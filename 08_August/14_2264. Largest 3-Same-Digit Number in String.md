# üöÄ 2264. Largest 3-Same-Digit Number in String

<div align="center">
    <img src="https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge" alt="Difficulty: Easy" />
    <a href="https://leetcode.com/problems/largest-3-same-digit-number-in-string/description/">
        <img src="https://img.shields.io/badge/LeetCode-Problem_Link-blue?style=for-the-badge&logo=leetcode" alt="Problem Link" />
    </a>
</div>

---

## üìù Problem Statement

You are given a string `num` representing a large integer. An integer is **good** if it meets the following conditions:

1.  It is a **substring** of `num` with a length of **3**.
2.  It consists of **only one unique digit**.

Return the **maximum good** integer as a string, or an empty string `""` if no such integer exists.

**Note:**
- A **substring** is a contiguous sequence of characters within a string.
- There may be **leading zeroes** in `num` or a good integer.

---

##  constraining a SHIP IN A BOTTLE
- `3 <= num.length <= 1000`
- `num` only consists of digits.

---

## üìã Examples

<div align="center">

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `"6777133339"` | `"777"` | There are two distinct good integers: "777" and "333". "777" is the largest. |
| `"2300019"` | `"000"` | "000" is the only good integer. |
| `"42352338"` | `""` | No substring of length 3 consists of only one unique digit. |

</div>

---

## üß† Approach & Explanation

The problem asks us to find the largest "good integer" within a given string `num`. A "good integer" is a three-character substring where all characters are the same digit.

The core idea is to iterate through the string and check every possible substring of length three. Since we need the *largest* good integer, we can simply keep track of the largest digit that forms such a substring.

Let's walk through it:
1. We can iterate through the string `num` starting from the third character (index 2), as we need a window of three characters to check (`i`, `i-1`, `i-2`).
2. In each iteration, we compare the current character `num[i]` with the previous two, `num[i-1]` and `num[i-2]`.
3. If all three characters are identical, we've found a "good integer".
4. We'll maintain a variable, let's call it `max_digit`, initialized to a character smaller than any digit (like a space ' ').
5. Whenever we find a good integer, we compare its digit (`num[i]`) with our `max_digit`. If the current digit is larger, we update `max_digit`.
6. After checking all possible substrings, if `max_digit` is still the initial placeholder value, it means no good integer was found, and we should return an empty string `""`.
7. Otherwise, we construct a new string of length three using the `max_digit` and return it.

This single-pass approach is efficient as it avoids creating substrings and performs simple character comparisons.

<details>
<summary>üí° Detailed Walkthrough (Example: num = "6777133339")</summary>

1.  **Initialize:** `maxChar = ' '` (a placeholder smaller than '0').
2.  **Loop Start:** `i = 2`.
    -   `num[2]` is '7', `num[1]` is '7', `num[0]` is '6'. They are not all equal.
3.  **`i = 3`:**
    -   `num[3]` is '7', `num[2]` is '7', `num[1]` is '7'. They are all equal.
    -   This is a good integer. The digit is '7'.
    -   Compare '7' with `maxChar` (' '). '7' is greater.
    -   Update `maxChar = '7'`.
4.  **`i = 4`:**
    -   `num[4]` is '1', `num[3]` is '7', `num[2]` is '7'. Not equal.
5.  **`i = 5`:**
    -   `num[5]` is '3', `num[4]` is '1', `num[3]` is '7'. Not equal.
6.  **`i = 6`:**
    -   `num[6]` is '3', `num[5]` is '3', `num[4]` is '1'. Not equal.
7.  **`i = 7`:**
    -   `num[7]` is '3', `num[6]` is '3', `num[5]` is '3'. They are all equal.
    -   This is a good integer. The digit is '3'.
    -   Compare '3' with `maxChar` ('7'). '3' is not greater. `maxChar` remains '7'.
8.  **`i = 8`:**
    -   `num[8]` is '3', `num[7]` is '3', `num[6]` is '3'. They are all equal.
    -   Good integer with digit '3'. Compare with `maxChar` ('7'). No update.
9.  **`i = 9`:**
    -   `num[9]` is '9', `num[8]` is '3', `num[7]` is '3'. Not equal.
10. **Loop End.**
11. **Final Check:** `maxChar` is '7', not the initial ' '.
12. **Return:** Construct a string of length 3 from `maxChar`: `"777"`.

</details>

---

## üíª Solution Code

### Brute-force Solution (C++)

This approach explicitly creates and checks every substring of length 3.

```cpp
// Intuition:
// The brute-force way is to check every single substring of length 3.
// For each substring, we verify if all its characters are identical.
// We keep track of the largest valid "good" integer string found so far.

// Approach:
// 1. Initialize an empty string `result` to store the maximum good integer.
// 2. Iterate through the input string `num` from the start up to the third-to-last character.
// 3. In each iteration, extract a substring of length 3.
// 4. Check if the three characters of the substring are the same.
// 5. If they are, it's a "good" integer. Compare this substring with the current `result`.
// 6. If the new substring is lexicographically larger than `result`, update `result`.
// 7. After the loop, return the `result` string.

// Time Complexity: O(n)
// The loop runs n-2 times. Substring creation and comparison take constant time (since length is fixed at 3).

// Space Complexity: O(1)
// We only use a few variables to store the result and the current substring. The space is constant regardless of input size.

class Solution {
public:
    string largestGoodInteger(string num) {
        string maxGoodInteger = ""; // Stores the maximum good integer found so far

        // Iterate through all possible start positions for a 3-digit substring
        for (int i = 0; i <= num.length() - 3; ++i) {
            // Extract the 3-digit substring
            string currentSub = num.substr(i, 3);
            
            // Check if it's a "good" integer (all digits are the same)
            if (currentSub[0] == currentSub[1] && currentSub[1] == currentSub[2]) {
                // If it's the first good integer found or larger than the current max, update it
                if (maxGoodInteger == "" || currentSub > maxGoodInteger) {
                    maxGoodInteger = currentSub;
                }
            }
        }
        
        return maxGoodInteger; // Return the largest one found
    }
};

/*
*
* Dry Run
* Input: num = "6777133339"
*
* Initial: maxGoodInteger = ""
*
* i = 0, currentSub = "677". Not good.
* i = 1, currentSub = "777". Is good. maxGoodInteger is updated to "777".
* i = 2, currentSub = "771". Not good.
* i = 3, currentSub = "713". Not good.
* i = 4, currentSub = "133". Not good.
* i = 5, currentSub = "333". Is good. Compare "333" with "777". "777" is larger, no change.
* i = 6, currentSub = "333". Is good. Compare "333" with "777". "777" is larger, no change.
* i = 7, currentSub = "339". Not good.
*
* Loop ends.
* Final Result: "777"
*
*/
```

### Optimized Solution (C++)

This approach avoids creating substrings and directly compares characters for better performance.

```cpp
// Intuition:
// To find the largest 3-same-digit number, we only need to find the largest digit that repeats 3 times consecutively.
// By iterating through the string and checking windows of three characters, we can track the maximum digit that satisfies this condition.

// Approach:
// 1. Initialize a character `maxChar` to a value lower than any digit (e.g., a space ' ') to act as a sentinel.
// 2. Iterate through the string from index 2 to the end.
// 3. For each index `i`, check if `num[i]`, `num[i-1]`, and `num[i-2]` are all equal.
// 4. If they are equal, it means we've found a "good" sequence. We then compare `num[i]` with our current `maxChar`.
// 5. If `num[i]` is greater than `maxChar`, we update `maxChar` to `num[i]`.
// 6. After the loop, if `maxChar` is still the sentinel value, no good integer was found, so we return an empty string.
// 7. Otherwise, we construct and return a string of length 3 consisting of `maxChar`.

// Time Complexity: O(n)
// We perform a single pass through the string of length n.

// Space Complexity: O(1)
// We only use a constant amount of extra space for the `maxChar` variable and the loop index.

class Solution {
public:
    string largestGoodInteger(string num) {
        // Initialize with a character smaller than any digit ('0')
        char maxChar = ' ';
        
        // Iterate from the third character to the end
        for(int i = 2; i < num.length(); i++) {
            // Check for three consecutive identical characters
            if(num[i] == num[i-1] && num[i] == num[i-2]) {
                // If found, update maxChar with the larger of the two
                maxChar = max(maxChar, num[i]);
            }
        }
        
        // If maxChar was never updated, no good integer was found
        // Otherwise, construct a string of length 3 with the max character
        return maxChar == ' ' ? "" : string(3, maxChar);
    }
};

/*
*
* Dry Run
* Input: num = "6777133339"
*
* Initial: maxChar = ' '
*
* i = 2: num[2]=='7', num[1]=='7', num[0]=='6'. Condition false.
* i = 3: num[3]=='7', num[2]=='7', num[1]=='7'. Condition true. maxChar = max(' ', '7') -> '7'.
* i = 4: num[4]=='1', num[3]=='7', num[2]=='7'. Condition false.
* i = 5: num[5]=='3', num[4]=='1', num[3]=='7'. Condition false.
* i = 6: num[6]=='3', num[5]=='3', num[4]=='1'. Condition false.
* i = 7: num[7]=='3', num[6]=='3', num[5]=='3'. Condition true. maxChar = max('7', '3') -> '7'.
* i = 8: num[8]=='3', num[7]=='3', num[6]=='3'. Condition true. maxChar = max('7', '3') -> '7'.
* i = 9: num[9]=='9', num[8]=='3', num[7]=='3'. Condition false.
*
* Loop ends.
* maxChar is '7' (not ' ').
* Return string(3, '7') which is "777".
*
*/
```

---

## üîë Key Insights

-   The problem asks for the **largest** good integer. This simplifies the logic, as we only need to track the single largest digit that forms a valid three-character sequence, rather than storing all possible good integer strings.
-   A single pass is sufficient. By using a sliding window of size three, we can check the condition efficiently without nested loops or complex data structures.
-   Handling the "no good integer" case can be cleanly managed by initializing our tracking variable (`maxChar`) to a sentinel value that is guaranteed to be less than any possible valid digit.

---

## üîé Further Exploration

-   Can you modify the solution to find the largest "good integer" of length `k`?
-   How would you approach this problem if you needed to return the count of all unique good integers?
-   Consider a variation where a "good integer" can be formed by any three identical characters in the string, not necessarily contiguous. How would that change your approach?

---

## üè∑Ô∏è Tags

<div align="center">
    <a href="https://leetcode.com/tag/string/"><img src="https://img.shields.io/badge/Topic-String-blue?style=for-the-badge" alt="String"></a>
    <a href="https://leetcode.com/tag/sliding-window/"><img src="https://img.shields.io/badge/Pattern-Sliding_Window-orange?style=for-the-badge" alt="Sliding Window"></a>
</div>

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/largest-3-same-digit-number-in-string/) for original content and copyright.**

---

## üë®‚Äçüíª Author

-   [imnilesh18](https://github.com/imnilesh18)