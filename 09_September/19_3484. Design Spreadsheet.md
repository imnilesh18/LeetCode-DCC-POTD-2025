# ‚ú® 3484. Design Spreadsheet

[![Problem Link](https://img.shields.io/badge/LeetCode-Link-blue?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/design-spreadsheet/description/)

---

## üöÄ Problem Statement

A spreadsheet is a grid with **26 columns** (labeled from `'A'` to `'Z'`) and a given number of **rows**. Each cell in the spreadsheet can hold an integer value.

We need to implement the `Spreadsheet` class with the following functionalities:

- `Spreadsheet(int rows)`: Initializes a spreadsheet with 26 columns and the specified number of rows. All cells are initially set to `0`.
- `setCell(String cell, int value)`: Sets the value of a specified cell (e.g., `"A1"`, `"B10"`).
- `resetCell(String cell)`: Resets a specified cell's value to `0`.
- `getValue(String formula)`: Evaluates a formula of the form `"=X+Y"`, where `X` and `Y` can be either cell references or non-negative integers, and returns the computed sum.

> **Note:** If `getValue` references a cell that has not been explicitly set, its value is considered `0`.

---

## üìã Constraints

- `1 <= rows <= 1000`
- `0 <= value <= 10^5`
- The formula is always in the format `"=X+Y"`.
- `X` and `Y` are either valid cell references or non-negative integers up to `10^5`.
- Cell references consist of a capital letter (`'A'`-`'Z'`) followed by a 1-indexed row number.
- At most `10^4` total calls will be made to the methods.

---

## üìä Examples

<details>
<summary><strong>Example 1 Walkthrough</strong></summary>

| Operation     | Input        | Output | Explanation                                       |
| :------------ | :----------- | :----- | :------------------------------------------------ |
| `Spreadsheet` | `[3]`        | `null` | Initialize a 3x26 grid.                           |
| `getValue`    | `["=5+7"]`   | `12`   | Returns `5 + 7 = 12`.                             |
| `setCell`     | `["A1", 10]` | `null` | Sets cell A1 to 10.                               |
| `getValue`    | `["=A1+6"]`  | `16`   | Returns value of A1 (10) + 6 = 16.                |
| `setCell`     | `["B2", 15]` | `null` | Sets cell B2 to 15.                               |
| `getValue`    | `["=A1+B2"]` | `25`   | Returns value of A1 (10) + value of B2 (15) = 25. |
| `resetCell`   | `["A1"]`     | `null` | Resets cell A1 to 0.                              |
| `getValue`    | `["=A1+B2"]` | `15`   | Returns value of A1 (0) + value of B2 (15) = 15.  |

</details>

---

## üí° Approach

The problem requires us to design a spreadsheet system, which is a classic data structure design problem. The most intuitive approach is to directly simulate the behavior of a spreadsheet using a 2D grid.

<details>
<summary><strong>Step-by-Step Walkthrough</strong></summary>

1.  **Data Structure**: We'll use a 2D integer vector (`vector<vector<int>> sheet`) to represent the grid. The constructor will initialize this grid with the given number of rows and 26 columns, filled with zeros.

2.  **Cell Coordinate Parsing**: The `setCell` and `resetCell` methods receive cell references as strings (e.g., "A1", "B10"). We need a consistent way to parse these into `(row, column)` indices for our 2D vector.

    - **Column**: The column can be derived from the first character. Since 'A' corresponds to column 0, 'B' to 1, and so on, we can calculate the column index as `col = cell[0] - 'A'`.
    - **Row**: The row number is the substring that follows the first character. We can extract it using `cell.substr(1)`. Since the problem specifies 1-indexed rows, we must convert it to a 0-indexed integer for our vector: `row = stoi(cell.substr(1)) - 1`.

3.  **Formula Evaluation (`getValue`)**: This is the core logic. The formula is always `"=X+Y"`.

    - First, we strip the leading `'='` character.
    - Next, we find the position of the `'+'` operator. This allows us to split the remaining string into two operands: `left` and `right`.
    - Since each operand (`left` or `right`) can be either an integer literal or a cell reference, we create a helper function, `solve(string s)`, to resolve its value.

4.  **Helper Function (`solve`)**: This function determines if the input string `s` is a number or a cell reference.

    - If the first character of `s` is a digit (`isdigit(s[0])`), we treat the entire string as an integer and return `stoi(s)`.
    - Otherwise, we assume it's a cell reference, parse it into `(row, col)` indices using the same logic as in step 2, and return the value from `sheet[row][col]`.

5.  **Final Calculation**: `getValue` calls `solve` on both the `left` and `right` operands and returns their sum: `return solve(left) + solve(right);`.

This simulation approach directly models the problem's requirements without needing complex algorithms, making it efficient and easy to implement.

</details>

---

## üíª Solution Code

```cpp
// Intuition: The problem can be solved by directly simulating a spreadsheet. We use a 2D vector to store cell values and parse string inputs to perform the required operations like setting a cell, resetting it, or evaluating a formula.
// Approach:
// 1. Initialize a 2D vector `sheet` of size `rows x 26` in the constructor.
// 2. For `setCell` and `resetCell`, parse the cell string (e.g., "A1") into row and column indices. The column is `cell[0] - 'A'` and the row is `stoi(cell.substr(1)) - 1`. Update the `sheet` accordingly.
// 3. For `getValue`, parse the formula `"=X+Y"` by finding the '+' to get the left ("X") and right ("Y") operands.
// 4. Create a helper function `solve` that takes an operand string.
// 5. Inside `solve`, check if the string is a number (starts with a digit). If yes, convert to int. If no, parse it as a cell reference and return the value from `sheet`.
// 6. The `getValue` function returns the sum of `solve(left)` and `solve(right)`.
// Time Complexity: Constructor -> O(rows), setCell/resetCell -> O(L) (length of cell string, effectively O(1)), getValue -> O(F) (length of formula)
// Space Complexity: O(rows) for storing the spreadsheet grid.
class Spreadsheet {
public:
    vector<vector<int>> sheet; // 2D vector to represent the spreadsheet grid

    Spreadsheet(int rows) {
        // Initialize the sheet with given rows, 26 columns, and default value 0
        sheet.assign(rows, vector<int>(26, 0));
    }

    void setCell(string cell, int value) {
        // Convert cell's first character to a 0-indexed column
        int col = cell[0] - 'A';
        // Convert the rest of the string to a 0-indexed row
        int row = stoi(cell.substr(1)) - 1;

        // Assign the value to the specified cell
        sheet[row][col] = value;
    }

    void resetCell(string cell) {
        // Parse column and row from the cell string
        int col = cell[0] - 'A';
        int row = stoi(cell.substr(1)) - 1;
        // Reset the cell's value to 0
        sheet[row][col] = 0;
    }

    // Helper function to resolve a string operand to its integer value
    int solve(string &s) {
        // Check if the operand is a number literal
        if(isdigit(s[0])) {
            return stoi(s); // Convert string to integer
        }

        // If not a number, it's a cell reference; parse it
        int col = s[0] - 'A';
        int row = stoi(s.substr(1)) - 1;

        // Return the value from the grid
        return sheet[row][col];
    }

    int getValue(string formula) {
        // Example formula: "=X+Y"
        string s = formula.substr(1); // Remove the leading '='
        int plusIdx = s.find('+'); // Find the position of the '+'

        // Extract the left and right operands
        string left = s.substr(0, plusIdx);
        string right = s.substr(plusIdx+1);

        // Resolve both operands and return their sum
        return solve(left) + solve(right);
    }
};

/*
*
* Dry Run
*
* Let's trace an example:
* 1. `spreadsheet.setCell("A1", 10)`
* - col = 'A' - 'A' = 0
* - row = stoi("1") - 1 = 0
* - sheet[0][0] is set to 10.
*
* 2. `spreadsheet.setCell("B2", 15)`
* - col = 'B' - 'A' = 1
* - row = stoi("2") - 1 = 1
* - sheet[1][1] is set to 15.
*
* 3. `spreadsheet.getValue("=A1+B2")`
* - `formula` = "=A1+B2"
* - `s` becomes "A1+B2"
* - `plusIdx` is 2.
* - `left` becomes "A1", `right` becomes "B2".
* - `solve(left)` i.e., `solve("A1")`:
* - It's not a digit.
* - col = 0, row = 0.
* - Returns `sheet[0][0]`, which is 10.
* - `solve(right)` i.e., `solve("B2")`:
* - It's not a digit.
* - col = 1, row = 1.
* - Returns `sheet[1][1]`, which is 15.
* - The function returns `10 + 15 = 25`.
*
*/
```

---

## üìù Notes

- The problem simplifies formula parsing by guaranteeing the `"=X+Y"` format, avoiding the need for a more complex expression evaluator.
- Properly handling the 1-based indexing for rows given in the input string is crucial for correct mapping to the 0-based indices of the 2D vector.
- The constraints are small enough that a direct simulation approach is perfectly efficient.

---

## üß† Key Insights

- **String Parsing**: The core of this problem lies in robustly parsing strings‚Äîboth for cell coordinates and for formulas. Using built-in string manipulation functions like `substr`, `find`, and `stoi` simplifies the implementation significantly.
- **Modularity**: Creating a helper function (`solve`) to handle the logic of resolving an operand (whether it's a cell or a literal value) makes the main `getValue` function cleaner and more readable. It isolates a piece of reusable logic.
- **Data Representation**: A 2D array or vector is the natural choice for representing a grid, making cell access an O(1) operation once the indices are known.

---

## üß≠ Further Exploration

- **More Complex Formulas**: How would you extend the `getValue` function to handle formulas with multiple operators (e.g., `"=A1+B2-C3"`) or different operators like `*` and `/`? This would require implementing operator precedence (PEMDAS/BODMAS), possibly using two stacks (one for values, one for operators).
- **Cell Dependencies**: What if a cell's value was a formula itself (e.g., setting cell C1 to `"=A1+B1"`)? This introduces the concept of a dependency graph. You would need to detect and handle circular dependencies (e.g., A1 depends on C1, and C1 depends on A1) and update cells recursively when a value they depend on changes.
- **Range-based Formulas**: Consider implementing functions that operate on ranges, like `SUM(A1:A10)`. This would involve parsing the range string and iterating through the corresponding cells.

---

## üìö References

- [LeetCode Problem: Design Spreadsheet](https://leetcode.com/problems/design-spreadsheet/description/)
- [std::string::substr](https://cplusplus.com/reference/string/string/substr/)
- [std::stoi](https://cplusplus.com/reference/string/stoi/)

---

## üè∑Ô∏è Tags

`Design` `Data Structure` `Simulation` `String`

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/design-spreadsheet/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
