# üìê 976. Largest Perimeter Triangle

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Easy-green" alt="Difficulty: Easy">
  <img src="https://img.shields.io/badge/Language-C++-blue.svg" alt="Language: C++">
  <img src="https://img.shields.io/badge/Topics-Array%2C%20Greedy%2C%20Sorting-orange" alt="Topics: Array, Greedy, Sorting">
</p>

---

## üìù Problem Statement

Given an integer array `nums`, return the **largest perimeter** of a triangle with a **non-zero area**, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return `0`.

---

## ‚õìÔ∏è Constraints

- `3 <= nums.length <= 10^4`
- `1 <= nums[i] <= 10^6`

---

## üß™ Examples

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [2, 1, 2]` | `5` | You can form a triangle with side lengths 1, 2, and 2. The perimeter is 1 + 2 + 2 = 5. |
| `nums = [1, 2, 1, 10]` | `0` | No three side lengths can form a triangle with a non-zero area. |

---

## üí° Approach & Explanation

The core of this problem lies in the **triangle inequality theorem**, which states that for any triangle with side lengths `a`, `b`, and `c`, the sum of the lengths of any two sides must be greater than the length of the third side.

1.  `a + b > c`
2.  `a + c > b`
3.  `b + c > a`

To find the **largest possible perimeter**, our intuition should guide us to use the largest available side lengths. This suggests a **greedy approach**.

If we sort the array in ascending order, let the three sides be `a ‚â§ b ‚â§ c`. The conditions `a + c > b` and `b + c > a` are automatically satisfied because `c` is the largest side. Therefore, we only need to check if `a + b > c`.

By sorting the `nums` array, we can iterate from the end (largest elements) and check this condition. We take three consecutive elements `nums[i]`, `nums[i+1]`, and `nums[i+2]`. Since the array is sorted, `nums[i] ‚â§ nums[i+1] ‚â§ nums[i+2]`. We check if `nums[i] + nums[i+1] > nums[i+2]`.

- If the condition is true, we have found a valid triangle. Because we are iterating from the largest elements, this triplet will form the largest possible perimeter. We can immediately return `nums[i] + nums[i+1] + nums[i+2]`.
- If the condition is false (`nums[i] + nums[i+1] <= nums[i+2]`), then `nums[i+2]` cannot form a triangle with any two smaller sides from the array. So, we can discard `nums[i+2]` and check the next set of three elements by decrementing our loop index.

If we iterate through all possible triplets and don't find a valid one, it's impossible to form a triangle, and we return `0`.

<details>
<summary>Click for a step-by-step walkthrough</summary>

Let's take `nums = [3, 6, 2, 3]`.

1.  **Sort the array**: `[2, 3, 3, 6]`
2.  **Start from the end**: We look at the last three elements as a potential triplet: `(3, 3, 6)`.
    -   Let `a = 3`, `b = 3`, `c = 6`.
    -   Check the triangle inequality: Is `a + b > c`?
    -   Is `3 + 3 > 6`? No, `6` is not greater than `6`. This is not a valid triangle.
3.  **Move to the next triplet**: We discard the largest element (`6`) and consider the next triplet from the end: `(2, 3, 3)`.
    -   Let `a = 2`, `b = 3`, `c = 3`.
    -   Check the triangle inequality: Is `a + b > c`?
    -   Is `2 + 3 > 3`? Yes, `5` is greater than `3`. This is a valid triangle.
4.  **Return the perimeter**: Since this is the first valid triangle we found while searching from the largest elements, it must have the largest perimeter. The perimeter is `2 + 3 + 3 = 8`.

</details>

---

## üíª Solution Code

### Brute-force Solution

```cpp
// Intuition: The most straightforward way is to check every possible combination of three side lengths from the array.
// Approach: Use three nested loops to generate all unique triplets (i, j, k). For each triplet, check if the side lengths (nums[i], nums[j], nums[k]) satisfy the triangle inequality theorem (a+b>c, a+c>b, b+c>a). If they do, calculate the perimeter and keep track of the maximum perimeter found so far.
// Time Complexity: O(n^3), due to the three nested loops iterating through the array.
// Space Complexity: O(1), as we only use a few variables to store the maximum perimeter.

class Solution {
public:
    int largestPerimeter(vector<int>& nums) {
        int max_perimeter = 0; // Initialize max perimeter to 0
        int n = nums.size();
        
        // Three nested loops to find all triplets
        for (int i = 0; i < n - 2; ++i) {
            for (int j = i + 1; j < n - 1; ++j) {
                for (int k = j + 1; k < n; ++k) {
                    int a = nums[i];
                    int b = nums[j];
                    int c = nums[k];
                    
                    // Check the triangle inequality theorem
                    if (a + b > c && a + c > b && b + c > a) {
                        // If it's a valid triangle, update the max perimeter
                        max_perimeter = max(max_perimeter, a + b + c);
                    }
                }
            }
        }
        return max_perimeter; // Return the largest perimeter found
    }
};

/*
*
* Dry Run
*
* Input: nums = [2, 1, 2]
*
* Triplet (2, 1, 2):
* a=2, b=1, c=2
* Check 1: 2 + 1 > 2 (True)
* Check 2: 2 + 2 > 1 (True)
* Check 3: 1 + 2 > 2 (True)
* Valid triangle. Perimeter = 2 + 1 + 2 = 5.
* max_perimeter = 5.
*
* Final Result: 5
*
*/
```

### Optimized Solution

```cpp
// Intuition: To get the largest perimeter, we should use the largest possible side lengths. This suggests a greedy approach. If we sort the sides as a <= b <= c, the triangle inequality simplifies to just checking if a + b > c.
// Approach: First, sort the array in ascending order. Then, iterate backwards from the end of the array, considering triplets of `(nums[i-2], nums[i-1], nums[i])`. The first triplet that satisfies `nums[i-2] + nums[i-1] > nums[i]` will form the largest possible perimeter, because we are using the largest available numbers. If we find such a triplet, we return its sum immediately. If the loop finishes without finding a valid triangle, it means no such triangle can be formed, so we return 0.
// Time Complexity: O(n log n), dominated by the sorting step. The loop runs in O(n).
// Space Complexity: O(1) or O(log n) to O(n), depending on the implementation of the sort algorithm.

class Solution {
public:
    int largestPerimeter(vector<int>& nums) {
        int n = nums.size(); // Get the size of the array
        
        // Sort the array in ascending order
        sort(begin(nums), end(nums));
        
        // Iterate from the end of the array to check for the largest sides first
        // We need at least 3 elements, so the loop starts from n-3
        for (int i = n - 3; i >= 0; i--) {
            // Let the three sides be a, b, c, where nums[i] <= nums[i+1] <= nums[i+2]
            // We only need to check if the sum of the two smaller sides is greater than the largest side.
            // The other two conditions (a+c > b and b+c > a) are always true because c is the largest.
            if(nums[i] + nums[i + 1] > nums[i + 2]){ // The crucial triangle inequality check
                // If the condition is met, we have found the largest perimeter.
                return nums[i] + nums[i + 1] + nums[i + 2];
            }
        }
        
        // If the loop completes, no valid triangle was found.
        return 0;
    }
};

/*
*
* Dry Run
*
* Input: nums = [1, 2, 1, 10]
*
* 1. Sort nums: [1, 1, 2, 10]
* 2. n = 4. Loop starts with i = n - 3 = 1.
*
* Iteration 1 (i = 1):
* - Triplet: (nums[1], nums[2], nums[3]) -> (1, 2, 10)
* - Check: nums[1] + nums[2] > nums[3] ?
* - Is 1 + 2 > 10?  (3 > 10) -> False.
*
* Loop condition `i >= 0` becomes false after i=0. The loop terminates.
*
* 3. No valid triangle found, return 0.
*
* Final Result: 0
*
*/
```

---

## üîë Key Insights

- **Greedy Choice**: To maximize the perimeter, it's always optimal to use the three largest possible side lengths that can form a valid triangle.
- **Sorting is Key**: Sorting simplifies the triangle inequality check. For sorted sides `a ‚â§ b ‚â§ c`, you only need to verify `a + b > c`. This significantly reduces the number of comparisons and makes the greedy approach feasible.

---

## üåê Further Exploration

- **Similar Problems**:
    - [LeetCode 3024. Type of Triangle](https://leetcode.com/problems/type-of-triangle/): A similar problem where you classify a triangle based on its side lengths.
    - [Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/): Count the number of triplets that can form a triangle.
- **Concepts**:
    - **Triangle Inequality Theorem**: A fundamental concept in geometry.
    - **Greedy Algorithms**: A class of algorithms that make the locally optimal choice at each stage with the hope of finding a global optimum.

---

## üìö References

- [LeetCode Problem Link](https://leetcode.com/problems/largest-perimeter-triangle/)
- [Triangle Inequality Theorem (Wikipedia)](https://en.wikipedia.org/wiki/Triangle_inequality)

---

## üè∑Ô∏è Tags

`Array` `Greedy` `Sorting` `Math`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/largest-perimeter-triangle/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)