# üèä 778. Swim in Rising Water

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Hard-red" alt="Difficulty: Hard" />
  <a href="https://leetcode.com/problems/swim-in-rising-water/description/" target="_blank">
    <img src="https://img.shields.io/badge/LeetCode-Problem%20Link-blue" alt="LeetCode Problem Link" />
  </a>
</p>

---

## üìù Problem Statement

You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.

It starts raining, and the water level rises over time. At time `t`, the water level is `t`. You can swim from a square to any 4-directionally adjacent square if and only if the elevation of **both** squares is at most `t`. You can swim infinite distances in zero time.

Your goal is to find the **minimum time** required to travel from the top-left square `(0, 0)` to the bottom-right square `(n - 1, n - 1)`.

---

## üìä Examples

| Input Grid | Output | Explanation |
| :--- | :--- | :--- |
| `[[0,2],[1,3]]` | `3` | At time `t=3`, all cells have an elevation less than or equal to the water level, making any path possible. Before `t=3`, it's impossible to reach `(1,1)`. |
| `[[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]` | `16` | You must wait until time `t=16` for a path to open up. The path's maximum elevation is 16, which determines the minimum time needed. |

---

## üß† Approach

This problem can be solved using two primary approaches: **Binary Search on the Answer** and **Dijkstra's Algorithm**. Both aim to find a path from the start to the end while minimizing the maximum elevation encountered.

<details>
<summary><strong>1. Binary Search on Answer + DFS/BFS</strong></summary>

### Intuition
The problem asks for the "minimum time," and the condition for being able to travel depends on time `t`. This structure hints at "minimizing the maximum" value (the time `t`). Whenever we need to minimize a maximum or maximize a minimum, **Binary Search on the Answer** is a powerful technique.

We can binary search for the minimum possible time `t`. For a given time `t`, we need to check if a path exists from `(0, 0)` to `(n - 1, n - 1)` such that every cell on the path has an elevation `grid[i][j] <= t`.

### Algorithm
1.  **Search Space**: The minimum possible time is `grid[0][0]`, and the maximum is `n*n - 1`. This defines our binary search range `[l, r]`.
2.  **Binary Search**:
    * Pick a `mid` time from the range `[l, r]`.
    * Check if it's possible to reach the destination `(n-1, n-1)` from `(0,0)` at time `mid`. This can be done with a simple **DFS or BFS**.
    * During the traversal (DFS/BFS), we can only visit cells `(i, j)` where `grid[i][j] <= mid`.
3.  **Adjust Range**:
    * If a path exists for `mid`, it means `mid` is a potential answer. We try for a smaller time by setting `r = mid - 1`.
    * If no path exists, `mid` is too small. We need to wait longer, so we set `l = mid + 1`.
4.  The final answer is the smallest `mid` for which a path was found.

</details>

<details>
<summary><strong>2. Dijkstra's Algorithm (Shortest Path on a Grid)</strong></summary>

### Intuition
This problem can be reframed as finding a "shortest path" in a weighted graph. The grid cells are the nodes. The weight of an edge between two cells isn't constant; instead, the "cost" of a path is the **maximum elevation** encountered along that path. We want to find a path from source to destination that minimizes this maximum cost.

Dijkstra's algorithm is perfect for finding the shortest path from a single source. We can adapt it by using a min-priority queue that prioritizes paths with a smaller "maximum elevation so far."

### Algorithm
1.  **Priority Queue**: Use a min-priority queue to store tuples of `(time, row, col)`. The queue will always give us the cell we can reach with the minimum time (maximum elevation).
2.  **Initialization**:
    * Push the starting cell `(grid[0][0], 0, 0)` into the priority queue. `grid[0][0]` is the initial time required.
    * Maintain a `result` or `distance` matrix to store the minimum time to reach each cell, initialized to infinity.
3.  **Exploration**:
    * While the priority queue is not empty, pop the element with the smallest time: `(currTime, i, j)`.
    * If this is the destination `(n-1, n-1)`, return `currTime`.
    * Explore its 4-directional neighbors `(i_, j_)`.
    * The time required to reach the neighbor is `nextTime = max(currTime, grid[i_][j_])`. This ensures we carry forward the maximum elevation seen on the path.
    * If `nextTime` is less than the previously recorded time to reach `(i_, j_)`, update the result and push `{nextTime, {i_, j_}}` to the priority queue.

</details>

---

## üíª Solution Code

### Approach 1: Binary Search + DFS

```cpp
// Intuition: The problem asks to find the minimum time 't' to reach the destination.
// This is a "minimize the maximum" problem, which is a classic signal for Binary Search on the Answer.
// For any given time 't', we can determine if a path exists. If it does, we try a smaller 't'; otherwise, we need a larger 't'.

// Approach:
// 1. Define a search space for the answer (time). The minimum time is at least grid[0][0] and the maximum is n*n - 1.
// 2. Binary search within this range [l, r].
// 3. For each 'mid' time, use a traversal (DFS or BFS) to check if a path exists from (0,0) to (n-1, n-1).
// 4. The traversal is only allowed to visit cells (i,j) where grid[i][j] <= mid.
// 5. If a path is found, 'mid' is a possible answer, so we try for a better (smaller) one: r = mid - 1.
// 6. If no path is found, 'mid' is too small, so we need more time: l = mid + 1.
// 7. The last valid 'mid' found is our minimum time.

// Time Complexity: O(n^2 * log(n^2)) = O(n^2 * log(n))
// The binary search performs log(n^2) iterations. In each iteration, we do a DFS which visits at most all n^2 cells.

// Space Complexity: O(n^2)
// The space is dominated by the 'visited' array for DFS and the recursion stack depth in the worst case.

class Solution {
public:
    int n;
    // Directions for 4-directional movement (Up, Down, Right, Left)
    vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    bool visited[50][50]; // Visited array for DFS to avoid cycles and redundant work

    // DFS function to check if destination is reachable at a given time 'mid'
    bool reachable(vector<vector<int>>& grid, int i, int j, int mid) {
        // Base cases for recursion termination
        if(i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || grid[i][j] > mid)
            return false; // Out of bounds, already visited, or cell elevation is too high
        
        visited[i][j] = true; // Mark current cell as visited
        
        // Check if we have reached the destination
        if(i == n-1 && j == n-1)
            return true;
        
        // Explore all 4-directionally adjacent neighbors
        for(vector<int> &dir : directions) {
            int new_i = i + dir[0];
            int new_j = j + dir[1];
            
            // If a path is found from any neighbor, propagate true up the call stack
            if(reachable(grid, new_i, new_j, mid))
                return true;
        }
        
        return false; // No path found from this cell
    }
    
    int swimInWater(vector<vector<int>>& grid) {
        n = grid.size();
        
        // Define the search space for binary search
        int l = grid[0][0], r = n*n-1;
        int result = 0;

        while(l <= r) {
            int mid = l + (r-l)/2; // Calculate the middle time to test
            
            // Reset visited array for each new DFS traversal
            memset(visited, 0, sizeof(visited));
            
            // Check if a path exists with the current 'mid' time
            if(reachable(grid, 0, 0, mid)) {
                result = mid; // 'mid' is a potential answer
                r = mid-1;    // Try for an even smaller time
            } else {
                l = mid+1;    // 'mid' is too small, need more time
            }
        }
        
        return result; // Return the minimum time found
    }
};
/*
*
* Dry Run
* grid = [[0,2],[1,3]], n = 2
*
* Search Range l=0, r=3
*
* Iteration 1:
* l=0, r=3 -> mid = 1
* reachable(grid, 0, 0, 1)?
* - Visit (0,0) since grid[0][0]=0 <= 1.
* - Neighbors of (0,0):
* - (0,1): grid[0][1]=2 > 1. Cannot visit.
* - (1,0): grid[1][0]=1 <= 1. Can visit.
* - Visit (1,0). Neighbors of (1,0): (0,0) (visited), (1,1) (grid[1][1]=3 > 1, cannot visit).
* - No path to (1,1) found. reachable returns false.
* l becomes mid+1 = 2.
*
* Iteration 2:
* l=2, r=3 -> mid = 2
* reachable(grid, 0, 0, 2)?
* - Visit (0,0). Neighbors:
* - (0,1): grid[0][1]=2 <= 2. Can visit.
* - Visit (0,1). Neighbors: (0,0) (visited), (1,1) (grid[1][1]=3 > 2, cannot visit).
* - (1,0): grid[1][0]=1 <= 2. Can visit.
* - Visit (1,0). Neighbors: (0,0) (visited), (1,1) (grid[1][1]=3 > 2, cannot visit).
* - No path to (1,1) found. reachable returns false.
* l becomes mid+1 = 3.
*
* Iteration 3:
* l=3, r=3 -> mid = 3
* reachable(grid, 0, 0, 3)?
* - Visit (0,0). Neighbors:
* - (0,1): grid[0][1]=2 <= 3. Visit (0,1).
* - Neighbors of (0,1): (1,1) (grid[1][1]=3 <= 3). Visit (1,1).
* - (1,1) is destination. Return true.
* Path found! reachable returns true.
* result = 3. r becomes mid-1 = 2.
*
* Loop terminates because l > r (3 > 2).
* Return result = 3.
*
*/
```

### Approach 2: Dijkstra's Algorithm

```cpp
// Intuition: The problem can be modeled as finding a shortest path in a graph where edge weights are not fixed.
// The "cost" of a path is the maximum elevation encountered. We want to find the path from (0,0) to (n-1, n-1)
// that minimizes this maximum cost. Dijkstra's algorithm is ideal for this, using a min-priority queue to
// always explore the path with the currently lowest maximum elevation.

// Approach:
// 1. Use a min-priority queue to store tuples of {time, {row, col}}. 'time' represents the max elevation on the path so far.
// 2. A 'result' matrix stores the minimum time (max elevation) to reach each cell, initialized to infinity.
// 3. Start with pq.push({grid[0][0], {0, 0}}) and result[0][0] = grid[0][0].
// 4. While the pq is not empty, extract the cell with the minimum time.
// 5. For each neighbor of the current cell:
//    a. Calculate the 'nextTime' to reach it: max(currentTime, neighbor_elevation).
//    b. If 'nextTime' is less than the recorded time in the 'result' matrix for that neighbor, it's a better path.
//    c. Update result[neighbor] = nextTime and push {nextTime, {neighbor_coords}} to the pq.
// 6. The first time we extract the destination cell (n-1, n-1) from the pq, its associated time is the answer.

// Time Complexity: O(n^2 * log(n^2)) = O(n^2 * log(n))
// Dijkstra's complexity is O(E log V), where V (vertices) = n^2 and E (edges) is at most 4*n^2.
// The log factor comes from priority queue operations.

// Space Complexity: O(n^2)
// For the priority queue and the 'result' matrix.

class Solution {
public:
    // Directions for 4-directional movement
    vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    // Type alias for the priority queue element for cleaner code
    using P = pair<int, pair<int, int>>; // {time, {i, j}}

    int swimInWater(vector<vector<int>>& grid) {
        int n = grid.size();
        // result[i][j] stores the minimum time to reach cell (i,j)
        vector<vector<int>> result(n, vector<int>(n, INT_MAX));
        
        // Min-heap priority queue, ordered by time
        priority_queue<P, vector<P>, greater<P>> pq; 
        
        // Initialize starting point
        result[0][0] = grid[0][0];
        pq.push({grid[0][0], {0, 0}});

        while (!pq.empty()) {
            // Get the cell reachable with the minimum time so far
            int currTime = pq.top().first;
            auto cell = pq.top().second;
            int i = cell.first;
            int j = cell.second;
            pq.pop();

            // If we reached the destination, this is the optimal path time
            if (i == n - 1 && j == n - 1)
                return currTime;

            // An optimization: if we found a shorter path to this cell already, skip
            if (currTime > result[i][j]) continue;

            // Explore neighbors
            for (auto& dir : directions) {
                int i_ = i + dir[0];
                int j_ = j + dir[1];
                
                // Check if neighbor is within grid bounds
                if (i_ >= 0 && i_ < n && j_ >= 0 && j_ < n) {
                    // The time to reach the neighbor is the max of current path's time and neighbor's elevation
                    int nextTime = max(currTime, grid[i_][j_]);

                    // If we found a better path to the neighbor
                    if (nextTime < result[i_][j_]) {
                        result[i_][j_] = nextTime; // Update the minimum time
                        pq.push({nextTime, {i_, j_}}); // Add to the queue to explore from here
                    }
                }
            }
        }

        return -1; // Should never be reached given the problem constraints
    }
};
/*
*
* Dry Run
* grid = [[0,2],[1,3]], n = 2
* result matrix = [[inf, inf], [inf, inf]]
* pq (min-heap): {}
*
* 1. Initialize:
* result[0][0] = 0
* pq.push({0, {0,0}}) -> pq: [{0, {0,0}}]
*
* 2. Loop 1:
* pq.pop() -> currTime=0, i=0, j=0
* Explore neighbors of (0,0):
* - Neighbor (0,1): elevation=2. nextTime = max(0, 2) = 2.
* result[0][1] > 2, so update result[0][1]=2, pq.push({2, {0,1}}).
* - Neighbor (1,0): elevation=1. nextTime = max(0, 1) = 1.
* result[1][0] > 1, so update result[1][0]=1, pq.push({1, {1,0}}).
* pq: [{1, {1,0}}, {2, {0,1}}]
*
* 3. Loop 2:
* pq.pop() -> currTime=1, i=1, j=0
* Explore neighbors of (1,0):
* - Neighbor (0,0): visited (result[0][0]=0 < max(1,0)=1, no update).
* - Neighbor (1,1): elevation=3. nextTime = max(1, 3) = 3.
* result[1][1] > 3, so update result[1][1]=3, pq.push({3, {1,1}}).
* pq: [{2, {0,1}}, {3, {1,1}}]
*
* 4. Loop 3:
* pq.pop() -> currTime=2, i=0, j=1
* Explore neighbors of (0,1):
* - Neighbor (0,0): visited.
* - Neighbor (1,1): elevation=3. nextTime = max(2, 3) = 3.
* result[1][1] is already 3, so no update (3 is not < 3).
* pq: [{3, {1,1}}]
*
* 5. Loop 4:
* pq.pop() -> currTime=3, i=1, j=1
* This is the destination (n-1, n-1).
* Return currTime = 3.
*
*/
```

---

## üí° Key Insights

-   **Minimize the Maximum**: This problem is a classic example of finding a path that minimizes the maximum value (bottleneck) along the path. This pattern strongly suggests either a binary search on the answer or a modified shortest path algorithm like Dijkstra's.
-   **Graph Modeling**: The grid can be seen as a graph where cells are vertices and adjacent cells have edges. The weight of traversing an edge isn't constant; it depends on the maximum elevation encountered so far.
-   **Monotonicity**: The core property that allows binary search is monotonicity. If a path is possible at time `t`, it is also possible for any time `t' > t`. This allows us to discard half of the search space in each step of the binary search.

## üöÄ Further Exploration

-   **Union-Find (Disjoint Set Union)**: Another advanced approach is to use a Union-Find data structure. You can sort all the `n*n` cells by their elevation. Iterate through the sorted cells, and for each cell `(i, j)`, "union" it with its already-visited neighbors that have a lower or equal elevation. The answer is the elevation of the first cell that connects the start `(0,0)` and end `(n-1, n-1)` components. This approach also yields a time complexity of roughly `O(n^2 * log(n^2))` due to sorting.

## üîó References

-   [Binary Search on Answer](https://www.topcoder.com/thrive/articles/Binary%20Search)
-   [Dijkstra's Algorithm](https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/)
-   [LeetCode Discuss Section](https://leetcode.com/problems/swim-in-rising-water/discuss/)

---

## üè∑Ô∏è Tags

`Array` `Binary Search` `Depth-First Search` `Breadth-First Search` `Union Find` `Graph` `Heap (Priority Queue)` `Matrix`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/swim-in-rising-water/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

-   [imnilesh18](https://github.com/imnilesh18)