# ü™Ñ 3539. Find Sum of Array Product of Magical Sequences

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Hard-red.svg" alt="Difficulty: Hard">
  <img src="https://img.shields.io/badge/Topics-Combinatorics-blue.svg" alt="Topic: Combinatorics">
  <img src="https://img.shields.io/badge/Topics-Bit%20Manipulation-blue.svg" alt="Topic: Bit Manipulation">
  <img src="https://img.shields.io/badge/Topics-Dynamic%20Programming-blue.svg" alt="Topic: Dynamic Programming">
</p>

<p align="center">
  <a href="https://leetcode.com/problems/find-sum-of-array-product-of-magical-sequences/description/">View Problem on LeetCode</a>
</p>

---

## üìù Problem Statement

You are given two integers, `m` and `k`, and an integer array `nums`.

A sequence of integers `seq` is called **magical** if:

1.  `seq` has a size of `m`.
2.  `0 <= seq[i] < nums.length`.
3.  The **binary representation** of `2^seq[0] + 2^seq[1] + ... + 2^seq[m-1]` has `k` set bits.

The **array product** of this sequence is defined as `prod(seq) = (nums[seq[0]] * nums[seq[1]] * ... * nums[seq[m-1]])`.

Return the **sum** of the **array products** for all valid **magical** sequences. Since the answer may be large, return it **modulo** `10^9 + 7`.

---

## ‚õìÔ∏è Constraints

- `1 <= k <= m <= 30`
- `1 <= nums.length <= 50`
- `1 <= nums[i] <= 10^8`

---

## üß™ Examples

| Input                                           | Output      |
| ----------------------------------------------- | ----------- |
| `m = 5, k = 5, nums = [1,10,100,10000,1000000]` | `991600007` |
| `m = 2, k = 2, nums = [5,4,3,2,1]`              | `170`       |
| `m = 1, k = 1, nums = [28]`                     | `28`        |

---

## üß† Approach

The problem asks for the sum of products of all "magical" sequences. A sequence is magical if it has length `m`, its elements are valid indices of `nums`, and the sum of `2` to the power of its elements has exactly `k` set bits.

A brute-force approach would be to generate all possible sequences of length `m` where indices can be repeated. For each sequence, we would calculate the sum `S = 2^seq[0] + 2^seq[1] + ...` and check if its binary representation has `k` set bits. If it does, we compute the product `P = nums[seq[0]] * nums[seq[1]] * ...` and add it to our total sum. This can be implemented with a recursive function `solve(count, current_sum)`, where `count` is the current length of the sequence. However, the `current_sum` can become extremely large, making memoization difficult and the approach too slow.

A more optimal approach uses **combinatorics and a digit-DP-like** strategy with bit manipulation. Instead of generating sequences, we consider the frequency of each index `i` from `0` to `n-1`.

The core challenge is calculating the sum `S` and its set bits without dealing with enormous numbers. We can process this sum bit by bit. Let's define a recursive function `solve(binarySum, m, k, i)` that calculates the desired sum for indices `i` to `n-1`, given:

- `binarySum`: A "carry" from the binary addition of previous bits.
- `m`: The number of elements we still need to choose for our sequence.
- `k`: The number of set bits we still need to find.
- `i`: The current index of `nums` we are considering.

At each step `i`, we can either **skip** the index `i` or **take** it `freq` times, where `1 <= freq <= m`.

1.  **Skip `i`**: We don't use index `i`. The `i`-th bit of the final sum depends only on the carry from the previous step. We update `k` by subtracting `binarySum & 1` and pass the new carry `binarySum >> 1` to the next state `solve(binarySum >> 1, m, k - (binarySum & 1), i+1, ...)`.

2.  **Take `i` `freq` times**: We use the index `i` exactly `freq` times. The new local binary sum at this bit position is `newBinarySum = binarySum + freq`. The current bit is `newBinarySum & 1`, and the new carry is `newBinarySum >> 1`.
    - We make a recursive call with updated parameters: `solve((newBinarySum >> 1), m - freq, k - (newBinarySum & 1), i+1, ...)`.
    - The product contribution from this choice is `(nums[i]^freq)` multiplied by the result of the recursive call.
    - We also need to account for all the ways to choose `freq` positions for `nums[i]` out of the remaining `m` spots, which is `nCr(m, freq)`. This requires pre-computing factorials and their modular inverses.

The base case for the recursion is when `m` becomes 0. If the remaining `k` and the set bits in the final `binarySum` are both zero, we have found a valid combination, so we return 1. Otherwise, we return 0.

This approach cleverly avoids large number arithmetic by processing the bitwise properties of the sum dynamically and combines it with combinatorial counting to find the total sum of products.

---

## üíª Solution Code

### Brute-Force with Memoization (TLE)

```cpp
// Intuition:
// The problem asks for the sum of products of all "magical" sequences. A magical sequence is defined by its length (m), the values of its elements (indices of nums), and a property of the sum of powers of 2 of its elements (k set bits).
// A straightforward way to solve this is to try and build every possible valid sequence of length 'm'. Since indices can be repeated, for each of the 'm' positions in the sequence, we can pick any index from 0 to N-1.
// We can use recursion to explore all these possibilities. A recursive function can keep track of the number of elements chosen so far and the running sum of 2^index. When we have chosen 'm' elements, we check if the sum has 'k' set bits. If so, we have found one valid combination.

// Approach:
// We define a recursive function `solve(count, sum, nums)`:
// - `count`: The number of elements we have picked for our sequence so far.
// - `sum`: The sum of 2^index for the elements picked.
// - Base Case: If `count == M`, we have a complete sequence of length M. We check if `__builtin_popcountll(sum) == K`. If it is, we return 1 (representing one valid sequence completion), otherwise 0.
// - Recursive Step: We iterate through all possible indices `i` from 0 to N-1. For each index `i`, we consider adding it to our sequence.
//   - The product for this path will be `nums[i]` multiplied by the result of subproblems.
//   - We make a recursive call `solve(count + 1, sum + (1LL << i), nums)`. This call will return the sum of products for the rest of the sequence.
//   - We multiply this result by `nums[i]` and add it to our total sum for the current state.
// - Memoization: The state is defined by `(count, sum)`. Since `sum` can be very large, we use a map with a string key `to_string(count) + "_" + to_string(sum)` to store the results of subproblems to avoid re-computation. This approach is still too slow because the `sum` state space is enormous.

// Time Complexity:
// O(M * N) after memoization, but the state `sum` can become extremely large (up to 2^N * M), making the number of states infeasible. Without memoization, it's O(N^M).

// Space Complexity:
// O(M * 2^N) for the memoization table, which is too large and impractical.

class Solution {
public:
    typedef long long ll;
    const int MOD = 1e9+7;
    int N, M, K;
    unordered_map<string, int> mp; // Memoization table

    ll solve(int count, ll sum, vector<int>& nums) {
        // Base case: if we have formed a sequence of length M
        if(count == M) {
            // Check if the sum has exactly K set bits
            return (__builtin_popcountll(sum) == K) ? 1 : 0;
        }

        // Create a unique key for the current state
        string key = to_string(count) + "_" + to_string(sum);
        if(mp.count(key)) {
            return mp[key]; // Return cached result
        }

        ll totalSum = 0;
        // Iterate through each number in nums to choose the next element
        for(int i = 0; i < N; i++) {
            // New sum if we pick index i
            ll newSum = sum + (1LL << i);

            // Calculate the product for this path and add to total
            // The recursive call returns the sum of products for the remaining part of the sequence
            ll prod = (nums[i] * solve(count+1, newSum, nums)) % MOD;

            totalSum = (totalSum + prod) % MOD;
        }

        // Cache the result for the current state and return it
        return mp[key] = totalSum;
    }

    int magicalSum(int m, int k, vector<int>& nums) {
        M = m;
        K = k;
        N = nums.size();

        // Start the recursion with an empty sequence
        return (int)(solve(0, 0, nums) % MOD);
    }
};

/*
*
* Dry Run
*
* Input: m = 2, k = 2, nums = [5, 4] (N=2)
*
* solve(0, 0):
* i = 0 (nums[0]=5):
* prod = 5 * solve(1, 1)
* solve(1, 1):
* i = 0 (nums[0]=5):
* prod = 5 * solve(2, 1 + (1<<0) = 2)
* solve(2, 2): count=m, popcount(2)=1 != k. return 0. -> prod = 0
* i = 1 (nums[1]=4):
* prod = 4 * solve(2, 1 + (1<<1) = 3)
* solve(2, 3): count=m, popcount(3)=2 == k. return 1. -> prod = 4
* totalSum = 0 + 4 = 4. mp[(1,1)]=4. return 4.
* prod = 5 * 4 = 20
* totalSum = 20
*
* i = 1 (nums[1]=4):
* prod = 4 * solve(1, 2)
* solve(1, 2):
* i = 0 (nums[0]=5):
* prod = 5 * solve(2, 2 + (1<<0) = 3)
* solve(2, 3): count=m, popcount(3)=2 == k. return 1. -> prod = 5
* i = 1 (nums[1]=4):
* prod = 4 * solve(2, 2 + (1<<1) = 6)
* solve(2, 6): count=m, popcount(6)=2 == k. return 1. -> prod = 4
* totalSum = 5 + 4 = 9. mp[(1,2)]=9. return 9.
* prod = 4 * 9 = 36
* totalSum = 20 + 36 = 56
*
* Final Answer = 56 (for this simplified example)
* The magical sequences are [0,1], [1,0], [1,1].
* Products: (5*4) + (4*5) + (4*4) = 20 + 20 + 16 = 56.
*
*/
```

### Optimized Solution (Combinatorics + Bit Manipulation DP)

```cpp
// Intuition:
// The brute-force approach fails due to the enormous state space of the sum. The key is to avoid calculating the large sum directly. Instead, we can process the sum bit-by-bit.
// The problem can be reframed using combinatorics. We need to choose 'm' indices in total. We can decide how many times (frequency) to pick each index 'i'.
// The final sum `S = sum(2^seq[j])` can be written as `S = freq[0]*2^0 + freq[1]*2^1 + ...`. We can perform this addition in binary, bit by bit, from right to left (i=0 to n-1), keeping track of a carry.

// Approach:
// We use a recursive function `solve(binarySum, m, k, i)` with memoization.
// - `binarySum`: This represents the "carry" from the previous less significant bits' calculations.
// - `m`: The remaining number of elements to choose.
// - `k`: The remaining number of set bits required.
// - `i`: The current index (and bit position `2^i`) we are considering.
//
// Base Cases:
// - If `m == 0`: We have chosen `m` elements. If the final `__builtin_popcount(binarySum) == k`, it's a valid combination, return 1.
// - If `m < 0`, `k < 0`, or `i >= N`: The path is invalid, return 0.
//
// Recursive Step for index `i`:
// We have two choices: skip `i` or take `i` some number of times.
// 1. Skip `i`:
//    - The contribution to the current bit `i` is 0. The sum at this bit is just the carry `binarySum`.
//    - The current bit's value is `binarySum & 1`. We update `k` accordingly.
//    - The new carry for the next state `i+1` is `binarySum >> 1`.
//    - We recurse: `solve((binarySum >> 1), m, k - (binarySum & 1), i+1, nums)`.
// 2. Take `i` `freq` times (where `1 <= freq <= m`):
//    - The sum at this bit position is `newBinarySum = binarySum + freq`.
//    - The current bit's value is `newBinarySum & 1`.
//    - The new carry is `newBinarySum >> 1`.
//    - The product contribution is `(nums[i]^freq)`.
//    - We need to choose `freq` positions out of `m` available spots, which is `nCr(m, freq)`.
//    - The total ways for this choice is `nCr(m, freq) * (nums[i]^freq) * solve(...)`.
//    - We sum this up for all possible frequencies `freq`.
//
// Precomputation:
// - To calculate `nCr % MOD` efficiently, we precompute factorials and their modular inverses using Fermat's Little Theorem.
// - We use binary exponentiation (`findPower`) to calculate powers and modular inverses.

// Time Complexity: O(N * M^2 * K)
// N is the number of indices, M is the max sequence length, and K is the number of set bits. The `binarySum` (carry) state grows slowly and is related to M, keeping the state space manageable. The inner loop runs M times.

// Space Complexity: O(N * M * K * log(M))
// The memoization table stores results for states (binarySum, m, k, i). The size of binarySum is roughly log(M).

class Solution {
public:
    typedef long long ll;
    const int MOD = 1e9+7;
    int N, K;

    // Memoization table using a map with a tuple key
    map<tuple<ll, int , int, int>, ll> memo;

    vector<ll> fact; // To store factorials
    vector<ll> invFact; // To store inverse factorials

    // Binary Exponentiation to calculate (a^b) % MOD
    ll findPower(ll a, ll b) {
        if(b == 0)
            return 1;

        ll half = findPower(a, b/2);
        ll result = (half * half) % MOD;

        if(b%2 == 1) {
            result = (result * a) % MOD;
        }

        return result;
    }

    // Calculate nCr % MOD using precomputed factorials and modular inverse
    ll nCr(int n, int r) {
        //nCr = n! * inv(r)! * inv(n-r)!
        return (((fact[n] * invFact[r]) % MOD) * invFact[n-r]) % MOD;
    }

    ll solve(ll binarySum, int m, int k, int i, vector<int>& nums) {
        // Base case: All 'm' elements have been chosen
        if(m == 0) {
            // Valid if the final carry has 'k' set bits
            return (__builtin_popcountll(binarySum) == k) ? 1 : 0;
        }

        // Base case: Invalid state (out of bounds or impossible)
        if (i >= N || k < 0) {
            return 0;
        }

        auto key = make_tuple(binarySum, m, k, i);
        if(memo.count(key)) {
            return memo[key]; // Return cached result
        }

        ll totalSum = 0;

        // Case 1: Skip index i
        // Pass the carry to the next bit, update k based on the current bit
        totalSum = (totalSum + solve((binarySum >> 1), m, k - (binarySum & 1), i+1, nums)) % MOD;

        // Case 2: Take index i `freq` number of times
        for(int freq = 1; freq <= m; freq++) {
            // Add freq to the carry to get the sum at the current bit
            ll newBinarySum = binarySum + freq;

            // Recurse for the next index
            ll prod = solve((newBinarySum >> 1), m - freq, k - (newBinarySum & 1), i+1, nums);

            // Multiply by (nums[i]^freq)
            prod = (findPower(nums[i], freq) * prod) % MOD;

            // Multiply by the number of ways to choose 'freq' positions from 'm'
            prod = (prod * nCr(m, freq)) % MOD;

            totalSum = (totalSum + prod) % MOD;
        }

        return memo[key] = totalSum; // Cache and return
    }

    int magicalSum(int m, int k, vector<int>& nums) {
        K = k;
        N = nums.size();

        // Precompute factorials and inverse factorials up to m
        fact.assign(m+1, 1);
        invFact.assign(m+1, 1);

        for(int i = 2; i <= m; i++) {
            fact[i] = (fact[i-1] * i) % MOD;
        }

        // Calculate modular inverse using Fermat's Little Theorem: a^(p-2) % p
        invFact[m] = findPower(fact[m], MOD-2);
        for(int i = m - 1; i >= 0; i--) {
            invFact[i] = (invFact[i+1] * (i+1)) % MOD;
        }

        // Start recursion from index 0
        return (int)(solve(0, m, k, 0, nums) % MOD);
    }
};

/*
*
* Dry Run
*
* Input: m = 2, k = 2, nums = [5, 4]
*
* solve(binarySum=0, m=2, k=2, i=0):
* Skip i=0:
* call solve(0 >> 1 = 0, m=2, k=2-(0&1)=2, i=1)
* solve(0, 2, 2, 1):
* Skip i=1:
* call solve(0, 2, 2, 2) -> i>=N, returns 0
* Take i=1, freq=1:
* newBinarySum = 0+1=1
* prod = solve(1>>1=0, 1, 2-(1&1)=1, 2) -> returns 0. prod=0
* Take i=1, freq=2:
* newBinarySum = 0+2=2
* prod = solve(2>>1=1, 0, 2-(2&1)=2, 2)
* solve(1,0,2,2): m=0, popcount(1)!=2, return 0. prod=0.
* Returns 0.
*
* Take i=0, freq=1:
* newBinarySum = 0+1=1
* prod_recursive = solve(1>>1=0, m=1, k=2-(1&1)=1, i=1)
* solve(0, 1, 1, 1):
* Skip i=1:
* solve(0, 1, 1, 2) -> returns 0
* Take i=1, freq=1:
* newBinarySum = 0+1=1
* solve(0, 0, 1-1=0, 2): m=0, popcount(0)==0, returns 1
* prod = (4^1) * 1 * nCr(1,1) = 4
* Returns 4
* prod = (5^1) * 4 * nCr(2,1) = 5 * 4 * 2 = 40
*
* Take i=0, freq=2:
* newBinarySum = 0+2=2
* prod_recursive = solve(2>>1=1, m=0, k=2-(2&1)=2, i=1)
* solve(1,0,2,1): m=0, popcount(1)!=2, return 0.
* prod = 0
*
* This is just a partial trace to illustrate the logic. The recursion explores all combinations of frequencies for each index,
* using bit manipulation to track the set bits property efficiently. The final result combines products and combinatorial ways.
*
*/
```

---

## üîë Key Insights

- **State Representation**: The core difficulty is the massive state space if we track the full sum of powers of two. The key insight is to realize we only need to process this sum bit-by-bit. The state can be simplified to `(carry, remaining_m, remaining_k, current_index)`. The carry (`binarySum`) remains small throughout the process.
- **Combinatorics**: Instead of building individual sequences, we think in terms of frequencies of indices. This allows us to group identical sequences and count them using combinations (`nCr`), which is much more efficient.
- **Modular Arithmetic**: For `nCr % MOD`, we cannot simply apply the modulo operator to a division. We must use **modular inverse**. Fermat's Little Theorem provides an efficient way to calculate `a^(-1) % p` as `a^(p-2) % p`, which can be computed using binary exponentiation.

---

## üöÄ Further Exploration

- **Digit DP**: The technique used here is analogous to Digit DP. In Digit DP, you build a number digit by digit while satisfying certain constraints. Here, we are building a binary number (the sum `S`) bit by bit.
- **Fermat's Little Theorem**: A fundamental theorem in number theory used for finding modular inverses when the modulus is a prime number.
- **Binary Exponentiation**: An efficient algorithm to compute `a^n` in `O(log n)` time, crucial for modular arithmetic operations.

---

## üîó References

- [Fermat's Little Theorem](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)
- [Binary Exponentiation](https://cp-algorithms.com/algebra/binary-exp.html)
- [Combinatorics and Modular Arithmetic](https://www.google.com/search?q=https://cp-algorithms.com/combinatorics/nCr_modulo.html)

---

## üè∑Ô∏è Tags

`Dynamic Programming`, `Bit Manipulation`, `Combinatorics`, `Math`, `Recursion`

---

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/find-sum-of-array-product-of-magical-sequences/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
