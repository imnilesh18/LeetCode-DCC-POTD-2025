# ‚ôüÔ∏è 2273. Find Resultant Array After Removing Anagrams

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Easy-green" alt="Difficulty: Easy">
  <a href="https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/description" target="_blank">
    <img src="https://img.shields.io/badge/Problem%20Link-LeetCode-blue" alt="Problem Link">
  </a>
  <img src="https://img.shields.io/badge/Language-C++-orange" alt="Language: C++">
  <img src="https://img.shields.io/badge/Tags-Array,%20String,%20Simulation-yellow" alt="Tags: Array, String, Simulation">
</p>

---

## üìù Problem Statement

You are given a **0-indexed** string array `words`. In one operation, you can select any index `i` such that `0 < i < words.length` and `words[i - 1]` and `words[i]` are **anagrams**, and then **delete** `words[i]` from the array. This process is repeated as long as such an index can be found.

Return the final state of the `words` array after all possible operations have been performed. An **Anagram** is a word formed by rearranging the letters of another word, using all the original letters exactly once.

---

## üìú Constraints

- `1 <= words.length <= 100`
- `1 <= words[i].length <= 10`
- `words[i]` consists of lowercase English letters.

---

## üìä Examples

| Input                                      | Output                  | Explanation                                                                                                                                                                                 |
| ------------------------------------------ | ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `words = ["abba","baba","bbaa","cd","cd"]` | `["abba","cd"]`         | 1. "bbaa" is an anagram of "baba", so "bbaa" is deleted. <br> 2. "baba" is an anagram of "abba", so "baba" is deleted. <br> 3. The second "cd" is an anagram of the first, so it's deleted. |
| `words = ["a","b","c","d","e"]`            | `["a","b","c","d","e"]` | No two adjacent strings are anagrams, so no operations are performed.                                                                                                                       |

---

## üß† Approach & Walkthrough

The core idea is to iterate through the array and build a new result array. We only add a word to our result if it is **not** an anagram of the previously added word.

<details>
<summary><strong>Step-by-Step Walkthrough</strong></summary>

1.  **Initialization**: The first word (`words[0]`) can never be deleted because the operation requires checking `words[i - 1]`, which is not possible for `i = 0`. So, we initialize our `result` array with `words[0]`.

2.  **Iteration**: We loop through the `words` array starting from the second element (`i = 1`).

3.  **Anagram Check**: In each iteration, we compare the current word `words[i]` with the **last word added to our `result` array** (`result.back()`). This `result.back()` represents the effective `words[i - 1]` after potential deletions.

4.  **Decision**:

    - If `words[i]` and `result.back()` are **not** anagrams, it means `words[i]` should be kept. We add it to our `result` array.
    - If they **are** anagrams, we effectively "delete" `words[i]` by simply not adding it to our `result` and moving to the next word.

5.  **Final Result**: After the loop finishes, the `result` array will contain the final list of words with all adjacent anagrams removed.

The most critical sub-problem is efficiently checking if two strings are anagrams. Several methods exist:

- **Sorting**: Sort both strings and check for equality. Simple but may be slow.
- **Frequency Map**: Use a hash map to count character frequencies for both strings and compare the maps.
- **Frequency Array**: Since all characters are lowercase English letters, a 26-element integer array is highly efficient. We can use one array: increment counts for characters in the first string and decrement for the second. If all final counts are zero, they are anagrams. This is the approach used in the optimized solution.

</details>

---

## üíª Solution Code

### Brute-Force (Using Sorting for Anagram Check)

```cpp
// Intuition: The most straightforward way to check for anagrams is to sort the strings. If two sorted strings are identical, they are anagrams.
// Approach: Iterate through the words array, comparing each word to the last valid word. Use a helper function that sorts copies of the strings to check if they are anagrams.
// Time Complexity: O(n * m log m), where n is the number of words and m is the maximum length of a word. Sorting each word takes O(m log m).
// Space Complexity: O(m) for storing the sorted copies of the strings during comparison.

class Solution {
public:
    // Helper function to check if two strings are anagrams by sorting
    bool isAnagram(string s1, string s2) {
        // Sort both strings
        sort(s1.begin(), s1.end());
        sort(s2.begin(), s2.end());
        // If sorted strings are equal, they are anagrams
        return s1 == s2;
    }

    vector<string> removeAnagrams(vector<string>& words) {
        vector<string> result;
        if (words.empty()) {
            return result;
        }

        // The first word is always included
        result.push_back(words[0]);

        // Iterate from the second word
        for (int i = 1; i < words.size(); ++i) {
            // Compare current word with the last word in the result list
            if (!isAnagram(words[i], result.back())) {
                result.push_back(words[i]);
            }
        }
        return result;
    }
};

/*
*
* Dry Run
* Input: words = ["abba", "baba", "bbaa", "cd", "cd"]
*
* 1. Initialize result = ["abba"].
* 2. i = 1, word = "baba". isAnagram("baba", "abba")? Sort "baba" -> "aabb". Sort "abba" -> "aabb". They are equal. True. Do nothing.
* 3. i = 2, word = "bbaa". result.back() is still "abba". isAnagram("bbaa", "abba")? Sort "bbaa" -> "aabb". True. Do nothing.
* 4. i = 3, word = "cd". result.back() is "abba". isAnagram("cd", "abba")? Sort "cd" -> "cd". Sort "abba" -> "aabb". False. Add "cd" to result. result = ["abba", "cd"].
* 5. i = 4, word = "cd". result.back() is "cd". isAnagram("cd", "cd")? True. Do nothing.
* 6. Loop ends. Return result: ["abba", "cd"].
*
*/
```

### Optimized Solution (Using Frequency Array)

```cpp
// Intuition: A highly efficient way to check for anagrams is by comparing character counts. Since all characters are lowercase English letters, a simple 26-element array can serve as a frequency map.
// Approach: We iterate through the input 'words' from the second element. For each word, we check if it's an anagram of the last word added to our 'result' vector. The anagram check is done using a helper function that counts character frequencies in a single 26-element array. If it's not an anagram, we add it to the result.
// Time Complexity: O(n * m), where 'n' is the number of words and 'm' is the average length of a word. We iterate through each word, and for each, we perform a character count, which takes O(m) time.
// Space Complexity: O(1) or O(k) where k is the number of unique words in the result, as we are creating a result vector. The space for the frequency array is constant O(26).

class Solution {
public:
    // Helper function to check if two strings are anagrams using a frequency array
    bool checkAnagram(string &s1, string& s2) {
        int arr[26] = {0}; // Initialize a frequency array for 26 lowercase letters

        // Increment frequency for each character in the first string
        for(char &ch : s1) {
            arr[ch-'a']++;
        }

        // Decrement frequency for each character in the second string
        for(char &ch : s2) {
            arr[ch-'a']--;
        }

        // If the strings are anagrams, all counts in the array must be zero
        for(int i = 0; i < 26; i++) {
            if(arr[i] != 0)
                return false; // Found a mismatch in character counts
        }

        return true; // All character counts match
    }

    vector<string> removeAnagrams(vector<string>& words) {
        int n = words.size(); // Get the total number of words

        vector<string> result; // This vector will store our final result

        result.push_back(words[0]); // The first word is always part of the result

        // Iterate through the words array starting from the second element
        for(int i = 1; i < n; i++) {
            // Check if the current word is NOT an anagram of the last word in the result
            if(!checkAnagram(words[i], result.back())) {
                result.push_back(words[i]); // If not an anagram, add it to the result
            }
        }

        return result; // Return the final filtered list of words
    }
};

/*
*
* Dry Run
*
* Input: words = ["abba", "baba", "bbaa", "cd", "cd"]
*
* Initial State:
* - result = []
*
* Step 1: Push words[0]
* - result.push_back("abba")
* - result is now ["abba"]
*
* Step 2: Loop i = 1
* - current word: "baba"
* - last result word: "abba"
* - checkAnagram("baba", "abba") returns true.
* - Do nothing.
*
* Step 3: Loop i = 2
* - current word: "bbaa"
* - last result word: "abba" (still "abba" because "baba" was not added)
* - checkAnagram("bbaa", "abba") returns true.
* - Do nothing.
*
* Step 4: Loop i = 3
* - current word: "cd"
* - last result word: "abba"
* - checkAnagram("cd", "abba") returns false.
* - result.push_back("cd")
* - result is now ["abba", "cd"]
*
* Step 5: Loop i = 4
* - current word: "cd"
* - last result word: "cd"
* - checkAnagram("cd", "cd") returns true.
* - Do nothing.
*
* End of Loop.
* Final Result: ["abba", "cd"]
*
*/
```

---

## üí° Key Insights

- **Greedy Approach**: The problem can be solved greedily. The decision to keep or remove a word `words[i]` only depends on the _last non-removed word_ before it.
- **Constant Space Anagram Check**: Using a fixed-size array (`int arr[26]`) for the anagram check is the most performant method here, as it avoids the overhead of sorting or hash map operations, leading to a linear time complexity relative to the string length.
- **In-Place vs. New Array**: While an in-place removal is possible, it would be more complex (e.g., using `vector::erase` which is O(n)). Building a new result array is simpler and more efficient for this problem's constraints.

## üöÄ Further Exploration

- What if the problem involved non-adjacent anagrams? How would the approach change?
- Consider the performance implications if the character set was not limited to lowercase English letters (e.g., Unicode). A hash map would be a more scalable solution in that case.
- How would you solve this if you were not allowed to use extra space for the `result` vector and had to modify the `words` vector in-place? (Hint: Two-pointer approach).

## üîó References

- [Anagrams](https://en.wikipedia.org/wiki/Anagram)
- [LeetCode Discussion on Anagrams](https://leetcode.com/discuss/explore/september-leetcoding-challenge-2021/1454474/anagrams)

---

## üè∑Ô∏è Tags

`Array` `String` `Simulation` `Anagram`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/find-resultant-array-after-removing-anagrams/description) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
