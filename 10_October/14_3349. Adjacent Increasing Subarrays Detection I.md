<div align="center">
  <h1>3349. Adjacent Increasing Subarrays Detection I</h1>
  <a href="https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i"><img src="https://img.shields.io/badge/Problem%20Link-LeetCode-blue?style=for-the-badge&logo=leetcode" alt="LeetCode Problem Link"></a>
</div>

<div align="center">
  <img src="https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge" alt="Difficulty: Easy">
  <img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="Language: C++">
  <img src="https://img.shields.io/badge/Tags-Array,Subarray-yellow?style=for-the-badge" alt="Tags: Array, Subarray">
</div>

---

## üìù Problem Statement

Given an array `nums` of `n` integers and an integer `k`, determine whether there exist **two adjacent subarrays** of length `k` such that both subarrays are **strictly increasing**.

Specifically, check if there are two subarrays starting at indices `a` and `b` (`a < b`), where:

- Both subarrays `nums[a...a + k - 1]` and `nums[b...b + k - 1]` are strictly increasing.
- The subarrays must be adjacent, meaning `b = a + k`.

Return `true` if it is possible to find two such subarrays, and `false` otherwise.

---

## üìä Constraints

- `2 <= nums.length <= 100`
- `1 < 2 * k <= nums.length`
- `-1000 <= nums[i] <= 1000`

---

## üìã Examples

<details>
<summary><strong>Example 1</strong></summary>

| Input                                 | Output |
| :------------------------------------ | :----- |
| `nums = [2,5,7,8,9,2,3,4,3,1], k = 3` | `true` |

**Explanation:**

- The subarray starting at index `2` is `[7, 8, 9]`, which is strictly increasing.
- The subarray starting at index `5` is `[2, 3, 4]`, which is also strictly increasing.
- These two subarrays are adjacent (`5 = 2 + 3`), so the result is `true`.

</details>

<details>
<summary><strong>Example 2</strong></summary>

| Input                                 | Output  |
| :------------------------------------ | :------ |
| `nums = [1,2,3,4,4,4,4,5,6,7], k = 5` | `false` |

**Explanation:** There are no two adjacent, strictly increasing subarrays of length 5.

</details>

---

## üí° Approach

<details>
<summary><strong>Brute-Force Approach</strong></summary>

The most straightforward way to solve this is to iterate through all possible starting positions for the first subarray and check if it and its adjacent counterpart meet the criteria.

1.  **Iterate:** Loop through the array with a starting index `start` from `0` up to `n - 2*k`. This ensures there's enough space for two adjacent subarrays of length `k`.
2.  **Check First Subarray:** For each `start`, check if the subarray `nums[start...start + k - 1]` is strictly increasing.
3.  **Check Second Subarray:** If the first subarray is increasing, check if the adjacent subarray `nums[start + k...start + 2*k - 1]` is also strictly increasing.
4.  **Return:** If both checks pass for any `start`, we can immediately return `true`. If the loop completes without finding such a pair, we return `false`.

A helper function `isIncreasing()` can be used to check if a given subarray is strictly increasing. This approach is simple but less efficient due to repeated checks.

</details>

<details>
<summary><strong>Optimized Approach (Single Pass)</strong></summary>

We can solve this problem in a single pass (`O(n)`) by tracking the lengths of consecutive increasing sequences. The core idea is to avoid redundant checks by identifying runs of increasing numbers.

1.  **Initialize:** We use two variables: `currRun` to track the length of the current increasing subarray and `prevRun` to store the length of the immediately preceding increasing subarray.
2.  **Iterate:** Traverse the array from the second element (`i = 1`).
3.  **Check Condition:**
    - If `nums[i] > nums[i-1]`, the current increasing run continues, so we increment `currRun`.
    - If `nums[i] <= nums[i-1]`, the increasing sequence is broken. We then update `prevRun = currRun` and reset `currRun` to `1` to start a new run.
4.  **Check for Solution:** At each step `i`, we check two conditions:
    - **Single Long Run:** Can the `currRun` alone contain two adjacent `k`-length subarrays? This is possible if `currRun >= 2 * k`. If so, we have found a solution.
    - **Two Adjacent Runs:** Can the `prevRun` and `currRun` together form the two required subarrays? Since they are adjacent, we just need to ensure each is long enough. This is true if `min(prevRun, currRun) >= k`.
5.  **Return:** If either of these conditions is met at any point, we return `true`. If we finish the loop, no such pair exists, and we return `false`.

This approach is optimal because it processes each element only once.

</details>

---

## üíª Solution Code

### Brute-Force Solution

```cpp
// Intuition:
// The problem asks for two *adjacent* strictly increasing subarrays of length k.
// A brute-force solution can systematically check every possible pair of adjacent subarrays.
// We can iterate through the array, treating each index `start` as the potential beginning of the first subarray.
// For each `start`, we define two consecutive segments of length k and verify if both are strictly increasing.

// Approach:
// 1. Iterate with a pointer `start` from index 0 up to `n - 2*k` to define the starting position of the first subarray.
// 2. In each iteration, define the first subarray from `start` to `start + k - 1` and the second from `start + k` to `start + 2*k - 1`.
// 3. Create a helper function `isIncreasing` that checks if a subarray within a given range `[start, end)` is strictly increasing.
// 4. Call this helper function for both subarrays.
// 5. If both calls return true, it means we have found a valid pair, so we return `true` immediately.
// 6. If the loop finishes without finding such a pair, return `false`.

// Time Complexity: O(n * k)
// The outer loop runs approximately `n - 2k` times (O(n)). Inside the loop, the `isIncreasing` function is called twice, each taking O(k) time.
// Thus, the total time complexity is O(n * k).

// Space Complexity: O(1)
// We are not using any extra space that scales with the input size. Only a few variables are used for iteration.

class Solution {
public:
    // Helper function to check if a subarray is strictly increasing
    bool isIncreasing(vector<int>& nums, int start, int end) {
        // Iterate from the second element of the subarray
        for(int i = start + 1; i < end; i++) {
            // If any element is not strictly greater than its predecessor, it's not increasing
            if(nums[i] <= nums[i - 1]) {
                return false; // Not strictly increasing
            }
        }
        return true; // The subarray is strictly increasing
    }

    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size(); // Get the size of the input array

        // Iterate through all possible starting positions for the first subarray
        // The loop condition ensures there's enough room for two adjacent subarrays of length k
        for(int start = 0; start + 2 * k <= n; start++) {
            // Check if the first subarray is strictly increasing
            bool first = isIncreasing(nums, start, start + k);
            // Check if the second (adjacent) subarray is strictly increasing
            bool second = isIncreasing(nums, start + k, start + 2 * k);

            // If both subarrays are strictly increasing, we found our answer
            if(first && second) {
                return true;
            }
        }

        // If the loop completes, no such pair of subarrays was found
        return false;
    }
};

/*
*
* Dry Run
*
* Input: nums = [2, 5, 7, 8, 9, 2, 3, 4, 3, 1], k = 3
* n = 10
*
* Loop 1: start = 0
* - first subarray: [2, 5, 7] -> isIncreasing = true
* - second subarray: [8, 9, 2] -> isIncreasing = false
* - continue
*
* Loop 2: start = 1
* - first subarray: [5, 7, 8] -> isIncreasing = true
* - second subarray: [9, 2, 3] -> isIncreasing = false
* - continue
*
* Loop 3: start = 2
* - first subarray: [7, 8, 9] -> isIncreasing = true
* - second subarray: [2, 3, 4] -> isIncreasing = true
* - first && second is true. Return true.
*
* Final Output: true
*/
```

### Optimized Solution

```cpp
// Intuition:
// Instead of re-calculating if a subarray is increasing again and again, we can iterate through the array once and
// keep track of the length of the current "run" of increasing numbers. When an increasing sequence breaks, we
// store its length and start a new run. We can then check if any single run is long enough to hold two k-length
// subarrays, or if two adjacent runs are each long enough (>= k).

// Approach:
// 1. Initialize `currRun = 1` (for the first element) and `prevRun = 0`.
// 2. Iterate through the array from the second element (i = 1).
// 3. If `nums[i] > nums[i-1]`, the increasing sequence continues, so increment `currRun`.
// 4. If `nums[i] <= nums[i-1]`, the sequence breaks. We store the length of the completed run in `prevRun` and reset `currRun` to 1.
// 5. After each update, check for two conditions:
//    a. `if (currRun >= 2 * k)`: A single increasing run is long enough to contain two adjacent k-length subarrays. Return true.
//    b. `if (min(currRun, prevRun) >= k)`: The previous run and the current run are adjacent and both are long enough. Return true.
// 6. If the loop completes without returning, no such subarrays exist. Return false.

// Time Complexity: O(n)
// We iterate through the array exactly once. Each step inside the loop is a constant time operation.

// Space Complexity: O(1)
// We only use a few integer variables (`n`, `currRun`, `prevRun`) to store state, which does not depend on the input size.

class Solution {
public:
    bool hasIncreasingSubarrays(vector<int>& nums, int k) {
        int n = nums.size(); // Get the size of the array

        int currRun = 1; // Length of the current strictly increasing run
        int prevRun = 0; // Length of the previous strictly increasing run

        // Iterate from the second element to compare with the previous one
        for(int i = 1; i < n; i++) {
            // Check if the current element continues the increasing trend
            if(nums[i] > nums[i - 1]) {
                currRun++; // Increment the length of the current run
            } else { // The increasing order is broken
                prevRun = currRun; // The current run becomes the previous run
                currRun = 1; // Start a new run of length 1
            }

            // Check if the current single run is long enough to hold two k-length subarrays
            if(currRun >= 2 * k) {
                // We can accommodate two subarrays of length >= k within this single run
                return true;
            }

            // Check if the previous run and the current run are two adjacent valid subarrays
            if(min(currRun, prevRun) >= k) {
                return true;
            }
        }

        // If the loop finishes, no valid configuration was found
        return false;
    }
};

/*
*
* Dry Run
*
* Input: nums = [2, 5, 7, 8, 9, 2, 3, 4, 3, 1], k = 3
* currRun = 1, prevRun = 0
*
* i = 1: nums[1]>nums[0] (5>2) -> currRun = 2
* i = 2: nums[2]>nums[1] (7>5) -> currRun = 3
* i = 3: nums[3]>nums[2] (8>7) -> currRun = 4
* i = 4: nums[4]>nums[3] (9>8) -> currRun = 5
* i = 5: nums[5]<=nums[4] (2<=9) -> break! prevRun=5, currRun=1. min(1,5)<3.
* i = 6: nums[6]>nums[5] (3>2) -> currRun = 2. min(2,5)<3.
* i = 7: nums[7]>nums[6] (4>3) -> currRun = 3. min(3,5)>=3. Return true.
*
* Final Output: true
*/
```

---

## üöÄ Key Insights

- The brute-force `O(n*k)` approach is intuitive but inefficient for larger constraints because it repeatedly scans the same elements.
- The optimized `O(n)` solution demonstrates a common pattern: use a single pass to gather information about properties (like "runs" of increasing numbers) to avoid re-computation. By storing the length of the `prevRun`, we can efficiently check for the condition between two adjacent but separate increasing sequences.

---

## üß≠ Further Exploration

- **Adjacent Increasing Subarrays Detection II**: What if the subarrays didn't have to be strictly adjacent? How would you modify the approach?
- **Varying Lengths**: What if the two subarrays could have different lengths, `k1` and `k2`?
- **Decreasing Subarrays**: Modify the code to find two adjacent strictly _decreasing_ subarrays.

---

## üîó References

- [LeetCode Problem: Adjacent Increasing Subarrays Detection I](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i)

---

## üè∑Ô∏è Tags

`Array` `Subarray` `Sliding Window` `Greedy`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
