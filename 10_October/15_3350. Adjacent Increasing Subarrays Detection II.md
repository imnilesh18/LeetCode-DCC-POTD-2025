# 3350. Adjacent Increasing Subarrays Detection II

<p align="center">
    <a href="https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/description/">
        <img src="https://img.shields.io/badge/LeetCode-Problem-blue?style=for-the-badge&logo=leetcode" alt="LeetCode Problem">
    </a>
    <img src="https://img.shields.io/badge/Difficulty-Medium-yellow?style=for-the-badge" alt="Difficulty: Medium">
</p>

---

## 📝 Problem Statement

Given an array `nums` of `n` integers, your task is to find the **maximum** value of `k` for which there exist **two adjacent** subarrays of length `k` each, such that both subarrays are **strictly increasing**. Specifically, check if there are **two** subarrays of length `k` starting at indices `a` and `b` (`a < b`), where:

- Both subarrays `nums[a..a + k - 1]` and `nums[b..b + k - 1]` are **strictly increasing**.
- The subarrays must be **adjacent**, meaning `b = a + k`.

Return the **maximum** possible value of `k`.

---

## 📊 Examples

| Input                               | Output |
| ----------------------------------- | ------ |
| `nums = [2,5,7,8,9,2,3,4,3,1]`      | `3`    |
| `nums = [1,2,3,4,4,4,4,5,6,7]`      | `2`    |

<details>
<summary><strong>Example 1 Walkthrough</strong></summary>

- **Input:** `nums = [2,5,7,8,9,2,3,4,3,1]`
- **Explanation:**
  - The subarray `[7, 8, 9]` (starting at index 2) is strictly increasing. Its length is 3.
  - The subarray `[2, 3, 4]` (starting at index 5) is also strictly increasing. Its length is 3.
  - These two subarrays are adjacent because the second one starts immediately after the first one ends (index 5 = index 2 + length 3).
  - Since we found two adjacent, strictly increasing subarrays of length 3, and no larger `k` is possible, the maximum `k` is 3.

</details>
<details>
<summary><strong>Example 2 Walkthrough</strong></summary>

- **Input:** `nums = [1,2,3,4,4,4,4,5,6,7]`
- **Explanation:**
  - The subarray `[1, 2]` (starting at index 0) is strictly increasing.
  - The subarray `[3, 4]` (starting at index 2) is strictly increasing.
  - These are adjacent (index 2 = index 0 + length 2).
  - The length `k` is 2. This is the maximum possible value.

</details>

---

## ⚙️ Constraints

- `2 <= nums.length <= 2 * 10^5`
- `-10^9 <= nums[i] <= 10^9`

---

## 💡 Approach

The problem asks for the maximum length `k` such that two adjacent subarrays of length `k` are both strictly increasing. This problem is an extension of its first part where `k` was given. Here, we need to find the optimal `k`.

The core idea is to iterate through the array while tracking the lengths of consecutive strictly increasing subarrays. We'll maintain two variables:
1.  `currRun`: The length of the current strictly increasing subarray we are traversing.
2.  `prevRun`: The length of the previously found strictly increasing subarray that comes just before the current one.

As we iterate through the array, we check if the current element is greater than the previous one.
- If `nums[i] > nums[i-1]`, it means the increasing streak continues, so we increment `currRun`.
- If `nums[i] <= nums[i-1]`, the streak is broken. The subarray that just ended becomes our "previous" run. So, we set `prevRun = currRun` and reset `currRun` to 1 for the new element `nums[i]`.

At each step, we update our maximum possible `k`. There are two scenarios to consider for finding a valid pair of adjacent subarrays:

1.  **Within a single long increasing subarray:** A single, long, strictly increasing subarray can be split into two smaller adjacent increasing subarrays. For a subarray of length `L`, we can form two adjacent subarrays of length `L / 2`.
    - We update `K = max(K, currRun / 2)`.

2.  **Across two adjacent increasing subarrays:** We might have two separate adjacent increasing subarrays. For example, `[2, 5, 8]` followed by `[3, 4, 6, 9]`. The first has length 3 (`prevRun`), and the second has length 4 (`currRun`). We can form two adjacent subarrays of length `min(3, 4) = 3`.
    - We update `K = max(K, min(currRun, prevRun))`.

By checking and updating `K` with the maximum of these two possibilities at every step of our single pass, we can efficiently find the global maximum `k`.

<details>
<summary><b>Dry Run: `nums = [2,5,7,8,9,2,3,4,3,1]`</b></summary>
<br>
- **Initialization:** `prevRun = 0`, `currRun = 1`, `K = 0`

- **i = 1:** `nums[1] (5) > nums[0] (2)`. `currRun` becomes 2.
  - `K = max(0, 2/2) = 1`
  - `K = max(1, min(2, 0)) = 1`

- **i = 2:** `nums[2] (7) > nums[1] (5)`. `currRun` becomes 3.
  - `K = max(1, 3/2) = 1`
  - `K = max(1, min(3, 0)) = 1`

- **i = 3:** `nums[3] (8) > nums[2] (7)`. `currRun` becomes 4.
  - `K = max(1, 4/2) = 2`
  - `K = max(2, min(4, 0)) = 2`

- **i = 4:** `nums[4] (9) > nums[3] (8)`. `currRun` becomes 5.
  - `K = max(2, 5/2) = 2`
  - `K = max(2, min(5, 0)) = 2`

- **i = 5:** `nums[5] (2) < nums[4] (9)`. Streak broken.
  - `prevRun = currRun` (which is 5). `currRun` resets to 1.
  - `K = max(2, 1/2) = 2`
  - `K = max(2, min(1, 5)) = 2`

- **i = 6:** `nums[6] (3) > nums[5] (2)`. `currRun` becomes 2.
  - `K = max(2, 2/2) = 2`
  - `K = max(2, min(2, 5)) = 2`

- **i = 7:** `nums[7] (4) > nums[6] (3)`. `currRun` becomes 3.
  - `K = max(2, 3/2) = 2`
  - `K = max(2, min(3, 5)) = 3` -> **K is updated to 3!**

- **i = 8:** `nums[8] (3) < nums[7] (4)`. Streak broken.
  - `prevRun = currRun` (which is 3). `currRun` resets to 1.
  - `K = max(3, 1/2) = 3`
  - `K = max(3, min(1, 3)) = 3`

- **i = 9:** `nums[9] (1) < nums[8] (3)`. Streak broken.
  - `prevRun = currRun` (which is 1). `currRun` resets to 1.
  - `K = max(3, 1/2) = 3`
  - `K = max(3, min(1, 1)) = 3`

- **End of loop.** Final Answer: `3`.
</details>

---

## 💻 Solution Code

```cpp
// Intuition:
// The goal is to find the maximum length 'k' for two adjacent, strictly increasing subarrays.
// This can be achieved by iterating through the array once and keeping track of the lengths of consecutive increasing runs.
// The maximum 'k' can arise from two scenarios:
// 1. A single long increasing run that can be split into two halves.
// 2. Two distinct, adjacent increasing runs.
// By checking both possibilities at each step, we can find the overall maximum.

// Approach:
// 1. Initialize 'prevRun' (length of the previous increasing run) to 0, 'currRun' (current run) to 1, and the result 'K' to 0.
// 2. Iterate through the array from the second element (i=1).
// 3. If nums[i] > nums[i-1], the increasing sequence continues, so increment 'currRun'.
// 4. If the sequence breaks (nums[i] <= nums[i-1]), the current run ends. We store its length in 'prevRun' and reset 'currRun' to 1 for the new element.
// 5. In every iteration, update 'K' by taking the maximum of its current value and two potential new values:
//    a. `currRun / 2`: This checks if the current run itself can be split into two valid subarrays.
//    b. `min(currRun, prevRun)`: This checks if we can form two adjacent subarrays using the boundary of the previous and current runs.
// 6. After the loop, 'K' will hold the maximum possible length.

// Time Complexity: O(N), where N is the number of elements in the array, because we perform a single pass through the array.
// Space Complexity: O(1), as we only use a few constant extra variables.

class Solution {
public:
    int maxIncreasingSubarrays(vector<int>& nums) {
        int n = nums.size(); // Get the size of the input array.

        int prevRun = 0; // Length of the previous strictly increasing subarray.
        int currRun = 1; // Length of the current strictly increasing subarray.
        
        int K = 0; // Stores the maximum k found so far.

        // Iterate through the array starting from the second element.
        for(int i = 1; i < n; i++) {
            
            // If the current element is greater than the previous, extend the current run.
            if(nums[i] > nums[i - 1]) {
                currRun++;
            } else {
                // If the increasing streak is broken, the current run becomes the previous run.
                prevRun = currRun;
                // Start a new run of length 1.
                currRun = 1;
            }

            // A single long run can be split in half.
            // Example: [1,2,3,4] (currRun=4) can give k=2 -> [1,2] and [3,4].
            K = max(K, currRun / 2);
            
            // Check if two adjacent runs can form the solution.
            // Example: [1,2,3] (prevRun=3) and [4,5] (currRun=2) -> min is 2, so k=2.
            K = max(K, min(currRun, prevRun));
        }

        return K; // Return the maximum k found.
    }
};

/*
*
* Dry Run
*
* Input: nums = [2,5,7,8,9,2,3,4,3,1]
* * i | nums[i] | nums[i-1] | Condition | prevRun | currRun | K
* ----------------------------------------------------------------
* - | -       | -         | -         | 0       | 1       | 0
* 1 | 5       | 2         | 5 > 2     | 0       | 2       | max(0, 1) = 1, max(1, 0) = 1 -> K=1
* 2 | 7       | 5         | 7 > 5     | 0       | 3       | max(1, 1) = 1, max(1, 0) = 1 -> K=1
* 3 | 8       | 7         | 8 > 7     | 0       | 4       | max(1, 2) = 2, max(2, 0) = 2 -> K=2
* 4 | 9       | 8         | 9 > 8     | 0       | 5       | max(2, 2) = 2, max(2, 0) = 2 -> K=2
* 5 | 2       | 9         | 2 < 9     | 5       | 1       | max(2, 0) = 2, max(2, 1) = 2 -> K=2
* 6 | 3       | 2         | 3 > 2     | 5       | 2       | max(2, 1) = 2, max(2, 2) = 2 -> K=2
* 7 | 4       | 3         | 4 > 3     | 5       | 3       | max(2, 1) = 2, max(2, 3) = 3 -> K=3
* 8 | 3       | 4         | 3 < 4     | 3       | 1       | max(3, 0) = 3, max(3, 1) = 3 -> K=3
* 9 | 1       | 3         | 1 < 3     | 1       | 1       | max(3, 0) = 3, max(3, 1) = 3 -> K=3
*
* Final Answer: 3
*
*/
```

---

## 🚀 Key Insights

-   The problem can be solved in a **single pass** with constant extra space, making it highly efficient.
-   The logic elegantly handles two distinct cases for forming the adjacent subarrays: either from within one continuous run or by combining two separate adjacent runs.
-   The use of `prevRun` and `currRun` is a classic pattern for problems involving streaks or contiguous properties in an array.

## 🧭 Further Exploration

-   Consider how the solution would change if the subarrays didn't need to be strictly adjacent but could have a small gap between them.
-   What if the subarrays had to be strictly decreasing instead of increasing? The logic would be very similar, just reversing the comparison operator.
-   Think about a variation where you need to find the count of all possible pairs of such adjacent subarrays for the maximum `k`.

## 📚 References

-   [LeetCode Problem Link](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/description/)
-   [Related Problem: Adjacent Increasing Subarrays Detection I](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-i/)

## 🏷️ Tags

`Array`, `Two Pointers`, `Greedy`

---

## 📄 License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/adjacent-increasing-subarrays-detection-ii/description/) for original content and copyright.**

---

## 👨‍💻 Author

-   [imnilesh18](https://github.com/imnilesh18)