# 2598. Smallest Missing Non-negative Integer After Operations

### [Problem Link](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/description/)

**Difficulty:** `Medium`

**Tags:** `Array`, `Hash Table`, `Math`, `Greedy`

## 📄 Problem Statement

You are given a **0-indexed** integer array `nums` and an integer `value`.

In one operation, you can add or subtract `value` from any element of `nums`.

- For example, if `nums = [1,2,3]` and `value = 2`, you can choose to subtract `value` from `nums[0]` to make `nums = [-1,2,3]`.

The **MEX** (minimum excluded) of an array is the smallest missing **non-negative** integer in it.

- For example, the MEX of `[-1,2,3]` is `0` while the MEX of `[1,0,3]` is `2`.

Return *the maximum MEX of `nums` after applying the mentioned operation any number of times*.

---

## 💡 Constraints

- `1 <= nums.length, value <= 10^5`
- `-10^9 <= nums[i] <= 10^9`

---

## 📋 Examples

| Input                               | Output | Explanation                                                                                                                                                                                                                                                           |
| ----------------------------------- | ------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `nums = [1,-10,7,13,6,8], value = 5` | `4`    | One can achieve this result by applying the following operations:<br>- Add `value` to `nums[1]` twice to make `nums = [1,0,7,13,6,8]`<br>- Subtract `value` from `nums[2]` once to make `nums = [1,0,2,13,6,8]`<br>- Subtract `value` from `nums[3]` twice to make `nums = [1,0,2,3,6,8]`<br>The MEX of `nums` is 4. It can be shown that 4 is the maximum MEX we can achieve. |
| `nums = [1,-10,7,13,6,8], value = 7` | `2`    | One can achieve this result by applying the following operation:<br>- subtract `value` from `nums[2]` once to make `nums = [1,-10,0,13,6,8]`<br>The MEX of `nums` is 2. It can be shown that 2 is the maximum MEX we can achieve.                                     |

---

## 🤔 Approach

The core idea of this problem revolves around the properties of the modulo operator. We can add or subtract `value` from any number `num` as many times as we want. This means we can transform `num` into any other number `x` as long as `num % value == x % value`. Our goal is to find the maximum possible MEX, which means we want to construct the longest possible sequence of non-negative integers starting from 0: `0, 1, 2, 3, ...`.

Let's see if we can form the number `k`. To form `k`, we need an element `num` in our array that can be transformed into `k`. This is possible if `num` and `k` have the same remainder when divided by `value`. In other words, `num % value == k % value`.

This simplifies the problem significantly. Instead of dealing with the large numbers in `nums`, we can focus on their remainders when divided by `value`. For any number `num`, the smallest non-negative number it can be transformed into is `num % value`. If `num` is negative, we can use the formula `((num % value) + value) % value` to get a positive remainder.

We can count the frequency of each possible remainder (from `0` to `value - 1`). An `unordered_map` is perfect for this. For each number in `nums`, we calculate its positive remainder modulo `value` and increment the count for that remainder in our map.

Once we have the frequency of all remainders, we can try to build our sequence `0, 1, 2, ...` greedily.
- We start by checking for `MEX = 0`. To form `0`, we need a number whose remainder modulo `value` is `0 % value = 0`. We check our frequency map. If the count for remainder `0` is greater than zero, we can form `0`. We "use up" one of these numbers by decrementing the count for remainder `0` and move on to check for `MEX = 1`.
- To form `1`, we need a number with remainder `1 % value = 1`. We check the map, and if available, we decrement its count and check for `MEX = 2`.
- We continue this process. For any target number `k`, we check if we have an available number with a remainder of `k % value`.

The first number `k` for which we cannot find a corresponding number in our map (i.e., the count for remainder `k % value` is zero) is our answer. This `k` is the smallest non-negative integer that we cannot form, which is the definition of the MEX.

---

## 💻 Solution Code

```cpp
// Intuition:
// The problem asks for the maximum possible MEX (Minimum Excluded non-negative integer) after applying operations.
// An operation consists of adding or subtracting `value` from any element. This implies that a number `num` can be transformed into any other number `x` if and only if `num % value == x % value`.
// So, we can reduce every number in `nums` to its smallest non-negative equivalent, which is its remainder when divided by `value`.
// The problem then becomes finding the smallest non-negative integer `k` that cannot be formed from the given numbers.
// We can count the frequencies of each remainder (`0` to `value-1`). Then, we can greedily check if we can form `0, 1, 2, ...`.
// To form a number `k`, we need a number from `nums` that can be transformed into `k`. This is possible if there's an available number with a remainder of `k % value`.
// We can iterate from `MEX = 0` upwards. For each `MEX`, we check if a number with remainder `MEX % value` is available (i.e., its count is > 0). If yes, we use one such number (decrement its count) and try the next `MEX`. The first `MEX` we cannot form is the answer.

// Approach:
// 1. Create a frequency map (or an array of size `value`) to store the counts of the remainders of each number in `nums` with respect to `value`.
// 2. Iterate through each `num` in the `nums` array.
// 3. For each `num`, calculate its non-negative remainder `r = ((num % value) + value) % value`. This formula correctly handles negative numbers.
// 4. Increment the frequency count for this remainder `r` in the map.
// 5. Initialize a variable `MEX = 0`. This will be our potential answer, starting from the smallest non-negative integer.
// 6. Start a `while` loop that continues as long as we can form the current `MEX`.
// 7. Inside the loop, check if the count of the remainder `MEX % value` in our map is greater than 0.
// 8. If it is, it means we can form the number `MEX`. So, we decrement the count for `mp[MEX % value]` and increment `MEX` to check for the next integer.
// 9. If the count is 0, it means we cannot form the current `MEX`. We break the loop.
// 10. The final value of `MEX` is the smallest non-negative integer that could not be formed, which is our answer.

// Time Complexity: O(N), where N is the length of `nums`. We iterate through `nums` once to populate the map (O(N)), and the while loop runs at most N+1 times because the MEX cannot be greater than N.
// Space Complexity: O(V), where V is the `value`, for storing the frequency map of remainders.

class Solution {
public:
    int findSmallestInteger(vector<int>& nums, int value) {
        // Use an unordered_map to store the frequency of remainders.
        unordered_map<int, int> mp;

        // Iterate through each number in the input array.
        for(int &num : nums) {
            // Calculate the non-negative remainder.
            // ((num % value) + value) ensures the result is positive even if num is negative.
            // The final % value handles cases where (num % value) was already positive.
            int r = ((num % value) + value) % value;

            // Increment the count for the calculated remainder.
            mp[r]++;
        }

        // Initialize MEX (Minimum Excluded) to 0.
        int MEX = 0;
        // Greedily check for 0, 1, 2, ...
        // We can form `MEX` if we have a number with remainder `MEX % value`.
        while(mp[(MEX % value)] > 0) {
            // If we can form MEX, decrement the count of the used remainder.
            mp[(MEX % value)]--;
            // Check for the next integer.
            MEX++;
        }

        // Return the first integer that cannot be formed.
        return MEX;
    }
};

/*
*
* Dry Run
*
* Input: nums = [1, -10, 7, 13, 6, 8], value = 5
*
* 1. Initialize `unordered_map<int, int> mp;`
*
* 2. Populate the map with remainders:
* - num = 1:  r = ((1 % 5) + 5) % 5 = 1. mp[1] = 1.
* - num = -10: r = ((-10 % 5) + 5) % 5 = (0 + 5) % 5 = 0. mp[0] = 1.
* - num = 7:  r = ((7 % 5) + 5) % 5 = 2. mp[2] = 1.
* - num = 13: r = ((13 % 5) + 5) % 5 = 3. mp[3] = 1.
* - num = 6:  r = ((6 % 5) + 5) % 5 = 1. mp[1] = 2.
* - num = 8:  r = ((8 % 5) + 5) % 5 = 3. mp[3] = 2.
*
* Final map `mp`: {0: 1, 1: 2, 2: 1, 3: 2}
*
* 3. Initialize `MEX = 0;`
*
* 4. `while` loop execution:
* - **MEX = 0**:
* - Check `mp[0 % 5]` which is `mp[0]`. It's 1 (> 0).
* - We can form 0.
* - Decrement `mp[0]` to 0.
* - Increment `MEX` to 1.
* - `mp` is now {0: 0, 1: 2, 2: 1, 3: 2}
*
* - **MEX = 1**:
* - Check `mp[1 % 5]` which is `mp[1]`. It's 2 (> 0).
* - We can form 1.
* - Decrement `mp[1]` to 1.
* - Increment `MEX` to 2.
* - `mp` is now {0: 0, 1: 1, 2: 1, 3: 2}
*
* - **MEX = 2**:
* - Check `mp[2 % 5]` which is `mp[2]`. It's 1 (> 0).
* - We can form 2.
* - Decrement `mp[2]` to 0.
* - Increment `MEX` to 3.
* - `mp` is now {0: 0, 1: 1, 2: 0, 3: 2}
*
* - **MEX = 3**:
* - Check `mp[3 % 5]` which is `mp[3]`. It's 2 (> 0).
* - We can form 3.
* - Decrement `mp[3]` to 1.
* - Increment `MEX` to 4.
* - `mp` is now {0: 0, 1: 1, 2: 0, 3: 1}
*
* - **MEX = 4**:
* - Check `mp[4 % 5]` which is `mp[4]`. It's 0 (not > 0).
* - We cannot form 4.
* - The loop condition `mp[4] > 0` is false. Loop terminates.
*
* 5. Return `MEX`, which is 4.
*
*/
```

---

## 🚀 Key Insights

- **Modulo is Key**: The ability to add or subtract `value` means any number `n` can be transformed into any other number `m` if they belong to the same remainder class (i.e., `n % value == m % value`). This reduces the problem from dealing with potentially large integers to a small, finite set of remainders.
- **Frequency Matters**: Simply storing the unique remainders in a set is not enough. We need to know *how many* numbers correspond to each remainder. For instance, if `nums = [0, 5]` and `value = 5`, both numbers have a remainder of `0`. The first `0` can be used to form the integer `0`, and the second one (originally `5`) can be used to form the integer `5` (since `5 % 5 == 0`). A frequency map correctly captures this, allowing us to build the sequence `0, 1, 2, 3, 4, 5, ...` as long as the necessary remainders are available.
- **Greedy Approach Works**: Since we are looking for the *smallest* missing non-negative integer, a greedy approach is optimal. We can simply start checking from 0 and move upwards one by one. The first number we fail to construct is guaranteed to be the MEX.

---

## 📚 Further Exploration

- **Follow-up Question:** What if you could only apply the operation at most `k` times for each element? How would the approach change?
- **Related Problems:**
  - [First Missing Positive](https://leetcode.com/problems/first-missing-positive/)
  - [Missing Number](https://leetcode.com/problems/missing-number/)
  - [Check if Array Pairs Are Divisible by k](https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/)

---

## 🔗 References

- **LeetCode Problem:** [Smallest Missing Non-negative Integer After Operations](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/description/)
- **Discussion:** [LeetCode Discussion Forum](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/discuss)

---

## 📄 License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/smallest-missing-non-negative-integer-after-operations/) for original content and copyright.**

---

## 👨‍💻 Author

- [imnilesh18](https://github.com/imnilesh18)