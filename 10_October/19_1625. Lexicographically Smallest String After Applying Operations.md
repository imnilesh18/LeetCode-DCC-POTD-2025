# 1625. Lexicographically Smallest String After Applying Operations

| | |
| :-- | :-- |
| **Problem Link** | <a href="https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/description" target="_blank">LeetCode</a> |
| **Difficulty** | <font color="orange">Medium</font> |
| **Tags** | `String`, `BFS`, `DFS` |

---

## üìù Problem Statement

You are given a string `s` of **even length** consisting of digits from `0` to `9`, and two integers `a` and `b`.

You can apply either of the following two operations any number of times and in any order on `s`:
1.  **Add `a`** to all odd indices of `s` (0-indexed). Digits post `9` are cycled back to `0`. For example, if `s = "3456"` and `a = 5`, `s` becomes `"3951"`.
2.  **Rotate `s`** to the right by `b` positions. For example, if `s = "3456"` and `b = 1`, `s` becomes `"6345"`.

Return the **lexicographically smallest** string you can obtain by applying the above operations any number of times on `s`.

---

## üìå Constraints

-   `2 <= s.length <= 100`
-   `s.length` is even.
-   `s` consists of digits from `0` to `9` only.
-   `1 <= a <= 9`
-   `1 <= b <= s.length - 1`

---

##  examples

| Input | Output | Explanation |
| :-- | :-- | :-- |
| `s = "5525", a = 9, b = 2` | `"2050"` | Start: "5525" -> Rotate: "2555" -> Add: "2454" -> ... -> Add: "2050". No smaller string is obtainable. |
| `s = "74", a = 5, b = 1` | `"24"` | Start: "74" -> Rotate: "47" -> Add: "42" -> Rotate: "24". No smaller string is obtainable. |
| `s = "0011", a = 4, b = 2` | `"0011"` | No sequence of operations yields a lexicographically smaller string. |

---

## üß† Approach & Explanation

This problem asks for the lexicographically smallest string reachable from an initial string `s` by applying two types of operations: an "add" operation and a "rotate" operation. Since these operations can be applied any number of times in any order, we are essentially exploring a state space where each unique string is a state.

The key insight is that the number of reachable states is **finite**.
1.  The **add** operation involves adding a value `a` to digits at odd indices, with results taken modulo 10 (e.g., `(digit + a) % 10`). This means a digit will eventually cycle back to its original value.
2.  The **rotate** operation on a string of length `n` also produces a finite number of unique strings (at most `n`).

Since we start at an initial state (`s`) and can transition to other states (new strings) via defined operations, this problem can be perfectly modeled as a **graph traversal**. Each string is a node, and an operation is an edge to a new node. Our goal is to find the lexicographically smallest node in this graph.

A **Breadth-First Search (BFS)** is an excellent algorithm for this task. It allows us to explore the state space layer by layer, ensuring we discover all reachable strings.

Here's the BFS strategy:
1.  Initialize a **queue** and add the starting string `s`.
2.  Use a **visited set** (e.g., `unordered_set`) to keep track of strings we have already processed to avoid cycles and redundant computations.
3.  Initialize a variable `smallestString` with the initial string `s`.
4.  While the queue is not empty, dequeue the current string `curr`.
5.  Compare `curr` with `smallestString` and update `smallestString` if `curr` is lexicographically smaller.
6.  Generate two new strings from `curr`:
    a.  **Add operation**: Create a new string by adding `a` to the digits at all odd indices of `curr`.
    b.  **Rotate operation**: Create another new string by rotating `curr` to the right by `b` positions.
7.  For each newly generated string, if it has not been visited before, add it to the queue and the visited set.
8.  Once the queue is empty, `smallestString` will hold the lexicographically smallest string found across all reachable states.

This approach guarantees that we explore every possible string that can be generated and correctly identify the smallest one.

---

## üíª Solution Code

```cpp
// Intuition:
// The problem can be modeled as a state-space search problem. Each unique string we can form is a "state".
// The given operations (add and rotate) are transitions between these states. Since we want to find the
// lexicographically smallest string among all reachable states, we can explore this state space using a
// graph traversal algorithm like Breadth-First Search (BFS). BFS is suitable here because it systematically
// explores all possible strings level by level from the starting string.

// Approach:
// 1. Use a queue for the BFS traversal, initialized with the starting string `s`.
// 2. Use an `unordered_set` called `visited` to keep track of strings that have already been processed to avoid cycles and redundant work.
// 3. Initialize a `smallestString` variable to `s`, which will be updated whenever a lexicographically smaller string is found.
// 4. Start the BFS loop: while the queue is not empty, dequeue a string `curr`.
// 5. Compare `curr` with `smallestString` and update `smallestString` if `curr` is smaller.
// 6. From `curr`, generate two new strings:
//    a. `add_op_str`: Apply the add operation (add `a` to odd indices, modulo 10).
//    b. `rotate_op_str`: Apply the rotate operation (rotate right by `b` positions).
// 7. For each new string, if it has not been visited, push it to the queue and add it to the `visited` set.
// 8. After the BFS completes, `smallestString` will hold the final answer.

// Time Complexity: O(n^2)
// In the worst-case, the number of states can be simplified. There are at most 'n' unique rotations. For each rotation, the number of states from additions depends on the cycle created by 'a' (at most 10 variations per odd-indexed digit). A loose upper bound on states can be considered O(n * 10) = O(n). For each state, we perform string operations (add/rotate) which take O(n) time. Total time complexity is roughly O(n * n) = O(n^2).

// Space Complexity: O(n^2)
// The space is dominated by the `visited` set and the `queue`. In the worst case, we might store O(n^2) unique strings of length n. Thus, the space complexity is O(n^2).

class Solution {
public:
    // Helper function to perform right rotation on the string
    void rotate(string &s, int b) {
        // A cool trick to rotate a string (or array) using three reverse operations
        reverse(begin(s), end(s));       // 1. Reverse the whole string
        reverse(begin(s), begin(s) + b); // 2. Reverse the first 'b' characters
        reverse(begin(s) + b, end(s));   // 3. Reverse the rest of the string
    }

    string findLexSmallestString(string s, int a, int b) {
        string smallestString = s; // Initialize with the starting string

        unordered_set<string> visited; // To keep track of visited states
        queue<string> que;             // Queue for BFS

        que.push(s);          // Start BFS with the initial string
        visited.insert(s);    // Mark it as visited

        while(!que.empty()) {
            string curr = que.front(); // Get the current string state
            que.pop();

            // Update the smallest string found so far
            if(curr < smallestString) {
                smallestString = curr;
            }

            // --- Operation 1: Add 'a' to odd-indexed digits ---
            string temp_add = curr;
            for(int i = 1; i < temp_add.length(); i += 2) {
                // Perform addition with wrap-around using modulo 10
                temp_add[i] = ((temp_add[i] - '0' + a) % 10) + '0';
            }

            // If this new string hasn't been visited, add it to the queue
            if(!visited.count(temp_add)) {
                visited.insert(temp_add);
                que.push(temp_add);
            }

            // --- Operation 2: Rotate the string by 'b' ---
            string temp_rotate = curr;
            rotate(temp_rotate, b);

            // If the rotated string hasn't been visited, add it to the queue
            if(!visited.count(temp_rotate)) {
                visited.insert(temp_rotate);
                que.push(temp_rotate);
            }
        }
        
        return smallestString; // Return the lexicographically smallest string found
    }
};

/*
*
* Dry Run
*
* Input: s = "5525", a = 9, b = 2
*
* 1. Initialize:
* - smallestString = "5525"
* - queue = ["5525"]
* - visited = {"5525"}
*
* 2. Dequeue "5525":
* - smallestString is "5525". No change.
* - Add operation: "5525" -> "5424". Add "5424" to queue and visited.
* - Rotate operation: "5525" -> "2555". Add "2555" to queue and visited.
* - queue = ["5424", "2555"]
*
* 3. Dequeue "5424":
* - "5424" is not smaller than "5525". No change to smallestString.
* - Add operation: "5424" -> "5323". Add "5323" to queue and visited.
* - Rotate operation: "5424" -> "2454". Add "2454" to queue and visited.
* - queue = ["2555", "5323", "2454"]
*
* 4. Dequeue "2555":
* - "2555" < "5525", so smallestString becomes "2555".
* - Add operation: "2555" -> "2454". "2454" is already visited.
* - Rotate operation: "2555" -> "5525". "5525" is already visited.
* - queue = ["5323", "2454"]
*
* ... (BFS continues)
*
* Later...
*
* Dequeue "2151":
* - "2151" < "2555", so smallestString becomes "2151".
* - Add operation: "2151" -> "2050". Add "2050" to queue and visited.
* - Rotate operation: "2151" -> "5121". Add "5121" to queue and visited.
*
* Dequeue "2050":
* - "2050" < "2151", so smallestString becomes "2050".
* - ... and so on.
*
* The process continues until the queue is empty. The final value of smallestString will be "2050".
*
*/
```

---

## üîë Key Insights

-   **State-Space Graph**: The problem can be visualized as finding a node in a graph. The strings are nodes, and the operations are directed edges. This insight turns a seemingly complex problem into a standard graph traversal.
-   **BFS for Exploration**: BFS is a natural choice for exploring all reachable states from a starting point. It guarantees that we will find every possible string.
-   **Finite States**: The modulo arithmetic in the "add" operation and the cyclic nature of rotation ensure that the number of possible states is finite, making traversal feasible.
-   **Memoization with a Visited Set**: Using a hash set to store visited states is crucial. It prevents re-processing the same string, avoiding infinite loops and significantly improving performance.

---

## üöÄ Further Exploration

-   **DFS Implementation**: Try solving this problem using Depth-First Search (DFS). The logic is very similar, but you would use a stack (or recursion) instead of a queue. Does the choice between BFS and DFS affect the outcome or performance in this specific problem?
-   **Varying Operations**: What if the "add" operation applied to even indices? Or what if the rotation was to the left? How would that change the state space?
-   **GCD Analysis**: The number of unique digits generated by the add operation `(d + k*a) % 10` depends on the greatest common divisor `gcd(a, 10)`. A deeper analysis of this could lead to a more precise time/space complexity bound.

---

## üîó References

-   This problem follows a pattern similar to other state-space search problems. For more examples, you can refer to problems like **[Open the Lock (LeetCode 752)](https://leetcode.com/problems/open-the-lock/)**, which also uses BFS to explore states.

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/lexicographically-smallest-string-after-applying-operations/) for original content and copyright.**

---

## üë®‚Äçüíª Author

-   [imnilesh18](https://github.com/imnilesh18)