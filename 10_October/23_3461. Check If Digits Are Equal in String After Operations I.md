# 3461. Check If Digits Are Equal in String After Operations I

**Problem Link:** [https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i/description/](https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i/description/)
**Difficulty:** `Easy`
**Tags:** `String`, `Simulation`, `Math`

---

## üìù Problem Statement

You are given a string `s` consisting of digits. Perform the following operation repeatedly until the string has exactly two digits:

1.  For each pair of consecutive digits in `s`, starting from the first digit, calculate a new digit as the sum of the two digits modulo 10.
2.  Replace `s` with the sequence of newly calculated digits, maintaining the order in which they are computed.

Return `true` if the final two digits in `s` are the same; otherwise, return `false`.

---

## ‚öôÔ∏è Constraints

* `3 <= s.length <= 100`
* `s` consists of only digits.

---

## üß™ Examples

<details>
<summary>Example 1</summary>

| Input  | Output | Explanation                                                                                                                                                                                                                  |
| :----- | :----- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `s = "3902"` | `true`   | Initially, `s = "3902"` <br> First operation: <br> `(s[0] + s[1]) % 10 = (3 + 9) % 10 = 2` <br> `(s[1] + s[2]) % 10 = (9 + 0) % 10 = 9` <br> `(s[2] + s[3]) % 10 = (0 + 2) % 10 = 2` <br> `s` becomes `"292"` <br> Second operation: <br> `(s[0] + s[1]) % 10 = (2 + 9) % 10 = 1` <br> `(s[1] + s[2]) % 10 = (9 + 2) % 10 = 1` <br> `s` becomes `"11"` <br> Since the digits in `"11"` are the same, the output is `true`. |

</details>

<details>
<summary>Example 2</summary>

| Input   | Output | Explanation                                                                                                                                    |
| :------ | :----- | :--------------------------------------------------------------------------------------------------------------------------------------------- |
| `s = "34789"` | `false`  | Initially, `s = "34789"`. <br> After the first operation, `s = "7157"`. <br> After the second operation, `s = "862"`. <br> After the third operation, `s = "48"`. <br> Since `'4' != '8'`, the output is `false`. |

</details>

---

## üí° Approach

The problem asks us to repeatedly apply an operation on a string of digits until its length becomes 2. The operation involves taking consecutive pairs of digits, summing them modulo 10, and forming a new string with these results. Finally, we check if the two digits in the resulting string are equal.

This is a simulation problem. We can directly implement the described process. A slight optimization can be made to avoid creating a new string in each step. Instead, we can modify the string **in-place**.

1.  Start with the initial string `s` and its length `n`.
2.  While the length `n` is greater than 2:
    * Iterate through the string from index `i = 0` to `n - 2`.
    * For each `i`, calculate the sum of the digits at `s[i]` and `s[i+1]` modulo 10.
        * Remember to convert characters to integers before adding (`s[i] - '0'`) and convert the result back to a character before storing (`result + '0'`).
    * Store the resulting character back into `s[i]`.
    * After the loop finishes (meaning one full operation is complete), decrement the length `n` by 1. This effectively ignores the last character of the current string in the next iteration, as the new string's length is always one less than the previous one.
3.  Once the loop terminates (when `n` becomes 2), compare the first two characters of the modified string (`s[0]` and `s[1]`).
4.  Return `true` if they are equal, `false` otherwise.

This in-place modification saves space compared to creating a new string in each step. The time complexity remains O(n¬≤) because the outer loop runs approximately `n` times, and the inner loop also runs up to `n` times in the worst case. The space complexity is O(1) as we modify the string in place.

---

## üíª Solution Code (Optimized)

```cpp
// Intuition: Simulate the process described in the problem statement. Repeatedly calculate the sum modulo 10 of adjacent digits and update the string until only two digits remain. Check if these last two digits are equal.
// Approach:
// 1. Get the length 'n' of the input string 's'.
// 2. Use a while loop that continues as long as 'n' > 2.
// 3. Inside the while loop, iterate from i = 0 to n - 2 (exclusive of n-1).
// 4. In each iteration, calculate the sum of digits s[i] and s[i+1] modulo 10.
//    - Convert char digits to int: (s[i] - '0') and (s[i+1] - '0').
//    - Calculate sum modulo 10: ((s[i] - '0') + (s[i+1] - '0')) % 10.
//    - Convert the result back to char: (... % 10) + '0'.
// 5. Update s[i] with the calculated character result. This modifies the string in-place for the next operation.
// 6. After the inner loop completes, decrement 'n' because the effective length of the string reduces by 1 in each operation.
// 7. Once the while loop finishes (n == 2), compare the first two characters (s[0] and s[1]).
// 8. Return true if s[0] == s[1], otherwise return false.
// Time Complexity: O(n^2), where n is the initial length of the string. The outer while loop runs O(n) times, and the inner for loop runs O(n) times in the worst case.
// Space Complexity: O(1), as we are modifying the string in-place and using only a few extra variables.
class Solution {
public:
    bool hasSameDigits(string s) {
        int n = s.length(); // Get initial length

        // Loop until string length is reduced to 2
        while(n > 2) {
            // Perform the operation on consecutive digits
            for(int i = 0; i < n-1; i++) {
                // Calculate (s[i] + s[i+1]) % 10 and update s[i]
                // Convert chars to ints, sum, take modulo, convert back to char
                s[i] = (((s[i] - '0') + (s[i+1] - '0')) % 10) + '0';
            }
            // Decrease the effective length of the string for the next iteration
            n--;
        }

        // Check if the final two digits are the same
        return s[0] == s[1];
    }
};

/*
*
* Dry Run
* Example: s = "3902"
*
* Initial: n = 4, s = "3902"
*
* Iteration 1 (while n > 2):
* i = 0: s[0] = ((3 + 9) % 10) + '0' = 2 + '0' = '2'. s becomes "2902"
* i = 1: s[1] = ((9 + 0) % 10) + '0' = 9 + '0' = '9'. s becomes "2902"
* i = 2: s[2] = ((0 + 2) % 10) + '0' = 2 + '0' = '2'. s becomes "2922"
* n-- => n = 3. Effective string for next iteration is "292".
*
* Iteration 2 (while n > 2):
* i = 0: s[0] = ((2 + 9) % 10) + '0' = 1 + '0' = '1'. s becomes "1922"
* i = 1: s[1] = ((9 + 2) % 10) + '0' = 1 + '0' = '1'. s becomes "1122"
* n-- => n = 2. Effective string for comparison is "11".
*
* While loop terminates (n is not > 2).
*
* Check: s[0] ('1') == s[1] ('1') ? Yes.
*
* Return: true
*
*/
```

---

## üîë Key Insights

* The problem can be solved by directly simulating the process described.
* In-place modification of the string (`s[i] = ...`) avoids the need for creating new strings, optimizing space complexity to O(1).
* Remember character-to-integer conversion (`char - '0'`) and integer-to-character conversion (`int + '0'`) when performing arithmetic operations on digit characters.
* Decrementing the length `n` after each full operation correctly handles the shrinking size of the effective string being processed.

---

## üî≠ Further Exploration

* Consider the constraints. If `s.length` were much larger, would O(n¬≤) be acceptable?
* Is there a mathematical pattern or property that could solve this without explicit simulation? (Hint: Consider the properties of modulo arithmetic). This leads to the "Part II" version of the problem, which often involves digit sums or digital roots.

---

## üìö References

* Modulo Arithmetic
* String Manipulation in C++

---

## üè∑Ô∏è Tags

`String`, `Simulation`, `Modulo Arithmetic`, `In-place Modification`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/check-if-digits-are-equal-in-string-after-operations-i/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)

---