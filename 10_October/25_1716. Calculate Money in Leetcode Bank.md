# 1716. Calculate Money in Leetcode Bank

<div align="center">
  <img src="https://img.shields.io/badge/LeetCode-Easy-brightgreen?style=for-the-badge&logo=leetcode" alt="LeetCode Easy Badge"/>
  <img src="https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge" alt="Difficulty Easy Badge"/>
  <img src="https://img.shields.io/badge/Topic-Math-blue?style=for-the-badge" alt="Math Badge"/>
  <img src="https://img.shields.io/badge/Topic-Simulation-lightgrey?style=for-the-badge" alt="Simulation Badge"/>
</div>

---

**Problem Link:** [https://leetcode.com/problems/calculate-money-in-leetcode-bank/description/](https://leetcode.com/problems/calculate-money-in-leetcode-bank/description/)

---

## üìù Problem Statement

Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.

- He starts by putting in $1 on Monday, the first day.
- Every day from Tuesday to Sunday, he will put in $1 more than the day before.
- On every subsequent Monday, he will put in $1 more than the previous Monday.

Given `n`, return the total amount of money he will have in the Leetcode bank at the end of the `nth` day.

---

## ‚öôÔ∏è Constraints

- `1 <= n <= 1000`

---

## Examples

<details>
<summary>Example Test Cases</summary>

| Input (`n`) | Output | Explanation                                                                                        |
| :---------- | :----- | :------------------------------------------------------------------------------------------------- |
| 4           | 10     | Total = 1 + 2 + 3 + 4 = 10                                                                         |
| 10          | 37     | Total = (1+2+3+4+5+6+7) + (2+3+4) = 28 + 9 = 37. Note: 2nd Monday starts with $2.                  |
| 20          | 96     | Total = (1+...+7) + (2+...+8) + (3+...+8 for 6 days) = 28 + 35 + (3+4+5+6+7+8) = 28 + 35 + 33 = 96 |

</details>

---

## ü§î Approach Explanation

### Approach 1: Simulation (Brute Force)

Simulate the process day by day, or week by week.
Keep track of the starting amount for the current Monday.
For each week (or the remaining days if less than 7), iterate through the days, add the corresponding amount to the total, and increment the daily amount.
After processing a week (or the remaining days), decrement `n` and increase the starting Monday amount for the next week.
Repeat until `n` becomes 0.

### Approach 2: Arithmetic Progression (AP) + Loop

Calculate the number of **complete weeks** (`terms = n / 7`).
The sums of money deposited each full week form an arithmetic progression: 28, 35, 42, ... (common difference `d = 7`).
Use the AP sum formula `Sum = (terms / 2) * (2 * first_term + (terms - 1) * d)` or `Sum = terms * (first_term + last_term) / 2` to calculate the total sum for the complete weeks. The first term is always 28 (1+2+...+7). The last term can be calculated using `last = first + (terms - 1) * 7`.
Calculate the **remaining days** (`remaining_days = n % 7`).
Determine the starting amount for the Monday of the **partial week** (`start_money = terms + 1`).
Loop through the `remaining_days`, adding `start_money`, `start_money + 1`, ..., to the total sum.

### Approach 3: Pure Arithmetic Progression (AP)

Calculate the sum for **complete weeks** using the AP formula as in Approach 2.
Calculate the **remaining days** (`remaining_days = n % 7`).
The amounts deposited during the remaining days also form an arithmetic progression. - The first term of this AP is `first_term_remain = terms + 1`. - The number of terms is `remaining_days`. - The common difference is 1. - The last term is `last_term_remain = first_term_remain + remaining_days - 1`.
Use the AP sum formula `Sum_remain = remaining_days * (first_term_remain + last_term_remain) / 2` to calculate the sum for the remaining days.
Add the sum for complete weeks and the sum for remaining days to get the final result. This avoids the loop for remaining days.

---

## üíª Solution Code

<details>
<summary>Approach 1: Simulation (Brute Force)</summary>

```cpp
// Intuition: Directly simulate the day-by-day deposit process as described in the problem. Track the money deposited each Monday and increment daily amounts.
// Approach:
// 1. Initialize `result = 0` and `monday_money = 1`.
// 2. Loop while `n > 0`.
// 3. Inside the loop, store the current Monday's starting amount in `money`.
// 4. Start an inner loop for the days of the current week (up to `min(n, 7)` days).
// 5. In the inner loop, add `money` to `result` and increment `money`.
// 6. After the inner loop, decrease `n` by 7 (or by the number of days processed if less than 7).
// 7. Increment `monday_money` for the next week's Monday.
// 8. Return `result`.
// Time Complexity: O(N) - The outer loop runs N/7 times, and the inner loop runs at most 7 times. Total operations are proportional to N.
// Space Complexity: O(1) - Only a few variables are used.
//T.C : O(N)
//S.C : O(1)
class Solution {
public:
    int totalMoney(int n) {
        int result = 0; // Initialize total money saved

        int monday_money = 1; // Starting money for the first Monday is $1

        // Loop until all days are processed
        while(n > 0) {

            int money = monday_money; // Money to deposit on the current day, starts with Monday's amount
            // Loop through the days of the current week (or remaining days if less than a full week)
            for(int day = 1; day <= std::min(n, 7); day++) {
                result += money; // Add daily deposit to the total result
                money++;         // Increment money for the next day
            }

            n -= 7;           // Decrease remaining days by 7 (a full week)
            monday_money++;   // Increment the starting amount for the next Monday
        }

        return result; // Return the total money saved
    }
};

/*
*
* Dry Run (n = 10)
*
* Initial: result = 0, monday_money = 1, n = 10
*
* Week 1:
* money = 1
* day 1: result = 0 + 1 = 1, money = 2
* day 2: result = 1 + 2 = 3, money = 3
* day 3: result = 3 + 3 = 6, money = 4
* day 4: result = 6 + 4 = 10, money = 5
* day 5: result = 10 + 5 = 15, money = 6
* day 6: result = 15 + 6 = 21, money = 7
* day 7: result = 21 + 7 = 28, money = 8
* n = 10 - 7 = 3
* monday_money = 1 + 1 = 2
*
* Week 2 (Partial):
* money = 2
* day 1 (day 8 total): result = 28 + 2 = 30, money = 3
* day 2 (day 9 total): result = 30 + 3 = 33, money = 4
* day 3 (day 10 total): result = 33 + 4 = 37, money = 5
* n = 3 - 7 = -4 (loop condition n > 0 becomes false)
* monday_money = 2 + 1 = 3
*
* Loop ends. Return result = 37.
*
*/
```

</details>

<details>
<summary>Approach 2: Optimized (AP + Loop)</summary>

```cpp
// Intuition: Calculate the sum for full weeks using the arithmetic progression formula and then loop through the remaining days.
// Approach:
// 1. Calculate the number of full weeks: `terms = n / 7`.
// 2. Calculate the sum for the first week: `first = 28`.
// 3. Calculate the sum for the last full week using the AP formula: `last = 28 + (terms - 1) * 7`.
// 4. Calculate the total sum for all full weeks using the AP sum formula: `result = terms * (first + last) / 2`.
// 5. Calculate the remaining days: `remaining_days = n % 7`.
// 6. Calculate the starting money for the first day of the partial week: `start_money = 1 + terms`.
// 7. Loop from `day = 1` to `remaining_days`.
// 8. In the loop, add `start_money` to `result` and increment `start_money`.
// 9. Return `result`.
// Time Complexity: O(1) - Arithmetic calculations take constant time. The loop for remaining days runs at most 6 times, which is constant.
// Space Complexity: O(1) - Only a few variables are used.
//T.C : O(1)
//S.C : O(1)
class Solution {
public:
    int totalMoney(int n) {
        int terms = n / 7; // Calculate the number of full weeks

        int first = 28; // Sum of money in the first full week (1+2+...+7)
        int last  = 28 + (terms - 1) * 7; // Sum of money in the last full week using AP formula: a + (n-1)d

        // Calculate the total sum for all full weeks using the sum of AP formula: n/2 * (a + l)
        int result = terms * (first + last) / 2;

        // Calculate the starting money for the first day of the remaining partial week
        int start_money = 1 + terms; // Monday money starts at (number of full weeks + 1)

        // Loop through the remaining days in the partial week
        for(int day = 1; day <= (n % 7); day++) {
            result += start_money; // Add the money for the current day
            start_money++;         // Increment the money for the next day
        }

        return result; // Return the final total money
    }
};

/*
*
* Dry Run (n = 10)
*
* terms = 10 / 7 = 1
* first = 28
* last = 28 + (1 - 1) * 7 = 28
* result = 1 * (28 + 28) / 2 = 28
*
* remaining_days = 10 % 7 = 3
* start_money = 1 + 1 = 2
*
* Loop for remaining days:
* day 1: result = 28 + 2 = 30, start_money = 3
* day 2: result = 30 + 3 = 33, start_money = 4
* day 3: result = 33 + 4 = 37, start_money = 5
*
* Loop ends. Return result = 37.
*
*/
```

</details>

<details>
<summary>Approach 3: Optimized (Pure AP)</summary>

```cpp
// Intuition: Calculate the sum for full weeks using AP formula and calculate the sum for the remaining days also using AP formula.
// Approach:
// 1. Calculate the number of full weeks: `terms = n / 7`.
// 2. Calculate the sum for the first week: `first = 28`.
// 3. Calculate the sum for the last full week using the AP formula: `last = 28 + (terms - 1) * 7`.
// 4. Calculate the total sum for all full weeks using the AP sum formula: `result = terms * (first + last) / 2`.
// 5. Calculate the remaining days: `remain = n % 7`.
// 6. If `remain > 0`:
//    a. Calculate the first term for the remaining days' AP: `first_term = (1 + terms)`.
//    b. Calculate the last term for the remaining days' AP: `last_term = first_term + remain - 1`.
//    c. Calculate the sum for the remaining days using the AP sum formula: `result += remain * (first_term + last_term) / 2`.
// 7. Return `result`.
// Time Complexity: O(1) - All calculations are arithmetic operations, taking constant time.
// Space Complexity: O(1) - Only a few variables are used.
//T.C : O(1)
//S.C : O(1)
class Solution {
public:
    int totalMoney(int n) {
        int terms = n / 7; // Calculate the number of full weeks

        int first = 28; // Sum of money in the first full week
        int last  = 28 + (terms - 1) * 7; // Sum of money in the last full week (AP formula for n-th term)

        // Calculate the total sum for all full weeks using the sum of AP formula
        int result = terms * (first + last) / 2;

        // Calculate the number of remaining days
        int remain = n % 7;

        // If there are remaining days, calculate their sum using AP formula
        if (remain > 0) {
            int first_term = (1 + terms);           // Money deposited on the first day of the partial week
            int last_term  = first_term + remain - 1; // Money deposited on the last day of the partial week
            // Add the sum of the remaining days using the AP sum formula
            result += remain * (first_term + last_term) / 2;
        }


        return result; // Return the final total money
    }
};

/*
*
* Dry Run (n = 10)
*
* terms = 10 / 7 = 1
* first = 28
* last = 28 + (1 - 1) * 7 = 28
* result = 1 * (28 + 28) / 2 = 28
*
* remain = 10 % 7 = 3
*
* if (remain > 0) is true:
* first_term = 1 + 1 = 2
* last_term = 2 + 3 - 1 = 4
* result += 3 * (2 + 4) / 2 = 3 * 6 / 2 = 9
* result = 28 + 9 = 37
*
* Return result = 37.
*
*/
```

</details>

---

## ‚ú® Notes

- The problem has a clear pattern based on weeks.
- The daily increase and the weekly Monday increase suggest an arithmetic progression.
- Approach 1 is intuitive but less efficient for very large `n` (though constraints are small here).
- Approaches 2 and 3 leverage mathematical formulas for O(1) time complexity, making them highly efficient. Approach 3 is slightly cleaner by using AP for the remaining days as well.

---

## üîë Key Insights

- Recognizing the weekly deposit pattern as two superimposed arithmetic progressions (one for the weekly sums with $d=7$, and one for the daily amounts within a week with $d=1$).
- Using AP sum formulas significantly optimizes the calculation compared to direct simulation.
- Handling the partial week (remaining days) separately is crucial. Both looping (Approach 2) and AP formula (Approach 3) work efficiently due to the small maximum number of remaining days (\<= 6).

---

## üöÄ Further Exploration

- What if the daily increment was different from $1?
- What if the Monday increment was different from $1?
- How would the solution change if `n` could be very large (e.g., $10^9$)? (Consider potential overflow issues with intermediate sums).

---

## üìö References

- [Arithmetic Progression Formulas](https://www.cuemath.com/algebra/arithmetic-progression-formula/)
- [LeetCode Problem Discussion](https://leetcode.com/problems/calculate-money-in-leetcode-bank/discuss/)

---

## \#Ô∏è‚É£ Tags

`Math`, `Simulation`, `Arithmetic Progression`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/calculate-money-in-leetcode-bank/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
