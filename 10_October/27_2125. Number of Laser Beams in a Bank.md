# 2125. Number of Laser Beams in a Bank

[![LeetCode](https://img.shields.io/badge/LeetCode-2125-FFA116?style=for-the-badge&logo=leetcode)](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/description/)
[![Difficulty](https://img.shields.io/badge/Difficulty-Medium-yellow?style=for-the-badge)](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/description/)

---

## üìù Problem Statement

Anti-theft security devices are activated inside a bank. You are given a **0-indexed** binary string array `bank` representing the floor plan of the bank, which is an `m x n` 2D matrix. `bank[i]` represents the `ith` row, consisting of `'0'`s and `'1'`s. `'0'` means the cell is empty, while `'1'` means the cell has a security device.

There is **one** laser beam between any **two** security devices if **both** conditions are met:

1.  The two devices are located on two **different rows**: `r1` and `r2`, where `r1 < r2`.
2.  For **each** row `i` where `r1 < i < r2`, there are **no security devices** in the `ith` row.

Laser beams are independent, i.e., one beam does not interfere nor join with another.

Return _the total number of laser beams in the bank_.

---

## ‚öôÔ∏è Constraints

- `m == bank.length`
- `n == bank[i].length`
- `1 <= m, n <= 500`
- `bank[i][j]` is either `'0'` or `'1'`.

---

## üß™ Examples

| Input                                          | Output | Explanation                                                                                                                                                                                                                         |
| :--------------------------------------------- | :----- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `bank = ["011001","000000","010100","001000"]` | `8`    | Between `bank[0]` & `bank[2]`: 3 devices _ 2 devices = 6 beams.<br>Between `bank[2]` & `bank[3]`: 2 devices _ 1 device = 2 beams.<br>Total = 6 + 2 = 8 beams. <br>Note: No beams between row 0 and row 3 because row 2 has devices. |
| `bank = ["000","111","000"]`                   | `0`    | No two devices are on different rows with no devices in between.                                                                                                                                                                    |

---

## ü§î Explanation

<details>
<summary>Click to view Detailed Explanation</summary>

The problem asks us to calculate the total number of laser beams connecting security devices located in a bank represented by a grid (`bank`). A laser beam connects two devices (`d1` at row `r1`, `d2` at row `r2`, with `r1 < r2`) if and only if:

1. They are in different rows (`r1 != r2`).
2. All rows strictly between `r1` and `r2` (i.e., rows `r1+1` to `r2-1`) contain **zero** security devices.

The key insight is that beams only form between rows that contain devices, and only if the intermediate rows are completely empty. Consider two rows, `row_A` and `row_B`, both containing security devices, with `row_A` appearing before `row_B`. If all rows between `row_A` and `row_B` are empty (contain only '0's), then every device in `row_A` will connect to every device in `row_B`.

Let `count_A` be the number of devices in `row_A` and `count_B` be the number of devices in `row_B`. The number of beams connecting these two rows will be `count_A * count_B`.

We can iterate through the rows of the bank grid. We need to keep track of the number of devices in the _previous_ row that contained any devices. Let's call this `prevDeviceCount`.

1. Initialize `totalBeams = 0` and `prevDeviceCount = 0`.
2. Iterate through each `row` from `i = 0` to `m-1`:
   a. Calculate the number of devices in the current row, `currDeviceCount`. Count the number of '1's in `bank[i]`.
   b. If `currDeviceCount > 0`:
   i. This row has devices. We can potentially form beams with the `prevDeviceCount`. The number of beams formed between the _previous device row_ and the _current row_ is `prevDeviceCount * currDeviceCount`. Add this product to `totalBeams`.
   ii. Update `prevDeviceCount` to `currDeviceCount`, as this row now becomes the "previous" row with devices for subsequent rows.
   c. If `currDeviceCount == 0`:
   i. This row is empty. Beams can pass through it. We do _not_ update `prevDeviceCount`. The `prevDeviceCount` from an earlier row remains the count for the next non-empty row we encounter.
3. After iterating through all rows, `totalBeams` will hold the final count.

This approach correctly handles the condition that intermediate rows must be empty, as we only add beams when we find a non-empty row (`currDeviceCount > 0`) and use the device count from the _most recent_ non-empty row encountered before it (`prevDeviceCount`).

</details>

---

## üí° Approach

1.  Initialize `result = 0` (total beams) and `prevDeviceCount = 0`.
2.  Iterate through each row `i` of the `bank` array (from `0` to `n-1`, where `n` is the number of rows).
3.  For each row `bank[i]`, calculate the current number of devices `currDeviceCount` by counting the '1's in the string.
4.  If `currDeviceCount` is greater than 0:
    - Add the product of `prevDeviceCount` and `currDeviceCount` to the `result`. This calculates the beams between the previous row with devices and the current row.
    - Update `prevDeviceCount` to `currDeviceCount`. This is because the current row is now the most recent row encountered that contains devices.
5.  If `currDeviceCount` is 0, do nothing. `prevDeviceCount` remains unchanged as beams can pass through this empty row to the next row containing devices.
6.  After iterating through all rows, return the final `result`.

---

## üíª Solution Code (C++)

```cpp
// Intuition: Laser beams connect devices between two rows (r1 < r2) only if all intermediate rows are empty ('0's).
// The number of beams between such valid adjacent rows is the product of the device counts in those rows.
// Approach: Iterate through rows, count devices ('1's) in the current row (currDeviceCount).
// Keep track of the device count from the *previous* row that had devices (prevDeviceCount).
// If currDeviceCount > 0, add (prevDeviceCount * currDeviceCount) to the total result, and then update prevDeviceCount = currDeviceCount.
// If currDeviceCount == 0, prevDeviceCount remains unchanged as beams can pass through empty rows. This is handled implicitly by the ternary operator.
// Time Complexity: O(m * n), where m is the number of rows and n is the number of columns. We visit each cell once.
// Space Complexity: O(1), constant extra space is used for variables like counts and result.
class Solution {
public:
    int numberOfBeams(std::vector<std::string>& bank) {
        int n = bank.size(); // Get the total number of rows (floors)
        int prevDeviceCount = 0; // Initialize the count of devices in the previous row with devices
        int result = 0; // Initialize the total number of laser beams

        // Iterate through each row of the bank
        for(int i = 0; i < n; i++) {
            int currDeviceCount = 0; // Initialize device count for the current row
            // Iterate through each character (cell) in the current row string
            for(char &ch : bank[i]) {
                // If the character is '1', it represents a device
                if(ch == '1') {
                    currDeviceCount++; // Increment the device count for the current row
                }
            }

            // Calculate beams: product of devices in the previous non-empty row and current row
            result += (prevDeviceCount * currDeviceCount);

            // Update prevDeviceCount for the next iteration:
            // If the current row had devices (currDeviceCount > 0), it becomes the new prevDeviceCount.
            // Otherwise (currDeviceCount == 0), keep the old prevDeviceCount.
            prevDeviceCount = currDeviceCount == 0 ? prevDeviceCount : currDeviceCount;
        }
        // Return the total calculated number of beams
        return result;
    }
};

/*
*
* Dry Run
* Example 1: bank = ["011001", "000000", "010100", "001000"]
*
* Initialization:
* n = 4
* prevDeviceCount = 0
* result = 0
*
* Iteration i = 0 (row "011001"):
* currDeviceCount = 3
* result += (0 * 3) => result = 0
* prevDeviceCount = (3 == 0 ? 0 : 3) => prevDeviceCount = 3
*
* Iteration i = 1 (row "000000"):
* currDeviceCount = 0
* result += (3 * 0) => result = 0
* prevDeviceCount = (0 == 0 ? 3 : 0) => prevDeviceCount = 3
*
* Iteration i = 2 (row "010100"):
* currDeviceCount = 2
* result += (3 * 2) => result = 6
* prevDeviceCount = (2 == 0 ? 3 : 2) => prevDeviceCount = 2
*
* Iteration i = 3 (row "001000"):
* currDeviceCount = 1
* result += (2 * 1) => result = 6 + 2 = 8
* prevDeviceCount = (1 == 0 ? 2 : 1) => prevDeviceCount = 1
*
* End of loop.
* Return result = 8.
*
*/
```

---

## üìù Notes

- The problem statement guarantees `m >= 1`, so there's always at least one row.
- If no rows or only one row contains devices, the result will correctly be 0.
- The crucial part is updating `prevDeviceCount` _only_ when the current row `currDeviceCount` is non-zero. This correctly handles the condition about empty intermediate rows.

---

## üöÄ Key Insights

- **Row-by-Row Processing:** The problem can be solved by iterating through the rows sequentially.
- **State Management:** Only the device count of the _immediately preceding non-empty row_ matters for calculating beams with the current row.
- **Multiplication Rule:** The number of beams between two valid rows is simply the product of their device counts.

---

## üß≠ Further Exploration

- Consider how the solution would change if beams could be blocked by devices in the _same_ column in intermediate rows (this is _not_ the case in the current problem).
- Analyze the constraints: What if `m` or `n` were much larger? Would the approach still be efficient? (Yes, as it's linear with respect to the total number of cells `m*n`).

---

## üìö References

- [LeetCode Problem Link](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/description/)

---

## üè∑Ô∏è Tags

`Array` `Math` `String` `Matrix`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)

---
