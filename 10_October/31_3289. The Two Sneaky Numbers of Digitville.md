# 3289. The Two Sneaky Numbers of Digitville

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge" alt="Difficulty: Easy">
  <img src="https://img.shields.io/badge/Topics-Array-blue?style=for-the-badge" alt="Topic: Array">
  <img src="https://img.shields.io/badge/Topics-Hash%20Table-blue?style=for-the-badge" alt="Topic: Hash Table">
  <img src="https://img.shields.io/badge/Topics-Bit%20Manipulation-blue?style=for-the-badge" alt="Topic: Bit Manipulation">
</p>

**Problem Link:** [https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/](https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/)

---

## üìù Problem Statement

In the town of Digitville, there was a list of numbers called `nums` containing integers from `0` to `n - 1`. Each number was supposed to appear **exactly once** in the list, however, **two** mischievous numbers sneaked in an **additional time**, making the list longer than usual.

As the town detective, your task is to find these two sneaky numbers. Return an array of size two containing the two numbers (in **any order**), so peace can return to Digitville.

---

## üîí Constraints

- `2 <= n <= 100`
- `nums.length == n + 2`
- `0 <= nums[i] < n`
- The input is generated such that `nums` contains **exactly** two repeated elements.

---

## examples: üìã Examples

<div align="center">

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [0,1,1,0]` | `[0,1]` | The numbers 0 and 1 each appear twice. |
| `nums = [0,3,2,1,3,2]` | `[2,3]` | The numbers 2 and 3 each appear twice. |
| `nums = [7,1,5,4,3,4,6,0,9,5,8,2]` | `[4,5]` | The numbers 4 and 5 each appear twice. |

</div>

---

## üß† Approach

<details>
<summary><strong>Approach 1: Using a Hash Map (Frequency Count)</strong></summary>

The most straightforward method is to simply count the frequency of each number.

1.  Initialize an `unordered_map` (hash map) to store the frequency of each number.
2.  Initialize an empty `vector` called `result` to store our sneaky numbers.
3.  Iterate through the input array `nums`.
4.  For each number `num`, increment its count in the hash map (`mp[num]++`).
5.  After incrementing, check if the count for `num` has just become `2`.
6.  If `mp[num] == 2`, it means this is the first time we've seen its duplicate. Add `num` to the `result` vector.
7.  After iterating through all numbers, `result` will contain the two sneaky numbers. Return `result`.

This approach is simple and easy to understand.
-   **Time Complexity:** $O(n)$, where $n$ is the length of `nums`, because we iterate through the array once. Hash map operations (insertion and lookup) take $O(1)$ on average.
-   **Space Complexity:** $O(n)$, as the hash map might store up to `n-1` unique elements in the worst case.

</details>

<details>
<summary><strong>Approach 2: Bit Manipulation (XOR) - O(1) Space</strong></summary>

To achieve a constant space solution, we can leverage the properties of the bitwise XOR operator.

-   `x ^ x = 0` (XORing a number with itself results in 0)
-   `x ^ 0 = x` (XORing a number with 0 results in the number itself)
-   XOR is associative and commutative.

**Core Idea:**
If we XOR all the numbers from the *expected* range `[0...n-1]` and all the numbers from the *given* `nums` array, all the numbers that appear once will be XORed twice, canceling themselves out. The two sneaky numbers (let's call them `a` and `b`) will be XORed three times (once from the expected range, twice from `nums`), leaving just `a ^ b`.

**Steps:**

1.  First, find the "original" `n`. Since `nums` has `n` numbers plus 2 duplicates, `n = nums.size() - 2`.
2.  Initialize a variable `total_xor = 0`.
3.  XOR all elements from `nums` into `total_xor`.
    ```cpp
    for(int num : nums) {
        total_xor ^= num;
    }
    ```
4.  XOR all elements from the expected range `[0...n-1]` into `total_xor`.
    ```cpp
    for(int i = 0; i < n; i++) {
        total_xor ^= i;
    }
    ```
5.  At this point, `total_xor` holds the value `a ^ b`.
6.  Since `a` and `b` are different, `a ^ b` must be non-zero. This means there is at least one bit position where `a` and `b` differ (where the bit in `total_xor` is `1`). We need to find *any* such bit to act as a separator.
7.  A common way is to find the **rightmost set bit (LSB)**. A built-in function `__builtin_ctz(total_xor)` gives the count of trailing zeros. The `mask` can then be calculated as `1 << trailZeroCount`. This `mask` will have only one bit set to `1`, at the position where `a` and `b` first differ.
8.  Now, we create two "groups", `G1 = 0` and `G2 = 0`. We will use the `mask` to separate all numbers (from both `nums` and the expected range `[0...n-1]`) into these two groups.
9.  Iterate through `nums` again:
    -   If `(num & mask)` is non-zero (meaning the separator bit is set), XOR it with `G1`.
    -   Else (the bit is not set), XOR it with `G2`.
10. Iterate through the expected range `[0...n-1]` again:
    -   If `(i & mask)` is non-zero, XOR it with `G1`.
    -   Else, XOR it with `G2`.
11. **Why does this work?**
    -   All unique numbers will be XORed into their respective groups *twice* (once from `nums`, once from the range `[0...n-1]`), canceling themselves out to 0.
    -   The sneaky number `a` will be XORed *three times* in its group (twice from `nums`, once from the range), leaving just `a`.
    -   The sneaky number `b` will be XORed *three times* in its group, leaving just `b`.
    -   Since the `mask` is based on a differing bit, `a` and `b` are guaranteed to be in different groups.
12. The final values `G1` and `G2` are the two sneaky numbers. Return `{G1, G2}`.

-   **Time Complexity:** $O(n)$, as we perform three separate passes (one to get `total_xor`, two to separate into groups).
-   **Space Complexity:** $O(1)$, as we only use a few integer variables.

</details>

---

## üíª Solution Code

### Approach 1: Brute-force Solution (C++)

```cpp
// Intuition: We need to find numbers that appear twice. A frequency counter 
// (like a hash map) is the most direct way to track the number of appearances for each integer.

// Approach:
// 1. Create an unordered_map `mp` to store the frequency of each number.
// 2. Create a vector `result` to store the two numbers that appear twice.
// 3. Iterate through the input vector `nums`.
// 4. For each `num`, increment its count in the map: `mp[num]++`.
// 5. After incrementing, check if the count for that `num` has just become 2.
// 6. If `mp[num] == 2`, this is one of the sneaky numbers. Add it to the `result` vector.
// 7. After the loop finishes, return the `result` vector.

// Time Complexity: O(n), where n = nums.size(). We iterate through the array once.
// Hash map insertion and lookup operations are O(1) on average.

// Space Complexity: O(n) in the worst case. The map could store up to (n-2) unique 
// elements if the duplicates appear at the end.

//Approach-1 (Simple using map)
//T.C : O(n)
//S.C : O(n)
class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        vector<int> result; // Stores the two sneaky (duplicate) numbers
        unordered_map<int, int> mp; // Frequency map
        
        for (int &num : nums) {
            mp[num]++; // Increment the count for the current number
            
            // If this number has now appeared twice, it's a sneaky number
            if (mp[num] == 2) {
                result.push_back(num); // Add it to our result list
            }
        }
        
        return result; // Return the list of two sneaky numbers
    }
};

/*
*
* Dry Run
*
* Input: nums = [0, 3, 2, 1, 3, 2]
*
* 1. Initialize: result = [], mp = {}
*
* 2. Loop 1 (num = 0):
* - mp[0]++ -> mp = {{0, 1}}
* - mp[0] is 1 (not 2).
*
* 3. Loop 2 (num = 3):
* - mp[3]++ -> mp = {{0, 1}, {3, 1}}
* - mp[3] is 1 (not 2).
*
* 4. Loop 3 (num = 2):
* - mp[2]++ -> mp = {{0, 1}, {3, 1}, {2, 1}}
* - mp[2] is 1 (not 2).
*
* 5. Loop 4 (num = 1):
* - mp[1]++ -> mp = {{0, 1}, {3, 1}, {2, 1}, {1, 1}}
* - mp[1] is 1 (not 2).
*
* 6. Loop 5 (num = 3):
* - mp[3]++ -> mp = {{0, 1}, {3, 2}, {2, 1}, {1, 1}}
* - mp[3] is 2.
* - result.push_back(3) -> result = [3]
*
* 7. Loop 6 (num = 2):
* - mp[2]++ -> mp = {{0, 1}, {3, 2}, {2, 2}, {1, 1}}
* - mp[2] is 2.
* - result.push_back(2) -> result = [3, 2]
*
* 8. End of loop.
*
* 9. Return result -> [3, 2]
*
*/
```

### Approach 2: Optimized Solution (C++)

```cpp
// Intuition: The XOR operator (^) can be used to find unique numbers.
// `x ^ x = 0` and `x ^ 0 = x`. If we XOR all numbers from the expected range [0..n-1]
// and all numbers from the `nums` array, all unique numbers will cancel out,
// leaving us with the XOR of the two duplicates (a ^ b). We can then use this
// result to isolate 'a' and 'b'.

// Approach:
// 1. Find the original size `n`. Since `nums` has n + 2 elements, `n = nums.size() - 2`.
// 2. Initialize `XOR = 0`. This will store `a ^ b`.
// 3. XOR all numbers in `nums` into `XOR`.
// 4. XOR all numbers from the expected range `[0...n-1]` into `XOR`.
// 5. Now, `XOR` holds `a ^ b`. Since `a != b`, `XOR` is non-zero.
// 6. Find the position of the rightmost set bit in `XOR`. This is a bit that
//    is different between `a` and `b`.
// 7. `trailZeroCount = __builtin_ctz(XOR)` finds the number of trailing zeros (index of LSB).
// 8. `mask = 1 << trailZeroCount` creates a mask with only that bit set (e.g., 00100).
// 9. Initialize two "groups" `G1 = 0` and `G2 = 0`.
// 10. Iterate through `nums` again. Use the `mask` to split numbers into two groups.
//     - If `(num & mask)` is non-zero, XOR `num` with `G1`.
//     - If `(num & mask)` is zero, XOR `num` with `G2`.
// 11. Iterate through the expected range `[0...n-1]`.
//     - If `(num & mask)` is non-zero, XOR `num` with `G1`.
//     - If `(num & mask)` is zero, XOR `num` with `G2`.
// 12. All unique numbers are XORed twice (once from `nums`, once from the range)
//     in their group, canceling to 0.
// 13. The duplicates `a` and `b` are XORed three times (twice from `nums`, once
//     from the range) in their respective groups (they are in different groups
//     due to the mask), leaving `a` in one group and `b` in the other.
// 14. Return `{G1, G2}`.

// Time Complexity: O(n), for the three passes (XOR all `nums`, XOR range `[0,n-1]`, 
// group and XOR `nums`, group and XOR range `[0,n-1]`).

// Space Complexity: O(1), only a few integer variables are used.

//Approach-2 (Using bit mask and XOR)
//T.C : O(n)
//S.C : O(1)
class Solution {
public:
    vector<int> getSneakyNumbers(vector<int>& nums) {
        // The original list was 0....n-1.
        // The new list has n+2 elements.
        int n = nums.size() - 2;

        int XOR = 0; // This will store the result a^b

        // XOR all numbers in the given array
        for(int &num : nums) {
            XOR ^= num;
        }

        // XOR all numbers from the original list [0...n-1]
        // This cancels out all numbers that appear once.
        // The remaining value in XOR is a^b (where a and b are the duplicates)
        for(int num = 0; num <= n-1; num++) { //original list
            XOR ^= num;
        }

        // Find the rightmost set bit (Least Significant Bit) in (a^b)
        // This bit is guaranteed to be different in 'a' and 'b'
        int trailZeroCount = __builtin_ctz(XOR); // Count trailing zeros
        int mask = 1 << trailZeroCount; // Create a mask with only that bit set

        int G1 = 0; // Group 1 (bit is set)
        int G2 = 0; // Group 2 (bit is not set)

        // Separate numbers from `nums` into two groups based on the mask
        for(int &num : nums) {
            if(num & mask) { // Check if the separator bit is set
                G1 ^= num;
            } else {
                G2 ^= num;
            }
        }

        // Separate numbers from the original range [0...n-1] into the same groups
        for(int num = 0; num <= n-1; num++) {
            if(num & mask) {
                G1 ^= num;
            } else {
                G2 ^= num;
            }
        }

        // G1 will hold 'a' and G2 will hold 'b' (or vice-versa)
        return {G1, G2};
    }
};

/*
*
* Dry Run
*
* Input: nums = [0, 3, 2, 1, 3, 2], n = 4. Expected Range [0, 1, 2, 3]. Duplicates a=2, b=3.
*
* 1. Calculate `XOR`:
* - XOR from nums: (0 ^ 3 ^ 2 ^ 1 ^ 3 ^ 2) = (0) ^ (1) ^ (2^2) ^ (3^3) = 0 ^ 1 ^ 0 ^ 0 = 1
* - XOR from range [0,3]: (0 ^ 1 ^ 2 ^ 3) = (00 ^ 01 ^ 10 ^ 11) = (00) = 0
* - total_xor = 1 ^ 0 = 1.
* - Wait, my manual XOR is wrong. Let's trace code.
*
* Tracing Code XOR:
* 1. `XOR = 0`
* 2. `XOR` with `nums`:
* - `0^0=0` -> `0^3=3` -> `3^2=1` -> `1^1=0` -> `0^3=3` -> `3^2=1`.
* - `XOR` = 1.
* 3. `XOR` with range `[0, 3]`:
* - `1^0=1` -> `1^1=0` -> `0^2=2` -> `2^3=1`.
* - Final `XOR` = 1. (This is `a^b` -> `2^3` = `010 ^ 011` = `001` = 1. Correct.)
*
* 4. Find `mask`:
* - `trailZeroCount = __builtin_ctz(1)` = 0.
* - `mask = 1 << 0` = 1. (Mask will check the 0-th bit)
*
* 5. Initialize `G1 = 0`, `G2 = 0`.
*
* 6. Group `nums = [0, 3, 2, 1, 3, 2]`:
* - `num = 0` (000): `0 & 1 = 0`. `G2 ^= 0` -> `G2 = 0`.
* - `num = 3` (011): `3 & 1 = 1`. `G1 ^= 3` -> `G1 = 3`.
* - `num = 2` (010): `2 & 1 = 0`. `G2 ^= 2` -> `G2 = 2`.
* - `num = 1` (001): `1 & 1 = 1`. `G1 ^= 1` -> `G1 = 3 ^ 1 = 2`.
* - `num = 3` (011): `3 & 1 = 1`. `G1 ^= 3` -> `G1 = 2 ^ 3 = 1`.
* - `num = 2` (010): `2 & 1 = 0`. `G2 ^= 2` -> `G2 = 2 ^ 2 = 0`.
* - After this loop: `G1 = 1`, `G2 = 0`.
*
* 7. Group range `[0, 1, 2, 3]`:
* - `num = 0` (000): `0 & 1 = 0`. `G2 ^= 0` -> `G2 = 0`.
* - `num = 1` (001): `1 & 1 = 1`. `G1 ^= 1` -> `G1 = 1 ^ 1 = 0`.
* - `num = 2` (010): `2 & 1 = 0`. `G2 ^= 2` -> `G2 = 0 ^ 2 = 2`.
* - `num = 3` (011): `3 & 1 = 1`. `G1 ^= 3` -> `G1 = 0 ^ 3 = 3`.
* - After this loop: `G1 = 3`, `G2 = 2`.
*
* 8. Return `{G1, G2}` -> `{3, 2}`.
*
*/
```

---

## üí° Key Insights

-   **Frequency Counting:** The hash map approach is a classic "frequency counting" pattern. It's often the first and most intuitive solution when dealing with duplicates, missing numbers, or frequency-based problems.
-   **XOR Properties:** The XOR-based solution is a powerful bit manipulation technique used to find unique or duplicate elements in $O(1)$ space. The key is to understand that XORing all expected and all actual elements cancels everything *except* the elements with an "odd" number of appearances.
-   **Isolating with a Mask:** The trick of finding `a ^ b` and then using its rightmost set bit (`LSB`) as a `mask` is a fundamental pattern. This mask effectively separates a diverse set of numbers into two distinct groups, guaranteeing that `a` and `b` fall into different groups, which allows us to isolate them.

---

## üöÄ Further Exploration

-   **What if only *one* number was repeated?** (Hint: Simpler XOR problem).
-   **What if one number was repeated and one was *missing*?** (Similar XOR logic, but the `a ^ b` result would be `duplicate ^ missing`).
-   **What if *three* numbers were repeated?** (This is much harder and cannot be solved with this simple XOR trick).
-   **Math Approach:** The problem can also be solved using a mathematical approach.
    1.  Find the sum of the expected range `[0...n-1]`: `sum_expected = n * (n - 1) / 2`.
    2.  Find the sum of the given `nums` array: `sum_actual`.
    3.  The difference `sum_actual - sum_expected` will be `a + b` (the sum of the two duplicates).
    4.  This gives you one equation: `a + b = S`. You would need a second equation, perhaps by using the sum of squares, to solve for `a` and `b`. This can be a good alternative if bit manipulation is not preferred.

---

## üìö References

-   [GeeksforGeeks: Find two repeating elements in a given array](https://www.geeksforgeeks.org/find-two-repeating-elements-in-a-given-array/)
-   [YouTube: Find the two repeating numbers (XOR approach)](https://www.youtube.com/watch?v=5nMGY4VUoRY)

---

## üè∑Ô∏è Tags

`Array` `Hash Table` `Bit Manipulation` `XOR`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/the-two-sneaky-numbers-of-digitville/) for original content and copyright.**

---

## üë®‚Äçüíª Author

-   [imnilesh18](https://github.com/imnilesh18)