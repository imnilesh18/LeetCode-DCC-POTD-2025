# 2257. Count Unguarded Cells in the Grid

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Medium-yellow" alt="Difficulty: Medium">
  <img src="https://img.shields.io/badge/Tags-Array-blue" alt="Tag: Array">
  <img src="https://img.shields.io/badge/Tags-Matrix-blue" alt="Tag: Matrix">
  <img src="https://img.shields.io/badge/Tags-Simulation-blue" alt="Tag: Simulation">
</p>

[Problem Link](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/description/)

---

<p align="center">
  <img src="https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png" alt="Problem Example" width="600px">
</p>

## üìù Problem Statement

You are given two integers `m` and `n` representing a **0-indexed** `m x n` grid. You are also given two 2D integer arrays `guards` and `walls` where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `i`th guard and `j`th wall respectively.

A guard can see **every** cell in the four cardinal directions (north, east, south, or west) starting from their position unless **obstructed** by a wall or another guard. A cell is **guarded** if there is **at least** one guard that can see it.

Return _the number of unoccupied cells that are **not** guarded_.

---

## üîí Constraints

- `1 <= m, n <= 10^5`
- `2 <= m * n <= 10^5`
- `1 <= guards.length, walls.length <= 5 * 10^4`
- `2 <= guards.length + walls.length <= m * n`
- `guards[i].length == walls[j].length == 2`
- `0 <= rowi, rowj < m`
- `0 <= coli, colj < n`
- All the positions in `guards` and `walls` are **unique**.

---

## Examples

### Example 1:

| Input                                                                                 | Output |
| :------------------------------------------------------------------------------------ | :----- |
| `m = 4, n = 6` <br> `guards = [[0,0],[1,1],[2,3]]` <br> `walls = [[0,1],[2,2],[1,4]]` | `7`    |

**Explanation:** The guarded and unguarded cells are shown in red and green respectively in the diagram. There are a total of 7 unguarded cells.

### Example 2:

| Input                                                                           | Output |
| :------------------------------------------------------------------------------ | :----- |
| `m = 3, n = 3` <br> `guards = [[1,1]]` <br> `walls = [[0,1],[1,0],[2,1],[1,2]]` | `4`    |

**Explanation:** The unguarded cells are shown in green in the diagram. There are a total of 4 unguarded cells.

---

## üß† Approach (Simulation)

The problem asks us to count cells that are not visible to any guard. A guard's vision is blocked by other guards, walls, or the grid boundaries. This problem can be solved by directly simulating this process.

1.  **Grid Initialization**: Create an `m x n` grid. We can use integer values to represent the state of each cell:

    - `0`: Empty, unguarded cell.
    - `1`: Guarded cell.
    - `2`: A guard is at this cell.
    - `3`: A wall is at this cell.
      (Any distinct non-zero values will work).

2.  **Mark Obstacles**: Iterate through the `guards` and `walls` arrays. Mark their positions in our grid with the corresponding values (e.g., `2` for guards, `3` for walls).

3.  **Simulate Guard Vision**: Iterate through the `guards` array again. For each guard's position `(r, c)`:

    - Simulate vision in all four directions (up, down, left, right).
    - **Up**: Starting from `(r-1, c)`, move upwards. For each cell `(i, c)`:
      - If it's a wall (`3`) or another guard (`2`), stop this direction.
      - If it's empty (`0`) or already guarded (`1`), mark it as guarded (`1`).
    - **Down**: Starting from `(r+1, c)`, move downwards. Repeat the logic.
    - **Left**: Starting from `(r, c-1)`, move left. Repeat the logic.
    - **Right**: Starting from `(r, c+1)`, move right. Repeat the logic.

4.  **Count Unguarded Cells**: After simulating all guards, iterate through the entire `m x n` grid. Count every cell that still has the value `0`. These are the cells that are unoccupied (not a guard or wall) and were never marked as "guarded".

5.  **Return Count**: Return the final count.

---

## üíª Solution Code

### Brute-Force Solution

A true brute-force approach might be to iterate through every single empty cell `(i, j)` and, for each one, check in all four directions to see if a guard is visible before a wall. This would be very inefficient, leading to a Time Limit Exceeded verdict. The simulation approach described above is the standard and efficient way to solve this problem.

### Optimized Solution (Simulation)

```cpp
// Intuition: We can simulate the entire process described. We need a way to represent the grid and the state of each cell (empty, wall, guard, or guarded).
// Approach:
// 1. Create an (m x n) integer grid, initialized to 0 (representing empty, unguarded cells).
// 2. Mark the positions of all guards on this grid with a distinct value (e.g., 2).
// 3. Mark the positions of all walls on this grid with another distinct value (e.g., 3).
// 4. Iterate through the list of guards again.
// 5. For each guard, call a helper function `markGuarded`.
// 6. The `markGuarded` function simulates the guard's vision in all four cardinal directions (up, down, left, right) from the guard's position.
// 7. In each direction, iterate cell by cell. If a cell is empty (0), mark it as guarded (1). (We can also mark '1' as '1', it doesn't change anything).
// 8. If the vision hits a wall (3), another guard (2), or the grid boundary, stop the simulation for that direction.
// 9. After iterating through all guards, the grid is fully marked.
// 10. Iterate through the entire grid (m x n) one last time.
// 11. Count all cells that still have a value of 0 (these are the unoccupied, unguarded cells).
// 12. Return the final count.
// Time Complexity: O(m*n + G*(m+n)), where G is the number of guards. O(m*n) to initialize the grid and for the final count. For each of the G guards, we travel in 4 directions, visiting at most m or n cells.
// Space Complexity: O(m*n) to store the state of the grid.

class Solution {
public:
    // Helper function to mark cells visible by a single guard
    void markGuarded(int row, int col, vector<vector<int>>& grid) {

        // --- Mark UP ---
        // Start from the cell just above the guard and go upwards
        for(int i = row - 1; i >= 0; i--) {
            // Stop if we hit a wall (3) or another guard (2)
            if(grid[i][col] == 2 || grid[i][col] == 3) {
                break;
            }
            grid[i][col] = 1; // Mark the cell as guarded
        }

        // --- Mark DOWN ---
        // Start from the cell just below the guard and go downwards
        for(int i = row + 1; i < grid.size(); i++) {
            // Stop if we hit a wall (3) or another guard (2)
            if(grid[i][col] == 2 || grid[i][col] == 3) {
                break;
            }
            grid[i][col] = 1; // Mark the cell as guarded
        }

        // --- Mark LEFT ---
        // Start from the cell to the left and go leftwards
        for(int j = col - 1; j >= 0; j--) {
            // Stop if we hit a wall (3) or another guard (2)
            if(grid[row][j] == 2 || grid[row][j] == 3) {
                break;
            }
            grid[row][j] = 1; // Mark the cell as guarded
        }

        // --- Mark RIGHT ---
        // Start from the cell to the right and go rightwards
        for(int j = col + 1; j < grid[0].size(); j++) {
            // Stop if we hit a wall (3) or another guard (2)
            if(grid[row][j] == 2 || grid[row][j] == 3) {
                break;
            }
            grid[row][j] = 1; // Mark the cell as guarded
        }
    }

    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        // 0 -> Unguarded, 1 -> Guarded, 2 -> Guard, 3 -> Wall
        vector<vector<int>> grid(m, vector<int>(n, 0)); // Initialize grid with 0s

        // mark guards positions
        for(vector<int>& vec : guards) {
            int i = vec[0];
            int j = vec[1];
            grid[i][j] = 2; // 2 represents a guard
        }

        // mark walls positions
        for(vector<int>& vec : walls) {
            int i = vec[0];
            int j = vec[1];
            grid[i][j] = 3; // 3 represents a wall
        }

        // Iterate through each guard and mark the cells they can see
        for(vector<int>& guard : guards) {
            int i = guard[0];
            int j = guard[1];
            markGuarded(i, j, grid); // four direction check and mark guarded
        }

        int count = 0; // Initialize count of unguarded cells
        // Iterate through the grid to count unguarded cells
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == 0) { // If cell is 0, it's unguarded
                    count++;
                }
            }
        }
        return count; // Return the final count
    }
};

/*
*
* Dry Run
*
* Input: m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]
*
* 1. Initial 4x6 Grid (all 0s)
*
* 2. Mark Guards (G=2) and Walls (W=3):
* G W 0 0 0 0
* 0 G 0 0 W 0
* 0 0 W G 0 0
* 0 0 0 0 0 0
*
* 3. Process Guard at (0,0):
* - Up/Left: (Out of Bounds)
* - Down: Mark (1,0), (2,0), (3,0) as 1.
* - Right: Hit Wall at (0,1). Stop.
* Grid:
* G W 0 0 0 0
* 1 G 0 0 W 0
* 1 0 W G 0 0
* 1 0 0 0 0 0
*
* 4. Process Guard at (1,1):
* - Up: Hit Wall at (0,1). Stop.
* - Down: Mark (2,1), (3,1) as 1.
* - Left: Mark (1,0) as 1 (it's already 1).
* - Right: Mark (1,2), (1,3) as 1. Hit Wall at (1,4). Stop.
* Grid:
* G W 0 0 0 0
* 1 G 1 1 W 0
* 1 1 W G 0 0
* 1 1 0 0 0 0
*
* 5. Process Guard at (2,3):
* - Up: Mark (1,3) as 1 (already 1). Mark (0,3) as 1.
* - Down: Mark (3,3) as 1.
* - Left: Hit Wall at (2,2). Stop.
* - Right: Mark (2,4), (2,5) as 1.
* Final Grid:
* G W 0 1 0 0
* 1 G 1 1 W 0
* 1 1 W G 1 1
* 1 1 0 1 0 0
*
* 6. Final Count (count all 0s):
* - Row 0: 3 cells (at 0,2; 0,4; 0,5)
* - Row 1: 1 cell (at 1,5)
* - Row 2: 0 cells
* - Row 3: 3 cells (at 3,2; 3,4; 3,5)
* - Total = 3 + 1 + 0 + 3 = 7.
*
* 7. Return 7. (Matches example)
*
*/
```

---

## üí° Key Insights

- **State Management**: Using a grid to store the state of each cell is crucial. The key is to use distinct values to differentiate between empty cells, guarded cells, and obstacles (walls/other guards).
- **Simulation Order**: It doesn't matter in which order you process the guards. The final state of "guarded" cells will be the same.
- **Obstructions**: The rule is simple: a guard's line of sight stops as soon as it hits _any_ obstacle, whether it's a wall or another guard. Our simulation must strictly follow this.
- **Space-Time Trade-off**: We use O(m\*n) extra space for the grid, which allows us to solve the problem efficiently in O(m\*n + G\*(m+n)) time.

---

## üöÄ Further Exploration

- **Recursive (DFS) Approach**: As suggested in the provided explanation, could you implement this using a recursive Depth First Search (DFS) function?
  - You would start a DFS from each guard in all four directions.
  - The DFS function would take the current `(r, c)` and the `direction` it's moving in.
  - It would only continue to call itself recursively in that _same_ direction.
  - The base cases would be hitting an obstacle (wall, guard) or the grid boundary.
  - This avoids using iterative `for` loops for each direction inside the main guard loop.

---

## üìö References

- [LeetCode Problem Discussion](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/discuss/)
- [Matrix Simulation Techniques](https://www.geeksforgeeks.org/simulation-algorithms/)

---

## üè∑Ô∏è Tags

`Array` `Matrix` `Simulation` `Grid`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/description/) for original content and copyright.**

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
