# 1578. Minimum Time to Make Rope Colorful

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Medium-yellow.svg" alt="Difficulty: Medium" />
  <img src="https://img.shields.io/badge/Topics-Array-blue.svg" alt="Topic: Array" />
  <img src="https://img.shields.io/badge/Topics-String-blue.svg" alt="Topic: String" />
  <img src="https://img.shields.io/badge/Topics-Greedy-blue.svg" alt="Topic: Greedy" />
  <img src="https://img.shields.io/badge/Topics-Dynamic%20Programming-blue.svg" alt="Topic: Dynamic Programming" />
</p>

Solution for the LeetCode problem: **Minimum Time to Make Rope Colorful**.

---

## Problem Details

-   **Problem Link**: [1578. Minimum Time to Make Rope Colorful](https://leetcode.com/problems/minimum-time-to-make-rope-colorful/)
-   **Difficulty**: `Medium`
-   **Tags**: `Array`, `String`, `Greedy`, `Dynamic Programming`

---

## üìù Problem Statement

Alice has **n** balloons arranged on a rope. You are given a **0-indexed** string `colors` where `colors[i]` is the color of the `ith` balloon.

Alice wants the rope to be **colorful**. She does not want **two consecutive balloons** to be of the same color, so she asks Bob for help. Bob can remove some balloons from the rope to make it **colorful**. You are given a **0-indexed** integer array `neededTime` where `neededTime[i]` is the time (in seconds) that Bob needs to remove the `ith` balloon from the rope.

Return *the **minimum time** Bob needs to make the rope **colorful***.

---

## Constraints

-   `n == colors.length == neededTime.length`
-   `1 <= n <= 10^5`
-   `1 <= neededTime[i] <= 10^4`
-   `colors` contains only lowercase English letters.

---

##  Examples

Here are a few examples to illustrate the problem:

<br />

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `colors = "abaac"`, `neededTime = [1,2,3,4,5]` | `3` | Bob can remove the blue balloon at index 2. This takes 3 seconds. There are no longer two consecutive balloons of the same color. Total time = 3. |
| `colors = "abc"`, `neededTime = [1,2,3]` | `0` | The rope is already colorful. Bob does not need to remove any balloons from the rope. |
| `colors = "aabaa"`, `neededTime = [1,2,3,4,1]` | `2` | Bob will remove the balloons at indices 0 and 4. Each balloon takes 1 second to remove. Total time = 1 + 1 = 2. |

---

## üí° Approach

The problem asks for the *minimum time* to ensure no two adjacent balloons are the same color. This implies that for any group of consecutive, identical balloons, we must remove all of them except for one.

To minimize the total time, our greedy strategy should be:
**In any group of consecutive, same-colored balloons, keep the one that is most expensive to remove and remove all the others.**

We can implement this by iterating through the balloons once, keeping track of the maximum cost (`prevMaxTime`) seen within the *current* continuous group of same-colored balloons.

### Algorithm Steps:

1.  Initialize `totalTime = 0` (our final answer) and `prevMaxTime = 0`. `prevMaxTime` will store the cost of the balloon we intend to *keep* from the current group.
2.  Iterate through the balloons from `i = 0` to `n-1`.
3.  **Check for a new color group**: If we are at a new balloon (`i > 0`) and its color (`colors[i]`) is different from the previous one (`colors[i-1]`), it signifies the start of a new color group. We must reset `prevMaxTime = 0`, as this new group will have its own "most expensive" balloon.
4.  Get the `currentTime = neededTime[i]`.
5.  **Make the Greedy Choice**: We need to decide which balloon to "remove" (add its cost to `totalTime`) and which to "keep" (carry its cost forward in `prevMaxTime`).
    * We add `min(prevMaxTime, currentTime)` to `totalTime`.
    * **Case 1**: `currentTime < prevMaxTime`. (e.g., `prevMaxTime = 5`, `currentTime = 3`). We add `3` to `totalTime`. This is like removing the current, cheaper balloon and keeping the previous, more expensive one.
    * **Case 2**: `currentTime >= prevMaxTime`. (e.g., `prevMaxTime = 5`, `currentTime = 7`). We add `5` to `totalTime`. This is like removing the *previously* kept balloon (cost 5) and now keeping the current, more expensive one (cost 7).
    * **Case 3 (Start of new group)**: `prevMaxTime` was reset to `0`. We add `min(0, currentTime) = 0` to `totalTime`. This correctly adds no cost for the first balloon in a group.
6.  **Update `prevMaxTime`**: We update `prevMaxTime` to be the cost of the balloon we are "keeping" for the next comparison.
    * `prevMaxTime = max(prevMaxTime, currentTime)`.
7.  After the loop, `totalTime` will hold the minimum cost to make the rope colorful.

This single-pass, O(1) space approach efficiently calculates the minimum removal time by ensuring only the most expensive balloon in any consecutive group is spared.

---

## üíª Solution Code

Here is the optimized C++ solution based on the greedy approach.

<details>
<summary>Click to view C++ Solution</summary>

````cpp
// Intuition: To minimize removal time, for any group of consecutive identical balloons,
// we must remove all balloons except the one that is most expensive to remove.
//
// Approach: Iterate through the array, keeping track of the maximum cost (`prevMax`)
// within the current continuous color group.
// 1. If the current balloon (`i`) is a different color than the previous one (`i-1`),
//    we are starting a new group, so reset `prevMax` to 0.
// 2. We want to keep the most expensive balloon. So, we add the cost of the *less*
//    expensive balloon to our total `time`. This is `min(prevMax, curr)`.
// 3. We update `prevMax` to be the new "balloon to keep", which is the
//    `max(prevMax, curr)`. This ensures we always carry forward the cost of the
//    most expensive balloon seen so far in this group.
//
// Time Complexity: O(n), where 'n' is the number of balloons. We do a single pass.
// Space Complexity: O(1), as we only use a few constant extra variables.

class Solution {
public:
    int minCost(string colors, vector<int>& neededTime) {
        int n = colors.size();
        
        int time    = 0;  // Total time accumulated for removals
        int prevMax = 0;  // The cost of the balloon to *keep* in the current group
        
        for(int i = 0; i < n; i++) {
            
            // If new color, reset the "balloon to keep" cost
            if(i > 0 && colors[i] != colors[i-1]) {
                prevMax = 0;
            }
            
            // Get the cost of the current balloon
            int curr = neededTime[i];
            
            // Greedily add the cost of the *cheaper* balloon to the total time
            // We "keep" the more expensive one (its cost is stored in prevMax)
            time += min(prevMax, curr); 
            
            // Update prevMax to be the most expensive balloon seen so far in this group
            prevMax = max(prevMax, curr);
            
        }
        
        // Return the total time for all removals
        return time;
    }
};

/*
*
* Dry Run
*
* Input: colors = "aabaa", neededTime = [1, 2, 3, 4, 1]
*
* n = 5
* time = 0
* prevMax = 0
*
* i = 0 ('a'):
* (i > 0) is false.
* curr = 1
* time += min(0, 1)  -> time = 0
* prevMax = max(0, 1) -> prevMax = 1
*
* i = 1 ('a'):
* (colors[1] != colors[0]) is false.
* curr = 2
* time += min(1, 2)  -> time = 1
* prevMax = max(1, 2) -> prevMax = 2
* (Group of 'a's: kept balloon with cost 2, removed balloon with cost 1)
*
* i = 2 ('b'):
* (colors[2] != colors[1]) is true.
* prevMax = 0
* curr = 3
* time += min(0, 3)  -> time = 1
* prevMax = max(0, 3) -> prevMax = 3
*
* i = 3 ('a'):
* (colors[3] != colors[2]) is true.
* prevMax = 0
* curr = 4
* time += min(0, 4)  -> time = 1
* prevMax = max(0, 4) -> prevMax = 4
*
* i = 4 ('a'):
* (colors[4] != colors[3]) is false.
* curr = 1
* time += min(4, 1)  -> time = 1 + 1 = 2
* prevMax = max(4, 1) -> prevMax = 4
* (Group of 'a's: kept balloon with cost 4, removed balloon with cost 1)
*
* End of loop.
* Return time = 2
*
*/
`````

</details>

-----

## üîë Key Insights

  - **Greedy Choice**: The problem has an optimal substructure and a greedy choice property. The local optimal choice (keeping the most expensive balloon in a small, consecutive group) leads to the global optimal solution (minimum total removal time).
  - **Group-by-Group Processing**: The problem can be broken down into independent subproblems. Each continuous group of same-colored balloons can be processed independently. The `prevMax = 0` reset is what "closes" one subproblem and starts the next.

-----

## üöÄ Further Exploration

  - **Stack-based Approach**: This problem can also be solved using a stack. You can iterate through the balloons and push their *indices* onto a stack. If the current balloon `i` is the same color as the balloon at `stack.top()`:
      - Compare `neededTime[i]` and `neededTime[stack.top()]`.
      - Add the *smaller* time to your `totalTime`.
      - If the current balloon's time is *larger*, pop the stack and push the current index `i` (as it's the new "one to keep").
      - If the current balloon's time is *smaller*, do nothing (you "removed" the current one, and the one on the stack is still the most expensive).
      - If the current balloon is a new color, just push its index.
  - This approach also achieves O(n) time but uses O(n) space in the worst case (e.g., "aaaaa"). The greedy O(1) space approach is generally preferred.

-----

## üîó References

  - **LeetCode Problem**: [https://leetcode.com/problems/minimum-time-to-make-rope-colorful/](https://leetcode.com/problems/minimum-time-to-make-rope-colorful/)
  - **Greedy Algorithms**: [Wikipedia](https://en.wikipedia.org/wiki/Greedy_algorithm)

-----

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-time-to-make-rope-colorful/) for original content and copyright.**

-----

## üë®‚Äçüíª Author

  - [imnilesh18](https://github.com/imnilesh18)
