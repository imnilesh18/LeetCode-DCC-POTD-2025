# 3318. Find X-Sum of All K-Long Subarrays I

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Easy-green.svg" alt="Difficulty: Easy">
  <img src="https://img.shields.io/badge/Tags-Array-blue.svg" alt="Tag: Array">
  <img src="https://img.shields.io/badge/Tags-Hash%20Table-lightgrey.svg" alt="Tag: Hash Table">
  <img src="https://img.shields.io/badge/Tags-Sliding%20Window-yellow.svg" alt="Tag: Sliding Window">
  <img src="https://img.shields.io/badge/Tags-Heap%20(Priority%20Queue)-orange.svg" alt="Tag: Heap (Priority Queue)">
</p>

---

## üîó Problem Link

[https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/description/](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/description/)

---

## üìù Problem Statement

You are given an array `nums` of `n` integers and two integers `k` and `x`.

The **x-sum** of an array is calculated by the following procedure:
1.  Count the occurrences of all elements in the array.
2.  Keep only the occurrences of the top `x` most frequent elements. If two elements have the same number of occurrences, the element with the **bigger** value is considered more frequent.
3.  Calculate the sum of the resulting array.

Note that if an array has less than `x` distinct elements, its **x-sum** is the sum of the array.

Return an integer array `answer` of length `n - k + 1` where `answer[i]` is the **x-sum** of the subarray `nums[i..i + k - 1]`.

---

## üìã Constraints

-   `1 <= n == nums.length <= 50`
-   `1 <= nums[i] <= 50`
-   `1 <= x <= k <= nums.length`

---

## üìå Examples

Here are the examples provided in the problem statement, formatted as stylish tables.

### Example 1

| Input | `nums = [1,1,2,2,3,4,2,3], k = 6, x = 2` |
| :--- | :--- |
| **Output** | `[6, 10, 12]` |
| **Explanation** | |
| `[1, 1, 2, 2, 3, 4]` | Freq: `{1:2, 2:2, 3:1, 4:1}`. Top 2 are `1` and `2`. Sum = `1+1+2+2 = 6`. |
| `[1, 2, 2, 3, 4, 2]` | Freq: `{1:1, 2:3, 3:1, 4:1}`. Top 2 are `2` (freq 3) and `4` (freq 1, larger value than 1, 3). Sum = `2+2+2+4 = 10`. |
| `[2, 2, 3, 4, 2, 3]` | Freq: `{2:3, 3:2, 4:1}`. Top 2 are `2` and `3`. Sum = `2+2+2+3+3 = 12`. |

### Example 2

| Input | `nums = [3,8,7,8,7,5], k = 2, x = 2` |
| :--- | :--- |
| **Output** | `[11, 15, 15, 15, 12]` |
| **Explanation** | Since `k == x`, the "top x most frequent" will always include all elements in the k-sized subarray. The x-sum is just the sum of the subarray. |
| `[3, 8]` | Sum = 11. |
| `[8, 7]` | Sum = 15. |
| `[7, 8]` | Sum = 15. |
| `[8, 7]` | Sum = 15. |
| `[7, 5]` | Sum = 12. |

---

## üß† Approach

This problem asks us to perform a simulation on every `k`-sized subarray. A naive approach might be to re-calculate everything for each of the `n - k + 1` windows, but we can do better by combining a sliding window with a min-heap.

1.  **Sliding Window for Frequencies:**
    * We iterate through the `nums` array using a standard sliding window approach (with pointers `i` and `j`).
    * We maintain one `unordered_map` (hash map) named `mp` that stores the frequency of elements **only within the current window** `[i, j]`.
    * As the window expands (increment `j`), we add `nums[j]` to the map: `mp[nums[j]]++`.
    * When the window size `(j - i + 1)` reaches `k`, we know we have a complete `k`-sized subarray.
    * At this point, we calculate the `x-sum` for the current window's frequencies (stored in `mp`).
    * After calculating the sum, we shrink the window from the left by incrementing `i`. We update the map by removing the outgoing element: `mp[nums[i]]--`.
    * If an element's frequency drops to 0, we `erase` it from the map to keep our map size proportional to the *distinct* elements in the window.

2.  **Calculating X-Sum with a Min-Heap:**
    * For each valid window, we need to find the sum of the top `x` most frequent elements.
    * A full sort (`O(k log k)`) would be inefficient to do at every step.
    * Instead, we use a **min-heap (priority queue)** of size `x`. We create a helper function `findTopXSum`.
    * This heap will store pairs: `{frequency, value}`.
    * We iterate through our frequency map `mp` (which has at most `k` distinct elements).
    * For each `{value, frequency}` pair in the map, we `push` `{frequency, value}` onto the min-heap.
    * Crucially, if `pq.size() > x`, we `pop()` the top element.
    * Since it's a min-heap, this evicts the element with the **lowest frequency**.
    * **Tie-breaking:** The problem states that for equal frequencies, the **bigger value** is more frequent. Our min-heap of pairs handles this perfectly:
        * If it compares `{2, 1}` and `{2, 4}`, it sees `{2, 1}` as "smaller".
        * If the heap is full and needs to evict one, it will evict `{2, 1}`, correctly *keeping* `{2, 4}` (the one with the bigger value).
    * After this loop (which runs `O(k log x)` times), the min-heap contains exactly the top `x` elements we care about.
    * We then drain the heap, summing the results: `sum += freq * val`.
    * This sum is the `x-sum` for the window, which we add to our `result` vector.

The overall time complexity will be O(n) for the sliding window, and for each of the `n` steps, we perform the `findTopXSum` operation, which takes `O(k log x)`. Total time: **O(n * k * log(x))**.
The space complexity is dominated by the hash map, which stores at most `k` distinct elements. Total space: **O(k)**.

---

## üí° Solution Code

Here is the C++ solution that implements the sliding window and min-heap approach.

````cpp
// Intuition: The problem requires calculating a special "x-sum" (sum of top x frequent elements) for every k-sized subarray.
// We can iterate through all k-sized subarrays using a sliding window to efficiently maintain element frequencies in a hash map.
// For each window, we need a way to find the top x frequent elements. A min-heap of size x is perfect for this.

// Approach:
// 1. Initialize a hash map `mp` to store frequencies and a result vector `result`.
// 2. Use a sliding window with pointers `i` (start) and `j` (end).
// 3. Expand the window by incrementing `j` and adding `nums[j]` to the map (`mp[nums[j]]++`).
// 4. When the window size `(j - i + 1)` hits `k`:
//    a. Call a helper function `findTopXSum(mp, x)` to calculate the x-sum for the current window.
//    b. Add the returned sum to `result`.
//    c. Shrink the window: decrement the count of `nums[i]` (`mp[nums[i]]--`).
//    d. If `mp[nums[i]]` becomes 0, erase `nums[i]` from the map.
//    e. Increment `i`.
// 5. In `findTopXSum(mp, x)`:
//    a. Create a min-heap `pq` to store pairs of {frequency, value}.
//    b. Iterate through the map `mp`. For each element, push {freq, val} to the heap.
//    c. If `pq.size() > x`, pop from the heap. This removes the element with the smallest frequency (or smallest value if frequencies are tied), keeping the top x.
//    d. After iterating through the map, drain the heap and calculate `sum += freq * val`.
//    e. Return the total `sum`.
// 6. Return the `result` vector from the main function.

// Time Complexity: O(n * k * log(x))
// The outer `while(j < n)` loop runs O(n) times.
// Inside the loop, the `if(j - i + 1 == k)` block runs O(n) times (once for each window).
// Inside this block, `findTopXSum` is called.
// `findTopXSum` iterates through the map (at most 'k' elements) -> O(k).
// Inside its loop, heap operations (push/pop) take O(log x) time (since heap size is capped at x).
// The final sum loop runs O(x) times, with pops taking O(log x).
// Total for `findTopXSum` = O(k * log(x) + x * log(x)) = O(k * log(x)) (as x <= k).
// Overall Time Complexity = O(n * k * log(x)).

// Space Complexity: O(k)
// The `unordered_map` `mp` stores at most k distinct elements from the window, so O(k).
// The priority queue `pq` in the helper function stores at most x elements, so O(x).
// Since x <= k, the total space is O(k + x) = O(k).

//Approach (Using max-heap + sliding window)
//T.C : O(n * k * log(k))
//S.C : O(k)
class Solution {
public:
    // Define a pair 'P' to store {frequency, element}
    typedef pair<int, int> P; //freq, element
    
    /**
     * Helper function to find the x-sum from a given frequency map.
     * @param mp The frequency map of the current window.
     * @param x The number of top frequent elements to consider.
     * @return The calculated x-sum.
     */
    int findTopXSum(unordered_map<int, int>& mp, int x) {
        // Create a min-heap.
        // It stores pairs {freq, val}.
        // 'greater<P>' makes it a min-heap, so the element with the *smallest* frequency is at the top.
        priority_queue<P, vector<P>, greater<P>> pq; //O(x) space, not O(k)

        // Iterate through all elements in the current window's frequency map
        for(auto &it : mp) { // This loop runs O(k) times
            // Push {frequency, element_value} onto the min-heap
            pq.push({it.second, it.first}); // O(log x) operation

            // If the heap size exceeds x, remove the smallest element
            if(pq.size() > x) {
                pq.pop(); // O(log x) operation. This evicts the element with the *lowest* frequency.
                          // If frequencies are tied, it evicts the one with the *smallest* value,
                          // which correctly keeps the element with the *bigger* value as per problem rules.
            }
        }

        int sum = 0;
        // Now, the heap contains the top x most frequent elements.
        // Drain the heap to calculate the final sum.
        while(!pq.empty()) { // This loop runs O(x) times
            // Get the top element (which is {freq, val})
            auto [freq, val] = pq.top(); 
            pq.pop(); // O(log x) operation

            // Add (frequency * value) to the total sum
            sum += freq*val;
        }

        return sum; // Return the final x-sum for this window
    }

    /**
     * Main function to find x-sums for all k-long subarrays.
     * @param nums The input array.
     * @param k The size of the subarray window.
     * @param x The number of top frequent elements to sum.
     * @return A vector of x-sums for each window.
     */
    vector<int> findXSum(vector<int>& nums, int k, int x) {
        int n = nums.size(); // Get the total size of the input array

        unordered_map<int, int> mp; // Frequency map for the sliding window, O(k) space
        vector<int> result; // Vector to store the answer for each window

        int i = 0; // Left pointer of the sliding window
        int j = 0; // Right pointer of the sliding window
        
        //T.C : O(n * klogx)
        while(j < n) { // Standard sliding window template
            // Add the new element (at j) to the window's frequency map
            mp[nums[j]]++;

            // Check if the window has reached the desired size 'k'
            if(j - i + 1 == k) {
                // If window is size k, calculate its x-sum and add to result
                result.push_back(findTopXSum(mp, x));

                // Now, shrink the window from the left
                // Decrement the count of the element at 'i'
                mp[nums[i]]--;
                // If the count becomes 0, erase it from the map to save space
                if(mp[nums[i]] == 0) {
                    mp.erase(nums[i]);
                }
                // Move the left pointer forward
                i++;
            }

            // Move the right pointer forward to expand the window
            j++;
        }

        return result; // Return the final list of x-sums
    }
};

/*
*
* Dry Run
*
* Input: nums = [1,1,2,2,3], k = 3, x = 2
* * n = 5
* mp = {}
* result = []
* i = 0, j = 0
* * j=0: j<5. mp[nums[0]]++ -> mp[1]=1. (j-i+1) = 1. 1!=3. j=1.
* j=1: j<5. mp[nums[1]]++ -> mp[1]=2. (j-i+1) = 2. 2!=3. j=2.
* j=2: j<5. mp[nums[2]]++ -> mp[2]=1. (j-i+1) = 3. 3==3.
* Call findTopXSum(mp={1:2, 2:1}, x=2)
* pq = min-heap
* it = {1, 2}. push({2, 1}). pq={{2, 1}}. size=1.
* it = {2, 1}. push({1, 2}). pq={{1, 2}, {2, 1}}. size=2.
* map end.
* sum = 0.
* pop {1, 2}. sum += 1*2 = 2.
* pop {2, 1}. sum += 2*1 = 2.
* sum = 4.
* Return 4.
* result.push_back(4). result = [4].
* mp[nums[0]]-- -> mp[1]-- -> mp[1]=1.
* mp[1] != 0.
* i=1.
* j=3.
* * j=3: j<5. mp[nums[3]]++ -> mp[2]++ -> mp[2]=2. (j-i+1) = (3-1+1) = 3. 3==3.
* Call findTopXSum(mp={1:1, 2:2}, x=2)
* pq = min-heap
* it = {1, 1}. push({1, 1}). pq={{1, 1}}. size=1.
* it = {2, 2}. push({2, 2}). pq={{1, 1}, {2, 2}}. size=2.
* map end.
* sum = 0.
* pop {1, 1}. sum += 1*1 = 1.
* pop {2, 2}. sum += 2*2 = 4.
* sum = 5.
* Return 5.
* result.push_back(5). result = [4, 5].
* mp[nums[1]]-- -> mp[1]-- -> mp[1]=0.
* mp[1] == 0. erase(1). mp={2:2}.
* i=2.
* j=4.
* * j=4: j<5. mp[nums[4]]++ -> mp[3]++ -> mp[3]=1. (j-i+1) = (4-2+1) = 3. 3==3.
* Call findTopXSum(mp={2:2, 3:1}, x=2)
* pq = min-heap
* it = {2, 2}. push({2, 2}). pq={{2, 2}}. size=1.
* it = {3, 1}. push({1, 3}). pq={{1, 3}, {2, 2}}. size=2.
* map end.
* sum = 0.
* pop {1, 3}. sum += 1*3 = 3.
* pop {2, 2}. sum += 2*2 = 4.
* sum = 7.
* Return 7.
* result.push_back(7). result = [4, 5, 7].
* mp[nums[2]]-- -> mp[2]-- -> mp[2]=1.
* mp[2] != 0.
* i=3.
* j=5.
* * j=5: j==5. Loop terminates.
* * Return result = [4, 5, 7]
*
*/
`````

-----

## üîë Key Insights

  - **Sliding Window:** This pattern is ideal for problems that ask to compute a value for all fixed-size subarrays (`k`). It avoids re-computation by intelligently adding one new element and removing one old element.
  - **Heap for "Top K":** When a problem asks for the "top K" (or in this case, "top X") items, a heap (priority queue) is almost always more efficient than sorting.
  - **Min-Heap for "Top K Frequent":** It might seem counter-intuitive, but to find the *most* frequent items, we use a *min-heap*. We keep adding items and if the heap size exceeds `x`, we remove the *smallest* (least frequent) item. This ensures that by the end, only the top `x` largest items remain.
  - **Tie-Breaking in Heaps:** The C++ `priority_queue<pair<int, int>, ..., greater<P>>` (min-heap) handles tie-breaking automatically. It sorts by the `first` element, and if they are equal, it sorts by the `second` element. This was crucial for correctly implementing the "bigger value is more frequent" rule.

-----

## üß≠ Further Exploration

  - **True O(n log k) Solution:** Can this problem be solved more efficiently? The current `O(n * k * log(x))` solution re-builds the heap for every window. Could we *modify* the heap in O(log k) as the window slides? This is complex because changing a frequency in the map doesn't easily translate to updating the heap, which only stores `x` elements.
  - **Frequency-of-Frequencies Map:** Another advanced approach could be to maintain a map of frequencies to a list of elements (e.g., `map<int_freq, set<int_val>>`). This might allow for faster updates.
  - **Find X-Sum of All K-Long Subarrays II:** This problem is "Part I". Look for a "Part II" that might have larger constraints (e.g., `n <= 10^5`), which would *require* a more optimized solution than `O(n * k * log(x))`, likely something closer to `O(n log n)` or `O(n log k)`.

-----

## üìö References

  - [LeetCode Problem](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/description/)
  - [Sliding Window Technique](https://www.geeksforgeeks.org/window-sliding-technique/)
  - [C++ Priority Queue (Heap)](https://en.cppreference.com/w/cpp/container/priority_queue)

-----

## üè∑Ô∏è Tags

`Array` `Hash Table` `Sliding Window` `Heap` `Priority Queue` `Simulation`

-----

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/) for original content and copyright.**

-----

## üë®‚Äçüíª Author

  - [imnilesh18](https://github.com/imnilesh18)
