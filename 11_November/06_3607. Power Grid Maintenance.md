# 3607. Power Grid Maintenance

<p align="center">
  <a href="https://leetcode.com/problems/power-grid-maintenance/description/">
    <img src="https://img.shields.io/badge/LeetCode-3607-FFA116?style=for-the-badge&logo=leetcode" alt="LeetCode 3607">
  </a>
  <a href="https://leetcode.com/problems/power-grid-maintenance/description/">
    <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Difficulty Medium">
  </a>
  <a href="./cpp/solution.cpp">
    <img src="https://img.shields.io/badge/Language-C++-blue?style=for-the-badge&logo=c%2B%2B" alt="C++">
  </a>
</p>

## üìù Problem Statement

You are given an integer `c` representing `c` power stations, each with a unique identifier `id` from 1 to `c` (1‚Äëbased indexing).

These stations are interconnected via `n` bidirectional cables, represented by a 2D array `connections`, where each element `connections[i] = [ui, vi]` indicates a connection between station `ui` and station `vi`. Stations that are directly or indirectly connected form a **power grid**.

Initially, **all** stations are **online** (operational).

You are also given a 2D array `queries`, where each query is one of the following **two** types:

1.  `[1, x]`: A maintenance check is requested for station `x`.
    - If station `x` is **online**, it resolves the check by itself.
    - If station `x` is **offline**, the check is resolved by the **operational** station with the **smallest `id`** in the same power grid as `x`.
    - If no operational station exists in that grid, return `-1`.
2.  `[2, x]`: Station `x` goes **offline** (i.e., it becomes non-operational).

Return an array of integers representing the results of each query of type `[1, x]` in the order they appear.

> **Note:** The power grid preserves its structure; an offline node remains part of its grid, and taking it offline does not alter connectivity.

## üéØ Constraints

- `1 <= c <= 10^5`
- `0 <= n == connections.length <= min(10^5, c * (c - 1) / 2)`
- `connections[i].length == 2`
- `1 <= ui, vi <= c`
- `ui != vi`
- `1 <= queries.length <= 2 * 10^5`
- `queries[i].length == 2`
- `queries[i][0]` is either 1 or 2.
- `1 <= queries[i][1] <= c`

## üìä Examples

### Example 1

| Input                                                                                               | Output    |
| :-------------------------------------------------------------------------------------------------- | :-------- |
| `c = 5`<br>`connections = [[1,2],[2,3],[3,4],[4,5]]`<br>`queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]` | `[3,2,3]` |

**Explanation:**

1.  Initially, all stations `{1, 2, 3, 4, 5}` are online and form a single power grid.
2.  `[1,3]`: Station 3 is online -> resolves by itself. Result: `3`.
3.  `[2,1]`: Station 1 goes offline. Online: `{2, 3, 4, 5}`.
4.  `[1,1]`: Station 1 offline. Smallest online in same grid is 2. Result: `2`.
5.  `[2,2]`: Station 2 goes offline. Online: `{3, 4, 5}`.
6.  `[1,2]`: Station 2 offline. Smallest online in same grid is 3. Result: `3`.

### Example 2

| Input                                                            | Output   |
| :--------------------------------------------------------------- | :------- |
| `c = 3`<br>`connections = []`<br>`queries = [[1,1],[2,1],[1,1]]` | `[1,-1]` |

**Explanation:**

1.  No connections, each station is its own grid.
2.  `[1,1]`: Station 1 online -> Result: `1`.
3.  `[2,1]`: Station 1 goes offline.
4.  `[1,1]`: Station 1 offline, no other stations in grid -> Result: `-1`.

## üí° Key Insights

- **Connected Components:** The problem specifies that connectivity never changes even if a node goes offline. This means we can pre-calculate which "grid" (connected component) every station belongs to.
- **Offline vs. Removed:** "Offline" just means a status change; it doesn't break the graph. We don't need dynamic graph algorithms.
- **Efficient Min-Query:** For Type 1 queries on an offline node, we need the _smallest_ available ID in its component. An **ordered set** (like `std::set` in C++ or `TreeSet` in Java) is perfect for this. It keeps elements sorted and allows $O(\log N)$ insertions, deletions, and retrieval of the minimum element.
- **Component Mapping:** We need a quick way to know which component a station `x` belongs to. A simple array `componentOf[x]` can store the component ID.

## üìù Approach

1.  **Graph Representation:** Build an adjacency list from `connections` to represent the power grid.
2.  **Pre-processing (DFS/BFS):**
    - Iterate through all stations from 1 to `c`.
    - If a station hasn't been visited, start a traversal (DFS or BFS) to find all stations in its connected component.
    - Assign a unique `componentId` to all these stations.
    - Store all these stations in an ordered set specific to that `componentId`.
3.  **Query Processing:**
    - **Type 1 `[1, x]`:**
      - Find the `componentId` of station `x`.
      - Check the ordered set for this component.
      - If `x` is present in the set, it's online. Return `x`.
      - If `x` is not present, it's offline. Return the smallest element in the set (`*set.begin()`).
      - If the set is empty, return `-1`.
    - **Type 2 `[2, x]`:**
      - Find the `componentId` of station `x`.
      - Remove `x` from the ordered set of that component.

## üöÄ Solution Code

```cpp
// Intuition: Since the power grid's connectivity structure doesn't change (only station status changes), we can pre-calculate connected components. Using an ordered set for each component allows efficiently finding the smallest available station when needed.
// Approach: 1. Build graph from connections. 2. Use DFS to find connected components, storing each component's stations in a sorted set. 3. For each query, use the pre-calculated component info to quickly check status, find the smallest online station, or update station status.
// Time Complexity: O(C + N + Q * log C) where C is number of stations, N is number of connections, Q is number of queries. DFS takes O(C+N), and each query involves set operations taking O(log C).
// Space Complexity: O(C + N) to store the graph, visited array, component mapping, and sets of stations.

class Solution {
public:
    // Map to store online stations for each component, kept sorted for easy access to smallest ID
    unordered_map<int, set<int>> componentStations;

    void dfs(int node, unordered_map<int, vector<int>>& adj,
             vector<int>& visited, int componentId, vector<int>& componentOf)  {
        visited[node] = 1;
        componentOf[node] = componentId; // Map node to its component ID
        componentStations[componentId].insert(node); // Add node to this component's set

        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                dfs(neighbor, adj, visited, componentId, componentOf);
            }
        }
    }

    vector<int> processQueries(int c, vector<vector<int>>& connections,
                               vector<vector<int>>& queries) {
        unordered_map<int, vector<int>> adj;
        vector<int> visited(c + 1, 0);
        vector<int> componentOf(c + 1); // Fast lookup for a station's component ID

        // Build the graph
        for (auto& edge : connections) {
            int u = edge[0];
            int v = edge[1];
            adj[u].push_back(v);
            adj[v].push_back(u);
        }

        // Pre-process connected components
        for (int node = 1; node <= c; node++) {
            if (!visited[node]) {
                // Start DFS from unvisited node, using it as component ID
                dfs(node, adj, visited, node, componentOf);
            }
        }

        vector<int> result;

        // Process each query
        for (auto& q : queries) {
            int type = q[0];
            int x = q[1];
            int compId = componentOf[x]; // Get component ID for station x

            if (type == 1) {
                // Check maintenance request
                if (componentStations[compId].count(x)) {
                    result.push_back(x); // Station x is online
                }
                else if (!componentStations[compId].empty()) {
                    // Station x offline, find smallest operational in same grid
                    result.push_back(*componentStations[compId].begin());
                }
                else {
                    result.push_back(-1); // No stations online in this grid
                }
            }
            else {
                // Station x goes offline, remove from set
                componentStations[compId].erase(x);
            }
        }

        return result;
    }
};

/*
*
* Dry Run Example:
* Input: c = 5, connections = [[1,2],[2,3],[3,4],[4,5]], queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]
*
* 1. Graph & Components (Pre-processing):
* - DFS finds one component {1, 2, 3, 4, 5} with ID 1.
* - componentStations[1] = {1, 2, 3, 4, 5}
* - componentOf = [0, 1, 1, 1, 1, 1] (1-based indexing)
*
* 2. Query processing:
* - [1, 3]: Type 1 on station 3. ID=1. 3 is in set. Result: [3]
* - [2, 1]: Type 2 on station 1. ID=1. Remove 1. Set is now {2, 3, 4, 5}.
* - [1, 1]: Type 1 on station 1. ID=1. 1 NOT in set. Smallest is *begin() = 2. Result: [3, 2]
* - [2, 2]: Type 2 on station 2. ID=1. Remove 2. Set is now {3, 4, 5}.
* - [1, 2]: Type 1 on station 2. ID=1. 2 NOT in set. Smallest is *begin() = 3. Result: [3, 2, 3]
*
* Final Output: [3, 2, 3]
*
*/
```

## üè∑Ô∏è Tags

`Graph` `Depth-First Search` `Breadth-First Search` `Union Find` `Hash Table` `Design`

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/power-grid-maintenance/description/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
