# 3542. Minimum Operations to Convert All Elements to Zero

<p align="center">
  <a href="https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/">
    <img src="https://img.shields.io/badge/LeetCode-3542-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 3542">
  </a>
  <a href="#beware-brute-force">
    <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Difficulty Medium">
  </a>
  <a href="#monotonous-stack-approach">
    <img src="https://img.shields.io/badge/Topic-Monotonic%20Stack-blue?style=for-the-badge" alt="Monotonic Stack">
  </a>
</p>

## üìù Problem Statement

You are given an array `nums` of size `n`, consisting of **non-negative** integers. Your task is to apply some (possibly zero) operations on the array so that **all** elements become 0.

In one operation, you can select a **subarray** `[i, j]` (where `0 <= i <= j < n`) and set all occurrences of the **minimum** non-negative integer in that subarray to 0.

Return the **minimum** number of operations required to make all elements in the array 0.

## üéØ Examples

**Example 1:**

```

Input: nums = [0,2]
Output: 1
Explanation:

  - Select subarray [1,1] (which is [2]). Minimum is 2. Setting it to 0 yields [0,0].
    Total operations: 1.

```

**Example 2:**

```

Input: nums = [3,1,2,1]
Output: 3
Explanation:

  - Select [1,3] ([1,2,1]), min is 1. Array becomes [3,0,2,0].
  - Select [2,2] ([2]), min is 2. Array becomes [3,0,0,0].
  - Select [0,0] ([3]), min is 3. Array becomes [0,0,0,0].
    Total operations: 3.


```

**Example 3:**

```

Input: nums = [1,2,1,2,1,2]
Output: 4
Explanation:

  - Select [0,5], min is 1. Array becomes [0,2,0,2,0,2].
  - Three more operations are needed to clear the remaining individual 2s.
    Total operations: 4.


````

## üîí Constraints

- `1 <= n == nums.length <= 10^5`
- `0 <= nums[i] <= 10^5`

---

## üí° Intuition & Approach

The core of this problem lies in understanding when a single operation can cover multiple occurrences of the same number.

An operation on a subarray clears all occurrences of its *minimum* value. This means if we want to clear multiple occurrences of a value `X` in one go, `X` must be the minimum value in the chosen subarray.

If we have an array like `[... X ... Y ... X ...]`, we can only clear both `X`s together if NO element between them (represented by `Y`) is strictly smaller than `X`. If `Y < X`, any subarray containing both `X`s will have `Y` (or something even smaller) as the minimum, preventing `X` from being cleared.

### üõë Brute Force (Thinking Process)

We could iterate through every unique number in the array and try to clear them. For a specific target number, we scan the array. When we find the target, we start a "flow" (a potential subarray). We continue this flow until we hit an element smaller than the target. Hitting a smaller element breaks the flow, meaning any subsequent occurrences of the target must be cleared by a *new* operation.

While conceptually simple, this requires iterating the array for every unique element, leading to $O(N \times U)$ time complexity, which will TLE given $N=10^5$.

### üöÄ Optimized Approach (Monotonic Stack)

We can optimize this by processing elements once using a **Monotonic Increasing Stack**. The stack will maintain the current "active" minimums that we are trying to extend.

1.  **Traverse** the array from left to right. Skip any `0`s as they don't need operations.
2.  If we encounter a number `nums[i]` that is **smaller** than the stack's top, it "breaks" the active subarrays for those larger elements. We pop them from the stack.
3.  After popping, if the stack is empty or the current number is **strictly greater** than the new stack top, it means we have encountered a new "local minimum" that needs its own operation. We push it to the stack and increment our operation count.
4.  If it's **equal** to the stack top, it can be cleared by the same operation already counted for the element on the stack, so we don't increment the count.

This ensures we only count a new operation when absolutely necessary, specifically when a new value starts a sequence that cannot be "covered" by a previously counted operation.

---

## üíª Solution Code

### üê¢ Brute Force Approach

```cpp
// Intuition: For each unique number, try to form the longest valid subarrays where it remains the minimum.
// Approach: Iterate through every unique target number. Scan array to find contiguous segments of 'target' not broken by smaller numbers.
// Time Complexity: O(N * U), where N is array size and U is number of unique elements. TLE for large inputs.
// Space Complexity: O(U) to store unique elements.
class Solution {
public:
    int minOperations(vector<int>& nums) {
        unordered_set<int> st(begin(nums), end(nums)); // Store unique elements
        int n = nums.size();
        int ops = 0;

        // Try to clear each unique number
        for(int target : st) {
            if(target == 0) continue; // 0s don't need operations
            
            bool flow = false; // Track if we are in a valid subarray for 'target'
            for(int i = 0; i < n; i++) {
                if(nums[i] == target) {
                    // Found target. If not currently in a flow, start a new operation.
                    if(!flow) {
                        flow = true;
                        ops++;
                    }
                } else if(nums[i] < target) {
                    // Found a smaller element. This breaks the current subarray flow.
                    flow = false;
                }
                // If nums[i] > target, flow continues (it's safe to include larger elements)
            }
        }
        return ops;
    }
};

/*
* Dry Run: nums = [3, 1, 2, 1]
* Unique elements: {1, 2, 3}
* Target 1: Indices 1, 3 are '1'. Index 2 is '2' (>1). 
* Flow starts at idx 1, continues through idx 2, covers idx 3. Ops changes: 0 -> 1.
* Target 2: Index 2 is '2'. Index 1 is '1' (<2).
* Idx 0 is 3 (>2, safe), Idx 1 is 1 (<2, breaks flow).
* At idx 2, found '2', flow=false -> start new flow, ops++. Ops changes: 1 -> 2.
* Target 3: Index 0 is '3'.
* At idx 0, found '3', flow=false -> start new flow, ops++. Ops changes: 2 -> 3.
* Final Result: 3
*/
````

### üêá Optimized Approach (Monotonic Stack)

```cpp
// Intuition: Use a monotonic increasing stack to track active operations. A smaller element 'breaks' the continuity of larger previous elements.
// Approach: Maintain a stack of elements that can still be extended to the right. When finding a smaller element, pop larger ones as their active subarray cannot extend further. Push new elements if they are strictly larger than the current stack top.
// Time Complexity: O(N), each element is pushed and popped at most once.
// Space Complexity: O(N) in worst case for strictly increasing array.
class Solution {
public:
    int minOperations(vector<int>& nums) {
        stack<int> st;
        int ops = 0;

        for(int i = 0; i < nums.size(); i++) {
            // If we find a smaller element, previous larger elements cannot
            // extend past this point. They are "finished".
            while(!st.empty() && st.top() > nums[i]) {
                st.pop();
            }

            // 0s don't require an operation to clear.
            if(nums[i] == 0) continue;
            
            // If stack is empty or current is strictly greater than top,
            // it marks the start of a new necessary operation.
            // If it's equal to st.top(), it's covered by the existing operation.
            if(st.empty() || st.top() < nums[i]) {
                st.push(nums[i]);
                ops++;
            }
        }

        return ops;
    }
};

/*
* Dry Run: nums = [3, 1, 2, 1]
* i=0, nums[0]=3: Stack empty. Push 3, ops=1. Stack: [3]
* i=1, nums[1]=1: 1 < 3. Pop 3. Stack empty. Push 1, ops=2. Stack: [1]
* i=2, nums[2]=2: 2 > 1. Push 2, ops=3. Stack: [1, 2]
* i=3, nums[3]=1: 1 < 2. Pop 2. Stack: [1]. 
* Current 1 == st.top() (1). Do nothing. Stack: [1]
* End Loop. Return ops = 3.
*/
```

-----

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-operations-to-convert-all-elements-to-zero/) for original content and copyright.**

## üë®‚Äçüíª Author

  - [imnilesh18](https://github.com/imnilesh18)
