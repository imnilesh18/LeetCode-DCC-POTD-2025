# 2654. Minimum Number of Operations to Make All Array Elements Equal to 1

<p align="center">
  <img src="https://img.shields.io/badge/Difficulty-Medium-yellow.svg" alt="Difficulty: Medium">
  <a href="https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/description/" target="_blank">
    <img src="https://img.shields.io/badge/LeetCode-Problem%20Link-blue.svg?style=flat-square" alt="LeetCode Problem Link">
  </a>
  <img src="https://img.shields.io/badge/Topics-Array-green.svg" alt="Topic: Array">
  <img src="https://img.shields.io/badge/Topics-Math-orange.svg" alt="Topic: Math">
  <img src="https://img.shields.io/badge/Topics-Number%20Theory-red.svg" alt="Topic: Number Theory">
</p>

---

## üìù Problem Statement

You are given a **0-indexed** array `nums` consisting of **positive** integers. You can do the following operation on the array **any** number of times:

-   Select an index `i` such that `0 <= i < n - 1` and replace either of `nums[i]` or `nums[i+1]` with their **gcd** value.

Return *the **minimum** number of operations to make all elements of `nums` equal to `1`*. If it is impossible, return `-1`.

The **gcd** of two integers is the greatest common divisor of the two integers.

---

## ‚õìÔ∏è Constraints

-   `2 <= nums.length <= 50`
-   `1 <= nums[i] <= 10^6`

---

## üìä Examples

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [2,6,3,4]` | `4` | 1. Choose `i = 2` and replace `nums[2]` with `gcd(3,4) = 1`. `nums = [2,6,1,4]`.<br>2. Choose `i = 1` and replace `nums[1]` with `gcd(6,1) = 1`. `nums = [2,1,1,4]`.<br>3. Choose `i = 0` and replace `nums[0]` with `gcd(2,1) = 1`. `nums = [1,1,1,4]`.<br>4. Choose `i = 2` and replace `nums[3]` with `gcd(1,4) = 1`. `nums = [1,1,1,1]`. |
| `nums = [2,10,6,14]` | `-1` | It can be shown that it is impossible to make all elements equal to 1. |

---

## üß† Approach & Rationale

The problem asks for the minimum operations to make all array elements `1`. The key operation is `gcd(nums[i], nums[i+1])`. The core logic splits into two distinct cases.

<details>
<summary><strong>Case 1: The array already contains at least one '1' ü•≥</strong></summary>

This is the simplest case. If we have even one `1` in the array, we can use it to "infect" all other elements.

-   The `gcd(x, 1)` is always `1`, regardless of what `x` is.
-   We can take our existing `1` and perform the GCD operation with its neighbor. This turns the neighbor into a `1` in one operation.
-   We can then propagate this `1` across the entire array.
-   If the array has `n` elements and already contains `count1` ones, we only need to convert the remaining `n - count1` elements.
-   Each conversion takes one operation.
-   Therefore, if `count1 > 0`, the answer is simply `n - count1`.

**Example:** `nums = [2, 6, 1, 4]`
1.  `n = 4`, `count1 = 1`. We need to convert `4 - 1 = 3` elements.
2.  `gcd(6, 1) = 1`. `nums = [2, 1, 1, 4]`. (1 operation)
3.  `gcd(2, 1) = 1`. `nums = [1, 1, 1, 4]`. (1 operation)
4.  `gcd(1, 4) = 1`. `nums = [1, 1, 1, 1]`. (1 operation)
Total operations = `3`, which matches our formula `n - count1 = 4 - 1 = 3`.

</details>

<details>
<summary><strong>Case 2: The array contains no '1's ü§î</strong></summary>

If there are no `1`s, our first task is to **create one**.

1.  **Creating a '1'**: A `1` can only be created if some contiguous subarray `nums[i...j]` has a total GCD of `1`.
2.  **Cost of Creating '1'**: To find the `gcd(nums[i], nums[i+1], ..., nums[j])`, we need to perform the operation `j - i` times.
    -   `op1 = gcd(nums[i], nums[i+1])` (replace `nums[i]`)
    -   `op2 = gcd(op1, nums[i+2])` (replace `nums[i]`)
    -   ...
    -   `op(j-i) = gcd(op(j-i-1), nums[j])` (replace `nums[i]`)
    This takes `j - i` operations to create a `1` at index `i`.
3.  **Minimizing Cost**: We need to find the *shortest* such subarray `[i...j]` that has a GCD of `1`, as this will have the minimum creation cost (`j - i`). We can find this by iterating through all possible start indices `i` and for each `i`, finding the first `j` such that `gcd(nums[i...j]) == 1`. We'll store the minimum `j - i` found as `minStepsTo1`.
4.  **Propagating the '1'**: Once we spend `minStepsTo1` operations to create our first `1`, we are back to Case 1. We now have an array with one `1` and `n - 1` other elements.
5.  **Total Cost**: It will take an additional `n - 1` operations to propagate this newly created `1` to the rest of the array.
    
    **Total Operations = `minStepsTo1` + `(n - 1)`**

6.  **Impossible Case**: If we check all possible subarrays and none of them has a GCD of `1`, it's impossible to ever create a `1`. In this case, `minStepsTo1` will remain at its initial `INT_MAX` value, and we return `-1`.

</details>

---

## üíª Solution Code

Here is the C++ implementation based on the described approach.

```cpp
// Intuition: The problem boils down to two cases: 
// 1. If the array already has a '1', we can use it to convert all other (n-1) elements to 1 in (n-1) operations. If there are 'k' ones, we only need to convert (n-k) elements.
// 2. If no '1' exists, we must first create one. We find the shortest subarray [i...j] whose GCD is 1. This takes (j-i) operations. Once we have this '1', it takes an additional (n-1) operations to convert the rest of the array. The total is (j-i) + (n-1). We minimize (j-i).
// Approach:
// 1. Count the number of '1's in the array. Let this be 'count1'.
// 2. If 'count1' > 0, return 'n - count1' as the answer.
// 3. If 'count1' == 0, initialize 'minStepsTo1' to INT_MAX.
// 4. Iterate through the array with an outer loop 'i' from 0 to n-1 (our starting point).
// 5. Start an inner loop 'j' from i+1 to n-1 (our ending point).
// 6. Maintain a running 'GCD' starting from 'nums[i]' and accumulating 'nums[j]'.
// 7. If the 'GCD' becomes 1, we've found a subarray [i...j] that can create a '1'.
// 8. The cost to create this '1' is 'j - i' operations. Update 'minStepsTo1 = min(minStepsTo1, j - i)'.
// 9. Break the inner loop since we found the shortest subarray starting from 'i'.
// 10. After checking all 'i', if 'minStepsTo1' is still INT_MAX, it's impossible to create a '1'. Return -1.
// 11. Otherwise, return 'minStepsTo1 + (n - 1)', which is the cost to create the first '1' plus the cost to propagate it.

//Approach - Turn an element to 1 and make all elements 1 using it.
//T.C : O(n^2 * log(M)), M = maximum number
//S.C : O(1)
class Solution {
public:
    int minOperations(vector<int>& nums) {
        int n = nums.size(); // Get the total number of elements

        int count1 = 0; // Counter for elements already equal to 1
        // First, check for any existing '1's
        for(int i = 0; i < n; i++) {
            if(nums[i] == 1)
                count1++; // Increment the counter if '1' is found
        }

        // Case 1: If we already have at least one '1'
        if(count1 > 0) {
            // We just need to convert the remaining (n - count1) elements
            // Each takes 1 operation (gcd(x, 1) = 1)
            return n - count1;
        }

        // Case 2: No '1's exist. We must create one.
        int minStepsTo1 = INT_MAX; // Track the minimum operations to create a '1'
        
        // Iterate through all possible subarray start indices 'i'
        for(int i = 0; i < n; i++) {
            int GCD = nums[i]; // Initialize the GCD for the subarray starting at 'i'
            
            // Iterate through all possible subarray end indices 'j'
            for(int j = i+1; j < n; j++) {
                // Calculate the running GCD of the subarray nums[i...j]
                GCD = gcd(GCD, nums[j]); // Assumes std::gcd (C++17) or built-in __gcd
                
                // If the GCD of this subarray is 1
                if(GCD == 1) {
                    // We can create a '1' in (j-i) operations
                    minStepsTo1 = min(minStepsTo1, j-i); // Update the minimum steps
                    break; // Found the shortest subarray starting at 'i', no need to check further
                }
            }
        }

        // If minStepsTo1 never changed, it's impossible to create a '1'
        if(minStepsTo1 == INT_MAX) {
            return -1; // Return -1 as per problem description
        }
        
        // Total ops = (steps to create first '1') + (steps to convert remaining n-1 elements)
        return minStepsTo1 + (n-1);
    }
};
/*
*
* Dry Run
*
* Example 1: nums = [2, 6, 3, 4]
* n = 4
* count1 = 0. (No '1's are present)
* minStepsTo1 = INT_MAX
*
* Outer loop i = 0 (start at nums[0] = 2):
* GCD = 2
* Inner loop j = 1 (nums[1] = 6):
* GCD = gcd(2, 6) = 2
* Inner loop j = 2 (nums[2] = 3):
* GCD = gcd(2, 3) = 1
* GCD == 1 is true.
* minStepsTo1 = min(INT_MAX, j-i) = min(INT_MAX, 2-0) = 2
* break inner loop.
*
* Outer loop i = 1 (start at nums[1] = 6):
* GCD = 6
* Inner loop j = 2 (nums[2] = 3):
* GCD = gcd(6, 3) = 3
* Inner loop j = 3 (nums[3] = 4):
* GCD = gcd(3, 4) = 1
* GCD == 1 is true.
* minStepsTo1 = min(2, j-i) = min(2, 3-1) = min(2, 2) = 2
* break inner loop.
*
* Outer loop i = 2 (start at nums[2] = 3):
* GCD = 3
* Inner loop j = 3 (nums[3] = 4):
* GCD = gcd(3, 4) = 1
* GCD == 1 is true.
* minStepsTo1 = min(2, j-i) = min(2, 3-2) = min(2, 1) = 1
* break inner loop.
*
* Outer loop i = 3 (start at nums[3] = 4):
* Inner loop (j=4) does not run.
*
* End of loops.
* minStepsTo1 is 1 (not INT_MAX).
* Return minStepsTo1 + (n-1) = 1 + (4-1) = 1 + 3 = 4.
*
*
* Example 2: nums = [2, 10, 6, 14]
* n = 4
* count1 = 0
* minStepsTo1 = INT_MAX
*
* Outer loop i = 0 (start at 2):
* j=1: GCD = gcd(2, 10) = 2
* j=2: GCD = gcd(2, 6) = 2
* j=3: GCD = gcd(2, 14) = 2
* (minStepsTo1 remains INT_MAX)
*
* Outer loop i = 1 (start at 10):
* j=2: GCD = gcd(10, 6) = 2
* j=3: GCD = gcd(2, 14) = 2
* (minStepsTo1 remains INT_MAX)
*
* Outer loop i = 2 (start at 6):
* j=3: GCD = gcd(6, 14) = 2
* (minStepsTo1 remains INT_MAX)
*
* End of loops.
* minStepsTo1 is still INT_MAX.
* Return -1.
*
*/
```

---

## üí° Key Insights

-   **The Power of '1'**: The entire problem hinges on obtaining a single `1`. Once a `1` exists, the problem becomes trivial and costs `n - (number of existing 1s)` operations.
-   **GCD is Associative**: `gcd(a, b, c) = gcd(gcd(a, b), c)`. This property is what allows us to calculate the GCD of a subarray `[i...j]` by using a running GCD variable.
-   **Cost Structure**: The cost is always `(cost to create first 1) + (cost to propagate 1)`. If the first cost is 0 (a '1' already exists), the total cost is just the propagation cost.
-   **Impossibility Condition**: If the GCD of the *entire array* is greater than `1`, then the GCD of *any* subarray will also be greater than `1`. Therefore, it's impossible to ever create a `1`.

---

## üöÄ Further Exploration

-   **Optimization**: Can we find the shortest subarray with GCD `1` faster than O(n¬≤)? Given the small constraint (`n <= 50`), O(n¬≤) is perfectly acceptable. If `n` were large (e.g., `10^5`), we might need a more advanced data structure, like a **Segment Tree** with a GCD query, combined with **Binary Search** to find the shortest range `[i, j]` for each `i` where `query(i, j) == 1`. This would be more complex, likely O(n * log(n) * log(M)).

---

## üìö References

-   [GeeksforGeeks: GCD (Greatest Common Divisor)](https://www.geeksforgeeks.org/c-program-find-gcd-hcf-two-numbers/)
-   [LeetCode Problem: 2654. Minimum Number of Operations to Make All Array Elements Equal to 1](https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/description/)

---

## üè∑Ô∏è Tags

`Array` `Math` `Number Theory` `GCD`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/) for original content and copyright.**

---

## üë®üíª Author

-   [imnilesh18](https://github.com/imnilesh18)