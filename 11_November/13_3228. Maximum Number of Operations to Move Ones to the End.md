# 3228. Maximum Number of Operations to Move Ones to the End

![Difficulty](https://img.shields.io/badge/Difficulty-Medium-yellow.svg) &nbsp; ![Language](https://img.shields.io/badge/Language-C%2B%2B-blue.svg)

---

### <a href="https://leetcode.com/problems/maximum-number-of-operations-to-move-ones-to-the-end/" target="_blank">üîó Problem Link</a>

**Problem Name:** `3228. Maximum Number of Operations to Move Ones to the End`
**Difficulty:** `Medium`
**Tags:** `String`, `Greedy`, `Counting`

---

## üìù Problem Statement

You are given a **binary string** `s`.

You can perform the following operation on the string **any** number of times:
* Choose **any** index `i` from the string where `i + 1 < s.length` such that `s[i] == '1'` and `s[i + 1] == '0'`.
* Move the character `s[i]` to the **right** until it reaches the end of the string or another `'1'`. For example, for `s = "010010"`, if we choose `i = 1`, the resulting string will be `s = "000110"`.

Return the *maximum* number of operations that you can perform.

---

## üìä Examples

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `s = "1001101"` | `4` | We can perform the following operations:<br>1. Choose `i = 0`. `s` becomes `"0011101"`.<br>2. Choose `i = 4`. `s` becomes `"0011011"`.<br>3. Choose `i = 3`. `s` becomes `"0010111"`.<br>4. Choose `i = 2`. `s` becomes `"0001111"`. |
| `s = "00111"` | `0` | No operations can be performed. |

---

## üõë Constraints

* `1 <= s.length <= 10^5`
* `s[i]` is either `'0'` or `'1'`.

---

## üí° Approach Walkthrough

The core of this problem is to maximize the number of operations. An "operation" is defined as picking a `'1'` at index `i` that has a `'0'` at `i+1`.

<details>
<summary>Why traverse Left-to-Right (LTR)?</summary>

Let's analyze two approaches:
1.  **Right-to-Left (RTL):** If we start from the right, like in `"1001101"`, we might first move the `'1'` at `i=5`. The string becomes `"1001011"`. This move "clears the path" for the other ones. The `'1'` at `i=3` can then move past the `'0'` at `i=4` in one operation. This tends to *minimize* operations because we are creating space for future moves.
2.  **Left-to-Right (LTR):** If we start from the left, we first process the `'1'` at `i=0`. It moves past the two `'0'`s and stops at the `'1'` at `i=3`. The string becomes `"0011101"`. Notice that the `'1'`s at `i=3` and `i=4` (original indices) *haven't moved yet*. This "blocks" the first `'1'` from moving further, but it also preserves future operations.

To **maximize** operations, we want each `'1'` to participate in as many "hops" as possible. The LTR approach ensures this. When we find a `'1'`, we count it. When we find a `'0'`, we know that *all* the `'1'`s we've counted so far *must* hop over this `'0'`. This adds `count_of_ones` to our total operations.

</details>

### The Greedy Strategy

1.  We will iterate through the string from left to right.
2.  We'll maintain a counter, `count1Seen`, which stores the number of `'1'`s we have encountered in the current contiguous block of `'1'`s.
3.  When we encounter a `'1'` (`s[i] == '1'`), we simply increment `count1Seen`.
4.  When we encounter a `'0'` (`s[i] == '0'`), this is where an operation happens. Every single `'1'` we've counted in `count1Seen` will eventually have to move past this `'0'`.
5.  Therefore, we add `count1Seen` to our `result` (total operations).
6.  **Crucially**: The problem states a `'1'` moves until it hits *another* `'1'` or the end. This implies that a block of ones moves together past a block of zeros. So, after processing the first `'0'` in a block, we must skip all subsequent contiguous `'0'`s, as they are all part of the same "hop" operation.
7.  We use an inner loop (`while(i < n && s[i] == '0') i++;`) to skip this entire block of `'0'`s.
8.  The outer loop then continues from the character *after* this block of `'0'`s (which is either a `'1'` or the end of the string).

This ensures that for every block of `'0'`s, we add the count of *all* preceding `'1'`s to our total, correctly maximizing the operations.

---

## üíª Optimized Solution (C++)

```cpp
// Intuition: The max operations are achieved by moving each '1' past a '0' block. By traversing left-to-right, every time we hit a '0' (or a block of '0's), the total number of operations we can perform is equal to the number of '1's we've seen so far, as each of them will need to be "hopped" over this '0' block.

// Approach:
// 1. Initialize `result = 0` (total operations) and `count1Seen = 0`.
// 2. Iterate through the string `s` with index `i`.
// 3. If `s[i] == '1'`, increment `count1Seen` and move to the next character (`i++`).
// 4. If `s[i] == '0'`, it means all `count1Seen` ones (from its left) can be moved past this zero.
// 5. Add `count1Seen` to `result`.
// 6. After adding, skip all consecutive '0's (`while(i < n && s[i] == '0') i++;`) because this group of '1's moves past the *entire block* of zeros.
// 7. The loop continues from the new `i`. Note that `i` is not incremented in the `else` block because the inner `while` loop handles the increment.
// 8. Return `result`.

// Time Complexity: O(n), where n is the length of the string. We traverse the string at most once. The inner `while` loop only skips elements, and `i` never decreases, ensuring a single linear pass.
// Space Complexity: O(1), as we only use a few constant extra variables.

class Solution {
public:
    int maxOperations(string s) {
        int n = s.length(); // Get the length of the string
        int result = 0;     // Initialize total operations counter
        int i = 0;          // Initialize the string iterator
        int count1Seen = 0; // Counter for '1's seen so far in the current group

        while(i < n) { // Iterate through the string
            if(s[i] == '0') {
                // We found a '0'. All previously seen '1's must hop over this.
                result += count1Seen; // Add the count of '1's to the result

                // Skip all consecutive '0's as they form a single "block"
                // The group of '1's moves past this entire block
                while(i < n && s[i] == '0') {
                    i++;
                }
            } else { // s[i] == '1'
                count1Seen++; // Increment the count of '1's
                i++; // Move to the next character
            }
        }  
        return result; // Return the total maximum operations
    }
};

/*
*
* Dry Run
*
* s = "1001101"
* n = 7
* result = 0
* i = 0
* count1Seen = 0
*
* Loop 1: i = 0, s[0] = '1'
* - s[i] is '1'.
* - count1Seen = 1.
* - i = 1.
*
* Loop 2: i = 1, s[1] = '0'
* - s[i] is '0'.
* - result += count1Seen => result = 0 + 1 = 1.
* - Inner loop (skip '0's):
* - i = 1, s[1] = '0'. i becomes 2.
* - i = 2, s[2] = '0'. i becomes 3.
* - i = 3, s[3] = '1'. Loop breaks.
* - `i` is now 3.
*
* Loop 3: i = 3, s[3] = '1'
* - s[i] is '1'.
* - count1Seen = 2. (We had 1, now we add this new one)
* - i = 4.
*
* Loop 4: i = 4, s[4] = '1'
* - s[i] is '1'.
* - count1Seen = 3.
* - i = 5.
*
* Loop 5: i = 5, s[5] = '0'
* - s[i] is '0'.
* - result += count1Seen => result = 1 + 3 = 4.
* - Inner loop (skip '0's):
* - i = 5, s[5] = '0'. i becomes 6.
* - i = 6, s[6] = '1'. Loop breaks.
* - `i` is now 6.
*
* Loop 6: i = 6, s[6] = '1'
* - s[i] is '1'.
* - count1Seen = 4.
* - i = 7.
*
* Loop 7: i = 7
* - `i < n` is false (7 < 7 is false).
* - Outer loop terminates.
*
* Final Answer: return result (which is 4).
*
*/
```

---

## üîë Key Insights

* **Maximization vs. Minimization:** The choice of traversal direction is key. A Left-to-Right (LTR) traversal maximizes operations because it counts "potential" moves before they are consolidated. A Right-to-Left (RTL) traversal would *minimize* operations, as moving a right-most `'1'` first clears a path for others, reducing their individual operation counts.
* **Blocks, not Individuals:** The problem logic implies we are moving a *block* of ones past a *block* of zeros. This is why when we find a `'0'`, we add `count1Seen` and then *skip* all subsequent `'0'`s. This correctly models the problem and avoids overcounting.

---

## üöÄ Further Exploration

* **Minimizing Operations:** How would you modify the code to find the *minimum* number of operations to move all ones to the end? (Hint: Consider the RTL traversal discussed in the "Approach" section).
* **Varying Costs:** What if moving a `'1'` past a `'0'` had a cost equal to the number of `'0'`s it skipped? How would the solution change?

---

## üîó References

* [LeetCode Problem](https://leetcode.com/problems/maximum-number-of-operations-to-move-ones-to-the-end/)
* [Greedy Algorithms](https://en.wikipedia.org/wiki/Greedy_algorithm)
* [String Traversal Techniques](https://www.geeksforgeeks.org/string-data-structure/)

---

## üè∑Ô∏è Tags

`LeetCode`, `Medium`, `String`, `Greedy`, `Counting`, `C++`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/maximum-number-of-operations-to-move-ones-to-the-end/) for original content and copyright.**

---

## üë®üíª Author

-   [imnilesh18](https://github.com/imnilesh18)