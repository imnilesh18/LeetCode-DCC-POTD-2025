# 1513. Number of Substrings With Only 1s

<p align="center">
  <a href="https://leetcode.com/problems/number-of-substrings-with-only-1s/description/">
    <img src="https://img.shields.io/badge/LeetCode-1513-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 1513">
  </a>
</p>

## ğŸ“ Problem Format

- **Problem Link:** [LeetCode 1513. Number of Substrings With Only 1s](https://leetcode.com/problems/number-of-substrings-with-only-1s/description/)
- **Difficulty:** [Medium]
- **Tags:** `Math`, `String`, `Counting`

## ğŸ“œ Problem Statement

Given a binary string `s`, return the number of substrings with all characters `'1'`s. Since the answer may be too large, return it modulo `10^9 + 7`.

## ğŸ“¦ Constraints

- `1 <= s.length <= 10^5`
- `s[i]` is either `'0'` or `'1'`.

## ğŸ“Š Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :---: | :--- |
| **1** | `s = "0110111"` | `9` | There are 9 substrings in total with only 1's characters:<br>"1" -> 5 times<br>"11" -> 3 times<br>"111" -> 1 time |
| **2** | `s = "101"` | `2` | Substring "1" is shown 2 times in `s`. |
| **3** | `s = "111111"` | `21` | Each substring contains only 1's characters. |

## ğŸ’¡ Explanation

The core of this problem lies in counting the number of contiguous sequences of `'1'`s. 

1.  **Identifying Groups:** We need to break the string down into groups of consecutive ones. For example, in `0110111`, we have groups `11` (length 2) and `111` (length 3).
2.  **Mathematical Insight:** For a single block of `n` consecutive ones, the number of substrings containing only ones is the sum of integers from 1 to `n`. This is calculated using the formula: `n * (n + 1) / 2`.
    * Example: `111` (length 3) has substrings: `1` (three times), `11` (two times), `111` (one time). Total = 3 + 2 + 1 = 6.
3.  **Handling Overflows:** Since the result can be large, we perform calculations modulo `10^9 + 7`.

We can solve this in two slightly different ways:
* **Approach 1:** Calculate the length of each contiguous block of 1s and apply the formula when the block ends (or when we hit a '0').
* **Approach 2:** Add to the result incrementally. For every '1' we encounter, if it extends a sequence of length `k`, it adds `k+1` new substrings ending at that position.

## ğŸ’» Solution Code

### Approach 1: Mathematical Formula (Group Processing)

```cpp
// Intuition: Identify consecutive groups of '1's. For a group of length n, total substrings = n*(n+1)/2.
// Approach: Traverse string, count consecutive '1's. On encountering '0', add formula result to total and reset count. Handle remaining count after loop.
// Time Complexity: O(N) where N is the length of the string s. We iterate through the string once.
// Space Complexity: O(1) as we only use a few variables for storage.

class Solution {
public:
    const int M = 1e9+7;

    int numSub(string s) {
        long long result = 0;
        long long count1 = 0;

        for(char ch : s) {
            if (ch == '1') {
                count1++; // Increment count for consecutive 1s
            } else {
                // Current streak of 1s ended, apply formula n*(n+1)/2
                result = (result + count1 * (count1 + 1) / 2) % M;
                count1 = 0; // Reset count for the next group
            }
        }

        // Adding the last group of 1s if string ends with 1
        result = (result + count1 * (count1 + 1) / 2) % M;

        return (int)result;
    }
};

/*
*
* Dry Run: s = "0110"
* 1. i=0, ch='0': else block -> result += 0, count1 = 0.
* 2. i=1, ch='1': if block -> count1 becomes 1.
* 3. i=2, ch='1': if block -> count1 becomes 2.
* 4. i=3, ch='0': else block -> result = (0 + 2*(3)/2) % M = 3. count1 = 0.
* 5. End Loop.
* 6. Final add: result = (3 + 0) % M = 3.
* 7. Return 3.
*
*/
````

### Approach 2: Incremental Counting (Optimized)

```cpp
// Intuition: Instead of waiting for a group to end, add to the result on the fly. The n-th '1' in a sequence adds 'n' new valid substrings.
// Approach: Maintain a running count of consecutive 1s. For each '1', increment count and add current count to result immediately.
// Time Complexity: O(N) - Single pass through the string.
// Space Complexity: O(1) - Only basic integer variables used.

class Solution {
public:
    const int M = 1e9+7;

    int numSub(string s) {
        int result = 0;
        int count1 = 0;

        for(char ch : s) {
            if (ch == '1') {
                count1++; // Extend current sequence of 1s
                // Add current length to result immediately
                // e.g., "11" -> 2nd '1' adds substrings "1" and "11" (count=2)
                result = (result + count1) % M; 
            } else {
                count1 = 0; // Reset sequence counter
            }
        }

        return result;
    }
};

/*
*
* Dry Run: s = "1101"
* 1. i=0, ch='1': count1=1, result = (0 + 1) = 1.
* 2. i=1, ch='1': count1=2, result = (1 + 2) = 3.
* 3. i=2, ch='0': else block -> count1 = 0.
* 4. i=3, ch='1': count1=1, result = (3 + 1) = 4.
* 5. Return 4.
*
*/
```

## ğŸ—ï¸ Key Insights

  - **Pattern Recognition:** The problem reduces to finding the sum of `1 + 2 + ... + n` for every island of ones.
  - **Incremental vs Batch:** Approach 1 calculates the sum at the *end* of a block. Approach 2 calculates the sum *step-by-step*.
      - Mathematically: `1 + 2 + 3` is the same as calculating `n*(n+1)/2` where `n=3`.
  - **Data Types:** In Approach 1, `count1 * (count1 + 1)` can exceed the range of a standard 32-bit integer if the string is long (e.g., 10^5 length), so `long long` is crucial before the modulo. Approach 2 avoids large multiplication by adding smaller numbers incrementally, but modulo is still required at each step to keep `result` within bounds.

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/number-of-substrings-with-only-1s/description/) for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

  - [imnilesh18](https://github.com/imnilesh18)
