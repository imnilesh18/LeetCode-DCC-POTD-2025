# 1437. Check If All 1's Are at Least Length K Places Away

<div align="center">
    <img src="https://img.shields.io/badge/Difficulty-Easy-green?style=for-the-badge" alt="Difficulty: Easy" />
    <img src="https://img.shields.io/badge/Topics-Array-blue?style=for-the-badge" alt="Topics: Array" />
</div>

---

## üîó Problem Link

<p align="center">
    <a href="https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/" target="_blank">
        <img src="https://img.shields.io/badge/LeetCode_Problem-Click_Here-orange?style=for-the-badge&logo=leetcode" alt="LeetCode Problem Link" />
    </a>
</p>

---

## üìù Problem Statement

Given a binary array `nums` and an integer `k`, return `true` if all `1`'s are at least `k` places away from each other, otherwise return `false`.

---

##  constraining Constraints

- `1 <= nums.length <= 105`
- `0 <= k <= nums.length`
- `nums[i]` is `0` or `1`

---

## üìã Examples

<div align="center">

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `nums = [1,0,0,0,1,0,0,1]`, `k = 2` | `true` | Each of the 1s are at least 2 places away from each other. |
| `nums = [1,0,0,1,0,1]`, `k = 2` | `false` | The second 1 and third 1 are only one apart from each other. |

</div>

---

## üß† Approach

The problem requires us to verify that the distance between any two `1`s in the array is at least `k`. The "distance" here refers to the number of `0`s separating them.

We can solve this efficiently with a single pass. The core idea is to keep track of the index of the **last `1`** we've seen.

1.  Initialize a variable, `lastOne`, to store the index of the most recent `1`. We must initialize it carefully. If we set it to `-1`, and the first `1` is at index `0`, our gap calculation might be incorrect. A clever way to start is to set `lastOne = -(k + 1)`. This virtually places the "previous" `1` far enough to the left that the first `1` encountered will always be valid, satisfying the `k` distance requirement.
2.  Iterate through the array from left to right.
3.  If the current element is `0`, we do nothing and continue.
4.  If the current element is `1`:
    * We calculate the distance from the `lastOne`'s index. The number of zeros between the current `1` (at index `i`) and the previous `1` (at index `lastOne`) is `i - lastOne - 1`.
    * We check if this gap is **less than `k`**.
    * If `i - lastOne - 1 < k`, we have found a violation. We can immediately return `false`.
    * If the gap is valid (i.e., `>= k`), we update `lastOne = i` because this is now the most recent `1` we've seen.
5.  If we complete the loop without ever returning `false`, it means all `1`s are spaced correctly, and we can return `true`.

This approach ensures we only check consecutive pairs of `1`s, which is sufficient. If `1_A` and `1_B` are `k` apart, and `1_B` and `1_C` are `k` apart, then `1_A` and `1_C` are guaranteed to be more than `k` apart.

---

## üíª Solution Code

### üê¢ Brute Force Approach (Conceptual)

A brute-force method could involve first iterating through the array to find and store the indices of all `1`s in a separate list. Then, iterate through this new list of indices from the second element, comparing each index `list[i]` with the previous one `list[i-1]`. If `list[i] - list[i-1] - 1 < k` for any pair, return `false`. This is still O(n) time but requires O(m) space, where `m` is the number of `1`s.

The single-pass approach is more efficient as it uses O(1) space.

### üöÄ Optimized Approach (Single Pass)

```cpp
// Intuition:
// We need to ensure that the gap (number of zeros) between any two consecutive '1's is at least 'k'.
// We can iterate through the array, keeping track of the index of the last '1' we encountered.

// Approach:
// 1. Initialize a variable `lastOne` to a value that ensures the first '1' is always valid. 
//    Using `-(k+1)` guarantees that `i - lastOne - 1` will be `>= k` for the first '1'.
//    (e.g., if i=0, k=2, lastOne=-3. Then 0 - (-3) - 1 = 2, which is >= k).
// 2. Iterate through the array `nums` with index `i`.
// 3. If `nums[i]` is `0`, continue to the next iteration.
// 4. If `nums[i]` is `1`:
//    a. Calculate the number of zeros between this '1' and the `lastOne`: `gap = i - lastOne - 1`.
//    b. If `gap < k`, it means the condition is violated, so return `false`.
//    c. If the gap is valid, update `lastOne = i` to this new '1's index.
// 5. If the loop finishes without returning `false`, all '1's are validly spaced. Return `true`.

// Time Complexity: O(n), where n is the length of the `nums` array. We do a single pass through the array.
// Space Complexity: O(1), as we only use a few extra variables (`n`, `lastOne`, `i`).
class Solution {
public:
    bool kLengthApart(vector<int>& nums, int k) {
        int n = nums.size(); // Get the size of the array
        
        // Initialize lastOne to a "safe" negative index.
        // `-(k+1)` ensures the first '1' found will always pass the check.
        // For example, if k=2, lastOne=-3. If first 1 is at i=0, (0 - (-3) - 1) = 2, which is >= k.
        int lastOne = -(k + 1);

        for (int i = 0; i < n; i++) {
            if (nums[i] == 1) { // We found a '1'
                // Calculate the gap (number of zeros) between this '1' and the last '1'
                if (i - lastOne - 1 < k) {
                    // If the gap is less than k, the condition is violated
                    return false;
                }
                
                // This '1' is validly spaced, update lastOne to the current index
                lastOne = i;
            }
        }

        // If we went through the whole array without returning false, it's valid
        return true;
    }
};

/*
*
* Dry Run
*
* Example 1: nums = [1,0,0,0,1,0,0,1], k = 2
*
* 1. Initialize n = 8, lastOne = -(2+1) = -3
* 2. Loop i = 0:
* - nums[0] == 1.
* - Check gap: i - lastOne - 1 = 0 - (-3) - 1 = 2.
* - Is 2 < k (i.e., 2 < 2)? No.
* - Update lastOne = 0.
* 3. Loop i = 1: nums[1] == 0. Continue.
* 4. Loop i = 2: nums[2] == 0. Continue.
* 5. Loop i = 3: nums[3] == 0. Continue.
* 6. Loop i = 4:
* - nums[4] == 1.
* - Check gap: i - lastOne - 1 = 4 - 0 - 1 = 3.
* - Is 3 < k (i.e., 3 < 2)? No.
* - Update lastOne = 4.
* 7. Loop i = 5: nums[5] == 0. Continue.
* 8. Loop i = 6: nums[6] == 0. Continue.
* 9. Loop i = 7:
* - nums[7] == 1.
* - Check gap: i - lastOne - 1 = 7 - 4 - 1 = 2.
* - Is 2 < k (i.e., 2 < 2)? No.
* - Update lastOne = 7.
* 10. Loop ends.
* 11. Return true.
*
* Example 2: nums = [1,0,0,1,0,1], k = 2
*
* 1. Initialize n = 6, lastOne = -(2+1) = -3
* 2. Loop i = 0:
* - nums[0] == 1.
* - Check gap: i - lastOne - 1 = 0 - (-3) - 1 = 2.
* - Is 2 < k (i.e., 2 < 2)? No.
* - Update lastOne = 0.
* 3. Loop i = 1: nums[1] == 0. Continue.
* 4. Loop i = 2: nums[2] == 0. Continue.
* 5. Loop i = 3:
* - nums[3] == 1.
* - Check gap: i - lastOne - 1 = 3 - 0 - 1 = 2.
* - Is 2 < k (i.e., 2 < 2)? No.
* - Update lastOne = 3.
* 6. Loop i = 4: nums[4] == 0. Continue.
* 7. Loop i = 5:
* - nums[5] == 1.
* - Check gap: i - lastOne - 1 = 5 - 3 - 1 = 1.
* - Is 1 < k (i.e., 1 < 2)? Yes.
* - Return false.
*
*/
```

---

## üí° Key Insights

-   **Edge Case Handling:** The initialization of `lastOne` to `-(k+1)` is the most crucial part. It elegantly handles the first `1` found in the array, regardless of its position (even at index 0), without needing a separate flag or conditional check.
-   **Gap Calculation:** The formula `current_index - last_index - 1` correctly gives the count of elements *between* the two indices.
-   **Greedy Check:** This is a greedy approach. We only care about the gap between the *current* `1` and the *most recent* `1`. If that gap is valid, we "greedily" move our `lastOne` pointer forward.

---

## üßê Further Exploration

-   What if the array wasn't binary? How would you find if all occurrences of a specific number `x` are `k` places apart? (The logic would be identical, just checking for `nums[i] == x`).
-   What if you had to return the *minimum* `k` for which the array would be `true`? You could find all gaps between `1`s and return the minimum gap.

---

## üìö References

-   [LeetCode Problem Discussion](https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/discuss/)
-   [Single Pass Traversal Technique](https://en.wikipedia.org/wiki/One-pass_algorithm)

---

## üè∑Ô∏è Tags

`Array`, `Single Pass`, `Greedy`

---

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/) for original content and copyright.**

---

## üë®üíª Author

-   [imnilesh18](https://github.com/imnilesh18)