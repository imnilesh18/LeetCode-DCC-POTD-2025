# 717. 1-bit and 2-bit Characters

<p align="center">
  <a href="https://leetcode.com/problems/1-bit-and-2-bit-characters/description/">
    <img src="https://img.shields.io/badge/LeetCode-717-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode Problem">
  </a>
  <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge" alt="Difficulty Easy">
  <img src="https://img.shields.io/badge/Language-C++-00599C?style=for-the-badge&logo=c%2B%2B&logoColor=white" alt="Language C++">
</p>

## â“ Problem Statement

We have two special characters:
1. The first character can be represented by one bit `0`.
2. The second character can be represented by two bits (`10` or `11`).

Given a binary array `bits` that ends with `0`, return `true` if the last character must be a one-bit character.

## ğŸ§± Constraints

- `1 <= bits.length <= 1000`
- `bits[i]` is either `0` or `1`.

## ğŸ”¢ Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :--- | :--- |
| **1** | `bits = [1,0,0]` | `true` | The only way to decode it is two-bit character `10` and one-bit character `0`. So the last character is a one-bit character. |
| **2** | `bits = [1,1,1,0]` | `false` | The only way to decode it is two-bit character `11` and two-bit character `10`. So the last character is NOT a one-bit character. |

---

## ğŸ’¡ Approach 1: Linear Scan (Left to Right)

### Intuition
We traverse the array from the beginning. The key observation is that if we encounter a `1`, it **must** be the start of a 2-bit character (either `10` or `11`). Therefore, we must consume the current bit and the next bit together. If we encounter a `0`, it is a 1-bit character.

### Algorithm
1. Initialize a pointer `i` at `0`.
2. Iterate while `i` is less than `n-1` (we want to stop before or exactly at the last character).
3. If `bits[i] == 1`, jump 2 steps (`i += 2`) because the next bit is part of this character.
4. If `bits[i] == 0`, jump 1 step (`i += 1`).
5. After the loop, check if `i` is equal to `n-1`. If yes, it means the last iteration landed exactly on the last zero, making it a 1-bit character.

### ğŸ’» Solution Code

```cpp
// Intuition: Iterate from start. If current bit is 1, it consumes the next bit (jump 2). If 0, jump 1.
// Approach: Use a while loop to traverse. Increment index by 2 if bit is 1, else by 1. Check if we land on the last index.
// Time Complexity: O(n) - Single pass through the array.
// Space Complexity: O(1) - No extra space used.
class Solution {
public:
    bool isOneBitCharacter(vector<int>& bits) {
        int n = bits.size();
        int i = 0;

        // Iterate through the array, stopping before the last element if possible
        while(i < n-1) {
            // If current bit is 1, skip the next bit (move 2 steps)
            // Otherwise, move 1 step
            i += (bits[i] == 1) ? 2 : 1;
        }

        // If we land exactly on the last index, it's a valid 1-bit character
        return i == n-1;
    }
};

/*
*
* Dry Run
* Input: bits = [1, 0, 0]
* n = 3, i = 0
*
* Iteration 1:
* bits[0] is 1.
* i increments by 2. i = 2.
*
* Loop check: i (2) < n-1 (2) is False. Loop terminates.
*
* Return: i == n-1 (2 == 2) -> true.
*/
```

---

## ğŸ’¡ Approach 2: Parity Check (Right to Left)

### Intuition
The problem states the array always ends with `0`. We only need to determine if this last `0` is the tail of a 2-bit character (like `...10`) or a standalone 1-bit character.
This depends entirely on the sequence of `1`s immediately preceding the final `0`.
- If there is an **odd** sequence of continuous `1`s before the last `0` (e.g., `...01110`), the last `1` must pair with the final `0`, making it a 2-bit character.
- If there is an **even** sequence of continuous `1`s (e.g., `...0110`), the `1`s pair with each other, leaving the final `0` alone.

### Algorithm
1. Start from the second to last element (`n-2`) and iterate backwards.
2. Count the continuous streak of `1`s. Stop immediately when a `0` is encountered.
3. If the count of `1`s is even, the answer is `true`. If odd, `false`.

### ğŸ’» Solution Code

```cpp
// Intuition: The last bit is always 0. Its status depends on the parity of the continuous sequence of 1s before it.
// Approach: Count consecutive 1s starting from n-2 backwards. Even count means 1s pair up, leaving last 0 alone (True).
// Time Complexity: O(n) - Worst case traverses the streak of 1s.
// Space Complexity: O(1) - Constant extra space.
class Solution {
public:
    bool isOneBitCharacter(vector<int>& bits) {
        int n = bits.size();
        
        int count1 = 0;

        // Count continuous 1s backwards from second to last element
        // Stop as soon as we hit a 0 or reach the beginning
        for(int i = n-2; i >= 0 && bits[i] == 1; i--) {
            count1++;
        }

        // Even 1s => pairs complete => last 0 is separate (True)
        // Odd 1s => last 1 pairs with final 0 => False
        return count1%2 == 0 ? true : false;
    }
};

/*
*
* Dry Run
* Input: bits = [1, 1, 1, 0]
* n = 4
*
* Loop starts at i = 2 (value 1):
* bits[2] == 1 -> count1 = 1, i becomes 1
* bits[1] == 1 -> count1 = 2, i becomes 0
* bits[0] == 1 -> count1 = 3, i becomes -1
* Loop ends.
*
* Return: count1 (3) % 2 == 0 -> false.
*/
```

---

## ğŸ§  Key Insights

- **Determinism:** A `1` always dictates the fate of the next bit (they must be a pair). A `0` has no effect on future bits.
- **Sufficiency of Tail:** We effectively only care about the "tail" of `1`s before the final zero. Any `0` appearing before this tail acts as a "reset" or barrier, ensuring all previous characters are fully resolved.
- **Optimization:** While both solutions are $O(N)$, Approach 2 is often faster in practice for cases with mixed 0s and 1s because it only scans the suffix, whereas Approach 1 always scans the entire array.

---

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/1-bit-and-2-bit-characters/description/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)