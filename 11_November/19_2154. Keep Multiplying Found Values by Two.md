# 2154. Keep Multiplying Found Values by Two

<p align="center">
  <a href="https://leetcode.com/problems/keep-multiplying-found-values-by-two/?">
    <img src="https://img.shields.io/badge/LeetCode-2154-FFA116?style=for-the-badge&logo=leetcode&logoColor=white" alt="LeetCode Problem">
  </a>
  <br>
  <span style="font-size: 1.2em; font-weight: bold; color: #00b8a3;">Difficulty: Easy</span>
</p>

## ğŸŒŸ Problem Statement

You are given an array of integers `nums`. You are also given an integer `original` which is the first number that needs to be searched for in `nums`.

You then do the following steps:

1.  If `original` is found in `nums`, **multiply** it by two (i.e., set `original = 2 * original`).
2.  Otherwise, **stop** the process.
3.  **Repeat** this process with the new number as long as you keep finding the number.

Return the **final** value of `original`.

---

## ğŸ¯ Examples

### Example 1
| Input | Output | Explanation |
|:--- |:---:|:---|
| `nums = [5,3,6,1,12]`<br>`original = 3` | **24** | â€¢ `3` is found in `nums`. Multiply by 2 to get `6`.<br>â€¢ `6` is found in `nums`. Multiply by 2 to get `12`.<br>â€¢ `12` is found in `nums`. Multiply by 2 to get `24`.<br>â€¢ `24` is not found. Return `24`. |

### Example 2
| Input | Output | Explanation |
|:--- |:---:|:---|
| `nums = [2,7,9]`<br>`original = 4` | **4** | â€¢ `4` is not found in `nums`.<br>â€¢ Return `4`. |

---

## ğŸ›‘ Constraints

- `1 <= nums.length <= 1000`
- `1 <= nums[i], original <= 1000`

---

## ğŸ’¡ Approach

To solve this efficiently, we need fast lookups to check if the current `original` value exists in the `nums` array.

1.  **Data Structure**: Since the constraints tell us that the numbers are between 1 and 1000, we can use a simple fixed-size array (frequency map) of size 1001 to act as a hash set. This allows for $O(1)$ lookups.
2.  **Preprocessing**: Iterate through `nums` and mark the presence of each number in our frequency array.
3.  **Simulation**:
    * Check if `original` exists in our array.
    * The constraints limit the values to 1000 for input, but `original` can grow larger. However, we only need to lookup values that *could* exist in `nums`, so if `original` exceeds 1000, it definitely isn't in `nums`.
    * While `original <= 1000` and it exists in our map, double it.
4.  **Result**: Return the final value of `original`.

---

## ğŸ’» Solution Code

```cpp
// Intuition: Use a frequency array (hash map) for O(1) lookups since the number range is small (1-1000).
// Approach: Mark presence of all numbers in nums. Repeatedly check if 'original' exists and double it.
// Time Complexity: O(N + K) where N is nums.length and K is the number of doubling steps (very small given range 1000).
// Space Complexity: O(M) where M is the range of numbers (1001) for the frequency array.

class Solution {
public:
    int findFinalValue(vector<int>& nums, int original) {
        // Create a frequency array for numbers 1 to 1000
        int arr[1001] = {0};

        // Populate the frequency array to mark existence of numbers
        for(int &num : nums) {
            arr[num]++;
        }

        // Loop while original is within bounds and exists in the array
        while(original <= 1000 && arr[original] != 0) {
            original *= 2; // Double the value
        }

        return original; // Return the final not-found value
    }
};

/*
*
* Dry Run
* Input: nums = [5, 3, 6, 1, 12], original = 3
* * 1. Initialize arr[1001] with 0s.
* 2. Fill arr: arr[5]=1, arr[3]=1, arr[6]=1, arr[1]=1, arr[12]=1.
* 3. While Loop Check 1:
* - Is 3 <= 1000? Yes.
* - Is arr[3] != 0? Yes (It's 1).
* - original = 3 * 2 = 6.
* 4. While Loop Check 2:
* - Is 6 <= 1000? Yes.
* - Is arr[6] != 0? Yes.
* - original = 6 * 2 = 12.
* 5. While Loop Check 3:
* - Is 12 <= 1000? Yes.
* - Is arr[12] != 0? Yes.
* - original = 12 * 2 = 24.
* 6. While Loop Check 4:
* - Is 24 <= 1000? Yes.
* - Is arr[24] != 0? No (It's 0).
* - Loop terminates.
* 7. Return original (24).
*
*/
````

-----

## ğŸ”‘ Key Insights

  - **Constraint Analysis**: The maximum value in `nums` is 1000. This suggests that an array-based lookup (`int arr[1001]`) is more efficient and simpler than a generic `unordered_set` or `map`.
  - **Loop Termination**: We strictly need to check `original <= 1000` in the `while` loop. If `original` becomes `2000`, we don't need to check the array because it's out of the possible range of input numbers, saving potential out-of-bounds errors.
  - **Efficiency**: This approach avoids sorting ($O(N \log N)$) and provides a near-linear time complexity relative to the array size.

-----

## ğŸ”— References

  - [LeetCode Problem Link](https://www.google.com/search?q=https://leetcode.com/problems/keep-multiplying-found-values-by-two/%3F)
  - [C++ Vector Reference](https://en.cppreference.com/w/cpp/container/vector)
  - [Hash Table Concepts](https://en.wikipedia.org/wiki/Hash_table)

-----

## ğŸ·ï¸ Tags

`Array` `Hash Table` `Simulation` `C++` `Easy`

-----

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://www.google.com/search?q=https://leetcode.com/problems/keep-multiplying-found-values-by-two/%3F) for original content and copyright.**

-----

## ğŸ‘¨â€ğŸ’» Author

  - [imnilesh18](https://github.com/imnilesh18)
