# 1930. Unique Length-3 Palindromic Subsequences

---

## üîó Problem Link

[LeetCode - Unique Length-3 Palindromic Subsequences](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/)

## ‚ÑπÔ∏è Problem Info

| Attribute      | Details                              |
| :------------- | :----------------------------------- |
| **Difficulty** | üü° Medium                            |
| **Tags**       | `Hash Table`, `String`, `Prefix Sum` |
| **Language**   | C++                                  |

---

## ‚ùì Problem Statement

Given a string `s`, return the number of **unique palindromes of length three** that are a **subsequence** of `s`.

Note that even if there are multiple ways to obtain the same subsequence, it is still only counted **once**.

A **palindrome** is a string that reads the same forwards and backwards.

A **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.

For example, `"ace"` is a subsequence of `"abcde"`.

---

## üéØ Constraints

- `3 <= s.length <= 10^5`
- `s` consists of only lowercase English letters.

---

## üìù Examples

### Example 1

```text
Input: s = "aabca"
Output: 3
Explanation: The 3 palindromic subsequences of length 3 are:
- "aba" (subsequence of "aabca")
- "aaa" (subsequence of "aabca")
- "aca" (subsequence of "aabca")
```

### Example 2

```text
Input: s = "adc"
Output: 0
Explanation: There are no palindromic subsequences of length 3 in "adc".
```

### Example 3

```text
Input: s = "bbcbaba"
Output: 4
Explanation: The 4 palindromic subsequences of length 3 are:
- "bbb" (subsequence of "bbcbaba")
- "bcb" (subsequence of "bbcbaba")
- "bab" (subsequence of "bbcbaba")
- "aba" (subsequence of "bbcbaba")
```

---

## üí° Explanation

### Core Intuition

A palindrome of length 3 follows the pattern `XYX`, where the first and last characters are the same (`X`), and the middle character (`Y`) can be anything. To find all unique length-3 palindromes, we simply need to fix the outer character `X` and count how many unique characters exist between the first and last occurrence of `X` in the string `s`.

### Approach

1.  **Identify Unique Characters:** First, determine which characters actually exist in the string `s`.
2.  **Find Boundaries:** For each unique character found:
    - Locate its **first** occurrence (leftmost index).
    - Locate its **last** occurrence (rightmost index).
3.  **Count Middle Elements:** If the first and last indices are different (meaning there is space between them), iterate through the substring between these indices. Use a Set to count the number of unique characters present in this range.
4.  **Sum Up:** The size of the Set for a specific character `X` represents the number of unique palindromes starting and ending with `X`. Add this count to the total result.

This method ensures we count unique subsequences because we iterate over unique outer characters and count unique inner characters for each.

---

## üíª Solution Code

### üü¢ Approach 1: Iterative Boundary Search

This approach iterates through the string to find unique characters first, then re-scans to find boundaries for each unique character.

```cpp
// Intuition: A length-3 palindrome is defined by its outer characters (must be same) and the inner character. We find unique outer chars, determine their widest range, and count unique inner chars.
// Approach: Collect unique chars in 's'. For each, find first/last index. Insert chars between indices into a Set. Add Set size to result.
// Time Complexity: O(N) - Technically O(26*N), as we iterate N for finding boundaries for at most 26 chars.
// Space Complexity: O(1) - We store at most 26 characters in the sets.

class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int n = s.length();

        // Identify all unique characters present in the string
        unordered_set<char> letters;
        for(int i = 0; i < n; i++) {
            letters.insert(s[i]);
        }

        int result = 0;

        // Process each unique character as a potential outer wrapper (X_X)
        for(char letter : letters) {

            int left_idx = - 1;
            int right_idx = - 1;

            // Find the first and last occurrence of the current 'letter'
            for(int i = 0; i < n; i++) {
                if(s[i] == letter) {
                    if(left_idx == - 1) {
                        left_idx = i; // Mark first occurrence
                    }

                    right_idx = i; // Continuously update for last occurrence
                }
            }

            // Collect unique characters strictly between left and right indices
            unordered_set<char> st;
            for(int middle = left_idx + 1; middle <= right_idx - 1; middle++) {
                st.insert(s[middle]);
            }

            // The size of the set represents unique palindromes like "letter + middle + letter"
            result += st.size();
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: s = "aabca"
* * 1. Unique letters found: {'a', 'b', 'c'}
* * 2. Loop letter 'a':
* - left_idx = 0, right_idx = 4 (indices in "aabca")
* - Loop middle (1 to 3): s[1]='a', s[2]='b', s[3]='c'
* - Set st = {'a', 'b', 'c'} -> Size 3. Result = 3.
* * 3. Loop letter 'b':
* - left_idx = 2, right_idx = 2.
* - Loop middle (3 to 1): Does not run.
* - Set st = {}. Result = 3 + 0 = 3.
* * 4. Loop letter 'c':
* - left_idx = 3, right_idx = 3.
* - Loop middle (4 to 2): Does not run.
* - Set st = {}. Result = 3 + 0 = 3.
* * Final Output: 3 ("aaa", "aba", "aca")
*
*/
```

### üöÄ Approach 2: Precomputed Indices (Optimized)

This approach optimizes the boundary search by pre-calculating the first and last indices of all characters in a single pass.

```cpp
// Intuition: Instead of searching for indices repeatedly, we can record the first and last position of every character (a-z) in one pass, reducing redundant scanning.
// Approach: Use a vector of pairs to store {first, last} indices for 'a'-'z'. Fill in one pass. Iterate 0-25, if valid range exists, count unique chars between them.
// Time Complexity: O(N) - One pass to fill indices, then checking ranges takes O(26*N) worst case, effectively linear.
// Space Complexity: O(1) - Fixed size vector of 26.

class Solution {
public:
    int countPalindromicSubsequence(string s) {
        int n = s.length();

        // Store {first_index, last_index} for all 26 characters
        vector<pair<int, int>> indices(26, {-1, -1});

        for(int i = 0; i < n; i++) {

            char ch = s[i];
            int idx = ch - 'a';

            // If first occurrence not recorded, record it
            if(indices[idx].first == - 1) {
                indices[idx].first = i;
            }

            // Always update second to keep track of the latest occurrence
            indices[idx].second = i;
        }

        int result = 0;

        // Iterate through all 26 possible lowercase English letters
        for(int i = 0; i < 26; i++) {

            int left_idx = indices[i].first;
            int right_idx = indices[i].second;

            // If character didn't appear or appeared only once (no space in between)
            if(left_idx == -1) {
                continue;
            }

            // Count unique characters between the first and last occurrence
            unordered_set<char> st;
            for(int middle = left_idx + 1; middle <= right_idx - 1; middle++) {
                st.insert(s[middle]);
            }

            result += st.size();
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: s = "bbcbaba"
* * 1. Precompute Indices:
* 'a': first=4, last=6 ("...aba")
* 'b': first=0, last=5 ("bbcbab...")
* 'c': first=2, last=2 ("..c..")
* others: {-1, -1}
* * 2. Check 'a' (indices 4, 6):
* - Range s[5] is 'b'. Set={'b'}. Size=1. Result=1 ("aba").
* * 3. Check 'b' (indices 0, 5):
* - Range s[1..4]: "bcba". Unique={'b','c','a'}. Size=3. Result=1+3=4 ("bbb", "bcb", "bab").
* * 4. Check 'c' (indices 2, 2):
* - Range invalid (start > end). Size=0. Result=4.
* * Final Output: 4
*
*/
```

---

## üîë Key Insights

1.  **Structure of Palindrome:** A length-3 palindrome depends entirely on the first and last character being identical. The middle character creates the uniqueness.
2.  **Search Space:** Since the input only contains lowercase English letters, iterating 26 times is extremely efficient (constant time overhead).
3.  **Avoid Duplicates:** By fixing the outer letters (first occurrence and last occurrence) and storing middle characters in a `Set`, we automatically handle the "unique" constraint without needing complex logic to filter duplicates.

---

## üñáÔ∏è References

- [LeetCode Discussion - Official Solution](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/solution/)
- [GeeksforGeeks - Palindromic Subsequences](https://www.geeksforgeeks.org/count-palindromic-subsequence-given-string/)

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/) for original content and copyright.**
