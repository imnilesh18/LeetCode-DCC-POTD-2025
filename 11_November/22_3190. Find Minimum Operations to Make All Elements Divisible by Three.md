# 3190. Find Minimum Operations to Make All Elements Divisible by Three

<div align="center">

<img src="https://img.shields.io/badge/Level-Easy-green.svg?style=for-the-badge&logo=leetcode" alt="Level Easy" />

<img src="https://img.shields.io/badge/Language-C++-blue.svg?style=for-the-badge&logo=cplusplus" alt="Language C++" />

</div>

---

## ğŸ”— Problem Link

> [**View on LeetCode**](https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/description)

## ğŸ“ Problem Statement

You are given an integer array `nums`. In one operation, you can add or subtract 1 from **any** element of `nums`.

Return the **minimum** number of operations to make all elements of `nums` divisible by 3.

## ğŸ§© Constraints

- `1 <= nums.length <= 50`
- `1 <= nums[i] <= 50`

## ğŸ§ª Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :---: | :--- |
| **1** | `nums = [1,2,3,4]` | `3` | All array elements can be made divisible by 3 using 3 operations:<br>1. Subtract 1 from 1 (1 -> 0)<br>2. Add 1 to 2 (2 -> 3)<br>3. Subtract 1 from 4 (4 -> 3) |
| **2** | `nums = [3,6,9]` | `0` | All elements are already divisible by 3. |

## ğŸ’¡ Explanation

The core task is to determine how many "adjustments" are needed so that every number in the list becomes a multiple of 3.

For any integer `x`, when we calculate `x % 3` (the remainder when divided by 3), there are three possibilities:
1.  **Remainder is 0**: The number is already divisible by 3. **0 operations** needed.
2.  **Remainder is 1**: The number is of the form $3k + 1$. Subtracting 1 makes it $3k$, which is divisible by 3. **1 operation** needed.
3.  **Remainder is 2**: The number is of the form $3k + 2$. Adding 1 makes it $3k + 3$, which is divisible by 3. **1 operation** needed.

Thus, for any number not already divisible by 3, exactly **one** operation is sufficient to fix it. We iterate through the array and count how many numbers have a non-zero remainder.

---

## ğŸ’» Solution Code

```cpp
// Intuition: A number is divisible by 3 if its remainder modulo 3 is 0. If the remainder is 1 or 2, exactly one operation (+1 or -1) is sufficient to reach the nearest multiple of 3.
// Approach: Iterate through the array. For each number, check if nums[i] % 3 is non-zero. If it is, increment the operation count.
// Time Complexity: O(N) where N is the size of the input array, as we iterate through the array once.
// Space Complexity: O(1) as we essentially use only a single variable for counting.

class Solution {
public:
    int minimumOperations(vector<int>& nums) {
        int ans = 0; // Initialize counter for operations
        for (auto x : nums) 
            // If x is not divisible by 3 (remainder 1 or 2), add 1 to answer
            ans += (x % 3 != 0);
        return ans; // Return total minimum operations
    }
};

/*
*
* Dry Run
* Input: nums = [1, 2, 3, 4]
*
* Initialization:
* ans = 0
*
* Loop Execution:
* 1. Element x = 1
* 1 % 3 is 1 (not 0)
* ans += 1 => ans = 1
*
* 2. Element x = 2
* 2 % 3 is 2 (not 0)
* ans += 1 => ans = 2
*
* 3. Element x = 3
* 3 % 3 is 0
* ans += 0 => ans = 2
*
* 4. Element x = 4
* 4 % 3 is 1 (not 0)
* ans += 1 => ans = 3
*
* Final Result: return 3
*
*/
```

## ğŸ” Key Insights

- **Modular Arithmetic**: The property `x % 3` immediately tells us the "distance" to a multiple of 3.
- **Uniform Cost**: Whether the remainder is 1 or 2, the cost to fix it is always 1 step.
- **Simplicity**: The constraints are small ($N \le 50$), but this $O(N)$ approach scales perfectly to much larger inputs.

## ğŸ·ï¸ Tags

- `Array`
- `Math`
- `Greedy`

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/description) for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)