# 1590. Make Sum Divisible by P


## ğŸ”— Problem Link

[**LeetCode: Make Sum Divisible by P**](https://leetcode.com/problems/make-sum-divisible-by-p/)

## â„¹ï¸ Problem Name

**1590. Make Sum Divisible by P**

## ğŸ·ï¸ Difficulty

![Medium](https://img.shields.io/badge/Difficulty-Medium-yellow)

## ğŸ”– Tags

`Array` `Hash Table` `Prefix Sum`

## ğŸ“„ Problem Statement

Given an array of positive integers `nums`, remove the **smallest subarray** (possibly empty) such that the **sum** of the remaining elements is divisible by `p`. It is **not** allowed to remove the whole array.

Return *the length of the smallest subarray that you need to remove, or `-1` if it's impossible*.

A **subarray** is defined as a contiguous block of elements in the array.

## ğŸ§ Examples

### Example 1:
**Input:** `nums = [3,1,4,2], p = 6`  
**Output:** `1`  
**Explanation:** The sum of the elements in nums is 10, which is not divisible by 6. We can remove the subarray `[4]`, and the sum of the remaining elements is 6, which is divisible by 6.

### Example 2:
**Input:** `nums = [6,3,5,2], p = 9`  
**Output:** `2`  
**Explanation:** We cannot remove a single element to get a sum divisible by 9. The best way is to remove the subarray `[5,2]`, leaving us with `[6,3]` with sum 9.

### Example 3:
**Input:** `nums = [1,2,3], p = 3`  
**Output:** `0`  
**Explanation:** Here the sum is 6, which is already divisible by 3. Thus we do not need to remove anything.

## â›“ï¸ Constraints

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^9`
- `1 <= p <= 10^9`

## ğŸ’¡ Approach & Explanation

The core of this problem lies in modular arithmetic and prefix sums. 

1.  **Identify the Target**: First, calculate the total sum of the array. If `TotalSum % p == 0`, we don't need to remove anything (return 0). If not, let `target = TotalSum % p`. Our goal is to find the smallest subarray whose sum has a remainder of `target` when divided by `p`. Removing such a subarray will make the remaining sum divisible by `p`.

2.  **Prefix Sum Technique**: We can compute the prefix sum as we iterate through the array. For any subarray ending at index `j` and starting at index `i`, its sum can be derived from the difference of prefix sums: `Sum(i, j) = PrefixSum[j] - PrefixSum[i-1]`.

3.  **Modular Equation**: We need a subarray ending at `j` (current index) such that:
    `(CurrentPrefixSum - PreviousPrefixSum) % p == target`
    
    Rearranging this equation to find the required `PreviousPrefixSum`:
    `PreviousPrefixSum % p = (CurrentPrefixSum - target + p) % p`
    *(We add `p` before taking modulo to handle negative results).*

4.  **HashMap for Tracking**: We use a Hash Map (or Unordered Map in C++) to store the most recent index where a specific `PrefixSum % p` occurred. 
    -   **Key**: `PrefixSum % p`
    -   **Value**: Index `j`
    
    As we iterate, we calculate the `needed` previous prefix modulo. If it exists in our map, it means there is a subarray ending at `j` with the required remainder. We calculate its length and update the minimum length found so far.

5.  **Edge Cases**:
    -   Initialize the map with `{0: -1}` to handle cases where the valid subarray starts from index 0.
    -   If the smallest subarray length found is equal to the array size `n`, it means we would remove the whole array, which is not allowed. Return `-1`.

## ğŸ› ï¸ Solution Code

```cpp
// Intuition: The problem asks to remove a subarray with sum % p == TotalSum % p. Using prefix sums and a hash map allows us to find such subarrays in O(N) time.
// Approach: Calculate total remainder (target). Iterate calculating prefix sum modulo p. Look for (current - target) % p in the map to find the shortest removal length.
// Time Complexity: O(N) where N is the number of elements in nums, as we iterate once.
// Space Complexity: O(N) worst case to store the hash map entries.

class Solution {
public:
    int minSubarray(vector<int>& nums, int p) {
        int n = nums.size();
        int SUM = 0;

        // Calculate total sum modulo p directly to avoid overflow
        for(int &num : nums) {
            SUM = (SUM + num) % p;
        }

        int target = SUM % p;
        
        // If total sum is already divisible, no removal needed
        if(target == 0) {
            return 0;
        }

        unordered_map<int, int> mp;

        int curr = 0;

        // Handle case where subarray starts from index 0
        mp[0] = -1;
        int result = n;

        for(int j = 0; j < n; j++) {
            // Update current prefix sum modulo p
            curr = (curr + nums[j]) % p;

            // Calculate the remainder we need to find in the map
            // Adding p handles negative results from subtraction
            int remain = (curr - target + p) % p;

            // If we found a matching prefix sum remainder
            if(mp.find(remain) != mp.end()) {
                // Update result with the smaller length
                result = min(result, j - mp[remain]);
            }

            // Store current prefix sum remainder and index
            mp[curr] = j;
        }
        
        // If result is n, we can't remove the whole array, so return -1
        return result == n ? -1 : result;
    }
};

/*
*
* Dry Run
* Input: nums = [3, 1, 4, 2], p = 6
* n = 4
* Total SUM calculation: (3+1+4+2) % 6 = 10 % 6 = 4
* target = 4. We need to remove a subarray with sum % 6 == 4.
* mp = {0: -1}, curr = 0, result = 4
*
* Iteration j = 0 (num = 3):
* curr = (0 + 3) % 6 = 3
* remain = (3 - 4 + 6) % 6 = 5
* 5 not in mp.
* mp updates: {0: -1, 3: 0}
*
* Iteration j = 1 (num = 1):
* curr = (3 + 1) % 6 = 4
* remain = (4 - 4 + 6) % 6 = 0
* 0 found in mp at index -1.
* Length = j - mp[0] = 1 - (-1) = 2. Subarray is [3, 1] (Sum 4).
* result = min(4, 2) = 2.
* mp updates: {..., 4: 1}
*
* Iteration j = 2 (num = 4):
* curr = (4 + 4) % 6 = 8 % 6 = 2
* remain = (2 - 4 + 6) % 6 = 4
* 4 found in mp at index 1.
* Length = j - mp[4] = 2 - 1 = 1. Subarray is [4] (Sum 4).
* result = min(2, 1) = 1.
* mp updates: {..., 2: 2}
*
* Iteration j = 3 (num = 2):
* curr = (2 + 2) % 6 = 4
* remain = (4 - 4 + 6) % 6 = 0
* 0 found in mp at index -1.
* Length = 3 - (-1) = 4.
* result = min(1, 4) = 1.
* mp updates: {..., 4: 3}
*
* End Loop. result is 1. Return 1.
*/
````

## ğŸ—ï¸ Key Insights

  - **Modulo Properties**: The identity `(a + b) % p = ((a % p) + (b % p)) % p` is crucial to prevent integer overflow when calculating sums of potentially large numbers.
  - **Equation Transformation**: The standard subarray sum problem asks for `Sum[i...j] = K`. In modular arithmetic, this becomes `(Prefix[j] - Prefix[i-1]) % p = target`.
  - **Negative Modulo Handling**: In C++, the `%` operator can yield negative values for negative operands. Adding `p` before taking the modulo `(a - b + p) % p` ensures the result is always positive and within `[0, p-1]`.
  - **Hash Map Strategy**: Storing indices allows us to calculate the length of the subarray immediately upon finding a valid prefix match.

## ğŸ““ Notes

  - If the total sum of the array is already divisible by `p`, the target is 0, and the answer is 0.
  - The constraint `1 <= nums.length <= 10^5` suggests an `O(N)` or `O(N log N)` solution is required. This hash map approach is `O(N)`.
  - The values in `nums` can be up to `10^9`, so a simple sum would overflow a standard integer, necessitating the use of `long long` or modular arithmetic at each step.

## ğŸš€ Further Exploration

  - **Similar Problems**:
      - [560. Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k/)
      - [974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/)
  - Try solving this without using a Hash Map if the constraints were smaller (e.g., `N <= 1000`).
  - Consider how the solution changes if we were allowed to remove multiple disjoint subarrays.

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/make-sum-divisible-by-p/) for original content and copyright.**

## ğŸ‘¨â€ğŸ’» Author

  - [imnilesh18](https://github.com/imnilesh18)
