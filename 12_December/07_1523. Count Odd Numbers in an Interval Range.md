# 1523. Count Odd Numbers in an Interval Range

<p align="center">
  <a href="https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/">
    <img src="https://img.shields.io/badge/LeetCode-Problem%20Link-FFA116?style=for-the-badge&logo=leetcode" alt="LeetCode"/>
  </a>
  <br>
  <img src="https://img.shields.io/badge/Difficulty-Easy-brightgreen?style=for-the-badge" alt="Difficulty Easy"/>
  <img src="https://img.shields.io/badge/Tags-Math-blue?style=for-the-badge" alt="Tags Math"/>
</p>

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/) for original content and copyright.**

---

## üí° Problem Statement

Given two non-negative integers `low` and `high`. Return the count of odd numbers between `low` and `high` (inclusive).

### üî¢ Examples

| Example | Input | Output | Explanation |
| :---: | :--- | :---: | :--- |
| **1** | `low = 3`, `high = 7` | `3` | The odd numbers between 3 and 7 are [3, 5, 7]. |
| **2** | `low = 8`, `high = 10` | `1` | The odd numbers between 8 and 10 are [9]. |

### üõë Constraints

- `0 <= low <= high <= 10^9`

---

## üß† Key Insights & Approaches

This problem can be solved in multiple ways, ranging from a naive iteration to an optimized mathematical formula.

### 1Ô∏è‚É£ Approach 1: Brute Force (Iterative)
The simplest way is to iterate from `low` to `high` and check if each number is odd.
- **Drawback**: Since the range can be up to $10^9$, this approach will likely result in a **Time Limit Exceeded (TLE)** error.

### 2Ô∏è‚É£ Approach 2: Mathematical Adjustment
Odd and even numbers alternate. In any range, roughly half the numbers are odd.
- If `low` is even, increment it to make it the first odd number.
- If `high` is even, decrement it to make it the last odd number.
- The count is then simply `(high - low) / 2 + 1`.

### 3Ô∏è‚É£ Approach 3: Prefix Count (Optimal)
We can calculate the count of odd numbers from `0` to `x` using the formula `(x + 1) / 2`.
- The answer for the range `[low, high]` is the count of odds up to `high` minus the count of odds up to `low - 1`.
- Formula: `count(high) - count(low - 1)` or simplified to `(high + 1) / 2 - low / 2`.

---

## üíª Solution Code

### Approach 1: Brute Force (TLE)

```cpp
// Intuition: Iterate through the range and count odd numbers manually.
// Approach: Adjust 'low' to be odd if needed, then increment by 2.
// Time Complexity: O(high - low) - Can be up to O(10^9), leading to TLE.
// Space Complexity: O(1) - Constant space used.

class Solution {
public:
    int countOdds(int low, int high) {
        int count = 0;
        
        // If low is even, start checking from the next number (which is odd)
        // or effectively just start the loop logic correctly.
        // Here we ensure 'low' starts as an odd number for the loop optimization
        low = low % 2 ? low : low + 1; 

        // Iterate from adjusted low to high, jumping 2 steps to hit only odds
        for(int num = low; num <= high; num += 2) { 
                count++;
        }

        return count;
    }
};

/*
*
* Dry Run
* Input: low = 3, high = 7
* 1. low (3) is odd. Loop starts at 3.
* 2. Iteration 1: num = 3. count = 1.
* 3. Iteration 2: num = 5. count = 2.
* 4. Iteration 3: num = 7. count = 3.
* 5. Iteration 4: num = 9 (9 > 7). Loop ends.
* Output: 3
*
*/
```

### Approach 2: Mathematical Adjustment

```cpp
// Intuition: The count of odds depends on the range size. We normalize the range to start and end with odds.
// Approach: Convert even boundaries to odd boundaries inside the range, then apply the formula (len/2) + 1.
// Time Complexity: O(1) - Constant mathematical operations.
// Space Complexity: O(1) - No extra space allocated.

class Solution {
public:
    int countOdds(int low, int high) {
        // If low is even, the first odd number is low + 1
        if(low % 2 == 0)
            low++;
        
        // If high is even, the last odd number is high - 1
        if(high % 2 == 0)
            high--;
  
        // If low became greater than high after adjustment (e.g., low=4, high=4 -> low=5, high=3), no odds exist
        if (low > high) return 0;

        // Calculate count using the inclusive range formula
        return (high - low) / 2 + 1;
    }
};

/*
*
* Dry Run
* Input: low = 8, high = 10
* 1. low (8) is even -> low becomes 9.
* 2. high (10) is even -> high becomes 9.
* 3. Formula: (9 - 9) / 2 + 1 = 0 + 1 = 1.
* Output: 1
*
*/
```

### Approach 3: Prefix Calculation (Optimal)

```cpp
// Intuition: Count(low to high) = Count(0 to high) - Count(0 to low-1).
// Approach: Use the formula (n + 1) / 2 to find total odds from 0 to n.
// Time Complexity: O(1) - Basic arithmetic operations.
// Space Complexity: O(1) - Constant space usage.

class Solution {
public:
    int countOdds(int low, int high) {
        // Odds in range [0, high] minus Odds in range [0, low-1]
        // Formula for odds from 0 to N is (N + 1) / 2
        return (high + 1) / 2 - (low) / 2;
    }
};

/*
*
* Dry Run
* Input: low = 3, high = 7
* 1. Count odds up to 7: (7 + 1) / 2 = 4. (Odds: 1, 3, 5, 7)
* 2. Count odds up to 2: (3) / 2 (integer division) = 1. (Odds: 1)
* Note: The formula effectively uses low/2 which is equivalent to counting odds up to low-1.
* 3. Result: 4 - 1 = 3.
* Output: 3
*
*/
```

---

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)