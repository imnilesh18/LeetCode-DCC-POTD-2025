# 1925. Count Square Sum Triples

<div align="center">

![Difficulty: Easy](https://img.shields.io/badge/Difficulty-Easy-green?style=flat-square&logo=leetcode)
![Language: C++](https://img.shields.io/badge/Language-C++-blue?style=flat-square&logo=c%2B%2B)
![Topic: Enumeration](https://img.shields.io/badge/Topic-Enumeration-orange?style=flat-square)
![Topic: Math](https://img.shields.io/badge/Topic-Math-purple?style=flat-square)

</div>

<br>

## ğŸ“ Problem Statement

A **square triple** `(a,b,c)` is a triple where `a`, `b`, and `c` are **integers** and `a^2 + b^2 = c^2`.

Given an integer `n`, return *the number of **square triples** such that* `1 <= a, b, c <= n`.

---

## â›“ï¸ Constraints

- `1 <= n <= 250`

---

## ğŸ” Examples

| Example | Input | Output | Explanation |
| :---: | :---: | :---: | :--- |
| **1** | `n = 5` | `2` | The square triples are `(3,4,5)` and `(4,3,5)`. |
| **2** | `n = 10` | `4` | The square triples are `(3,4,5)`, `(4,3,5)`, `(6,8,10)`, and `(8,6,10)`. |

---

## ğŸ’¡ Approach

The problem asks us to find the count of triples `(a, b, c)` such that `a^2 + b^2 = c^2` with all values $\le n$. Since the constraint on `n` is small ($n \le 250$), we can use a brute-force enumeration strategy.

1.  **Enumerate**: Use nested loops to iterate through all possible values for `a` and `b` in the range `[1, n]`.
2.  **Calculate**: For each pair `(a, b)`, compute the sum of squares $S = a^2 + b^2$.
3.  **Validate**: Determine if $\sqrt{S}$ is an integer `c` and if `c <= n`.
    * We can calculate `c` as the integer part of the square root of the sum.
    * Check if `c * c` is exactly equal to `a^2 + b^2` (perfect square check).
    * Check if `c` is within the valid range (i.e., `c <= n`).
4.  **Count**: If valid, increment the result counter.

---

## ğŸ’» Solution Code

```cpp
// Intuition: We need to find the number of triples (a, b, c) such that a^2 + b^2 = c^2 within the range [1, n]. Since n is small (up to 250), we can brute-force all pairs (a, b) and check if the resulting c is valid.
// Approach: Iterate through all possible values of 'a' and 'b' from 1 to n. For each pair, calculate the hypotenuse 'c' assuming it's a right triangle. Check if 'c' is an integer, less than or equal to n, and satisfies the Pythagorean theorem.
// Time Complexity: O(n^2) - Two nested loops iterating up to n.
// Space Complexity: O(1) - Only a few integer variables are used for storage.

class Solution {
public:
    int countTriples(int n) {
        int res = 0; // Initialize counter for valid triples
        // enumerate a and b
        for (int a = 1; a <= n; ++a) { // Iterate a from 1 to n
            for (int b = 1; b <= n; ++b) { // Iterate b from 1 to n
                // determine if it meets the requirements
                // Calculate integer square root of a^2 + b^2
                // Adding 1.0 acts as a small epsilon or simply ensures we use floating point sqrt before casting
                int c = int(sqrt(a * a + b * b + 1.0)); 
                
                // Check if c is within bounds and satisfies the equation exactly
                if (c <= n && c * c == a * a + b * b) {
                    ++res; // Found a valid square triple
                }
            }
        }
        return res; // Return total count
    }
};

/*
*
* Dry Run
* Input: n = 5
* * Iteration: a = 1, b = 1
* sum = 2, c = 1
* 1 <= 5 (True), 1*1 != 2 (False) -> No increment
* ...
* Iteration: a = 3, b = 4
* sum = 9 + 16 = 25
* c = int(sqrt(26.0)) = 5
* Check: 5 <= 5 (True) AND 25 == 25 (True)
* res increments to 1
* ...
* Iteration: a = 4, b = 3
* sum = 16 + 9 = 25
* c = int(sqrt(26.0)) = 5
* Check: 5 <= 5 (True) AND 25 == 25 (True)
* res increments to 2
* ...
* Iteration: a = 5, b = ... (No sums will satisfy c <= 5 except trivial/invalid ones not checked here logic-wise for c > n)
* * Final Result: 2
*
*/
````

-----

## ğŸ”‘ Key Insights

  - **Small Constraints:** The constraint $n \le 250$ is the key indicator that an $O(n^2)$ solution is acceptable.
  - **Precision:** When calculating `sqrt`, adding `1.0` inside `int()` conversion logic is a common trick in competitive programming to avoid truncation errors due to floating-point representation, though for perfect squares standard `sqrt` is usually sufficient.
  - **Symmetry:** The problem counts `(3, 4, 5)` and `(4, 3, 5)` as distinct triples, which is naturally handled by the nested loop structure iterating `a` and `b` independently.

-----

## ğŸ“„ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/count-square-sum-triples/) for original content and copyright.**

-----

## ğŸ‘¨â€ğŸ’» Author

  - [imnilesh18](https://github.com/imnilesh18)
