# 3583. Count Special Triplets

<p align="center">
  <a href="https://leetcode.com/problems/count-special-triplets/">
    <img src="https://img.shields.io/badge/LeetCode-3583-FFA116?style=for-the-badge&logo=leetcode" alt="LeetCode 3583">
  </a>
  <a href="https://github.com/imnilesh18">
    <img src="https://img.shields.io/badge/Author-imnilesh18-blue?style=for-the-badge&logo=github" alt="Author">
  </a>
  <a href="./LICENSE">
    <img src="https://img.shields.io/badge/License-MIT-green?style=for-the-badge" alt="License">
  </a>
</p>

## üìù Problem Statement

You are given an integer array `nums`.

A **special triplet** is defined as a triplet of indices `(i, j, k)` such that:
- `0 <= i < j < k < n`, where `n = nums.length`
- `nums[i] == nums[j] * 2`
- `nums[k] == nums[j] * 2`

Return the *total number of **special triplets** in the array*.

Since the answer may be large, return it **modulo** `10^9 + 7`.

### üîê Constraints

- `3 <= n == nums.length <= 10^5`
- `0 <= nums[i] <= 10^5`

---

## üéØ Examples

### Example 1
```

Input: nums = [6,3,6]
Output: 1
Explanation:
The only special triplet is (i, j, k) = (0, 1, 2), where:
nums[0] = 6, nums[1] = 3, nums[2] = 6
nums[0] = nums[1] \* 2 = 3 \* 2 = 6
nums[2] = nums[1] \* 2 = 3 \* 2 = 6

```

### Example 2
```

Input: nums = [0,1,0,0]
Output: 1
Explanation:
The only special triplet is (i, j, k) = (0, 2, 3), where:
nums[0] = 0, nums[2] = 0, nums[3] = 0
nums[0] = nums[2] \* 2 = 0 \* 2 = 0
nums[3] = nums[2] \* 2 = 0 \* 2 = 0

```

### Example 3
```

Input: nums = [8,4,2,8,4]
Output: 2
Explanation:
There are exactly two special triplets:

1.  (i, j, k) = (0, 1, 3) -\> nums[0]=8, nums[1]=4, nums[3]=8. (8 = 4\*2)
2.  (i, j, k) = (1, 2, 4) -\> nums[1]=4, nums[2]=2, nums[4]=4. (4 = 2\*2)

<!-- end list -->

````

---

## üí° Key Insights

To find a triplet `(i, j, k)` such that `nums[i] == 2*nums[j]` and `nums[k] == 2*nums[j]` with `i < j < k`:

1.  **Central Element Strategy**: Focus on the middle element `j`. If we fix `j`, we simply need to count how many `2 * nums[j]` exist to its **left** (for `i`) and how many exist to its **right** (for `k`).
2.  **Frequency Maps**: We can use Hash Maps to store frequencies.
    -   **Approach 1 (Two Pass)**: Count all frequencies first (Right Map), then iterate through the array moving elements from Right to Left maps.
    -   **Approach 2 (One Pass)**: Build the count of valid pairs dynamically. We look for a valid `k` based on previously formed valid `(i, j)` pairs.

---

## üöÄ Solutions

### Approach 1: Two Pass Solution (Left & Right Maps)

We maintain two frequency maps: `mp_left` (elements before current index) and `mp_right` (elements after current index). For every element `x` acting as `nums[j]`, we calculate `count(2x in left) * count(2x in right)`.

```cpp
// Intuition: Iterate through each element as the middle element 'j'. Use maps to count occurrences of '2*nums[j]' to the left and right.
// Approach: 
// 1. Precompute frequencies of all elements in a 'right' map.
// 2. Iterate through the array, treating the current element as 'nums[j]'.
// 3. Move current element from 'right' map to 'left' map logic (decrement right count).
// 4. Calculate contribution: count of (nums[j]*2) in left * count of (nums[j]*2) in right.
// 5. Add current element to 'left' map for next iterations.
// Time Complexity: O(n) - Two passes over the array.
// Space Complexity: O(n) - To store frequency maps.
class Solution {
public:
    int M = 1e9+7;

    int specialTriplets(vector<int>& nums) {
        unordered_map<int, int> mp_left;
        unordered_map<int, int> mp_right;

        int result = 0;

        // Populate right map with all frequencies initially
        for(int &num : nums) {
            mp_right[num]++;
        }

        for(int &num : nums) {
            // Remove current element from right map as it is now 'nums[j]'
            mp_right[num]--;

            // Target value to find is num * 2
            int left  = mp_left[num*2];
            int right = mp_right[num*2];

            // Add valid combinations to result
            result = (result + (1LL * left * right)) % M;

            // Add current element to left map for future iterations
            mp_left[num]++;
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: nums = [6, 3, 6]
* * 1. Init: mp_right = {6:2, 3:1}, mp_left = {}, result = 0
* * 2. Iteration 1 (num = 6):
* - mp_right[6] becomes 1
* - target = 12. mp_left[12] = 0, mp_right[12] = 0
* - result += 0
* - mp_left[6] becomes 1
* * 3. Iteration 2 (num = 3):
* - mp_right[3] becomes 0
* - target = 6. mp_left[6] = 1, mp_right[6] = 1
* - result += 1 * 1 = 1
* - mp_left[3] becomes 1
* * 4. Iteration 3 (num = 6):
* - mp_right[6] becomes 0
* - target = 12. mp_left[12] = 0, mp_right[12] = 0
* - result += 0
* - mp_left[6] becomes 2
* * End: Return 1
*
*/
````

### Approach 2: One Pass Solution (Dynamic Counting)

We can solve this in a single pass by maintaining two states:

1.  `valid_i`: Frequency of numbers seen so far (potential candidates for `nums[i]`).
2.  `valid_j`: Frequency of valid `(i, j)` pairs formed so far (where `nums[i] == 2 * nums[j]`).

When we encounter a number `num`, it acts as `nums[k]`. We check if there are any existing pairs `(i, j)` where `nums[j] == num / 2`. If so, we found a triplet.

```cpp
// Intuition: Build the triplet dynamically. Count valid 'i's, combine to form valid 'i,j' pairs, and finally valid 'i,j,k' triplets.
// Approach:
// 1. Maintain two maps: valid_i (freq of nums seen) and valid_j (count of pairs (i, j) ending at j where nums[i] == 2*nums[j]).
// 2. Iterate through nums. Treat current 'num' as 'k'.
// 3. If num is even, add valid_j[num/2] to result (forms triplet 2x, x, 2x).
// 4. Update valid_j[num]: add count of valid_i[num*2] (forms pair 2x, x).
// 5. Update valid_i[num]: increment count.
// Time Complexity: O(n) - Single pass.
// Space Complexity: O(n) - To store maps.
class Solution {
public:
    int M = 1e9+7;

    int specialTriplets(vector<int>& nums) {
        unordered_map<int, int> valid_i;
        unordered_map<int, int> valid_j;

        int result = 0;

        for(int &num : nums) {
            
            // If current 'num' acts as 'nums[k]', we need a pair ending with 'num/2'
            if(num%2 == 0) { //if it's valid k, we got our triplet
                result = (result + valid_j[num/2]) % M;
            }

            // If current 'num' acts as 'nums[j]', check if 'num*2' exists as 'nums[i]'
            // If it's valid j or not
            valid_j[num] = (valid_j[num] + valid_i[num*2]) % M;

            // Track frequency of numbers to serve as 'nums[i]' later
            valid_i[num]++;
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: nums = [8, 4, 2, 8, 4]
* * 1. num = 8:
* - Even? Yes. res += valid_j[4] (0) -> res = 0
* - valid_j[8] += valid_i[16] (0) -> valid_j = {8:0}
* - valid_i[8]++ -> valid_i = {8:1}
* * 2. num = 4:
* - Even? Yes. res += valid_j[2] (0) -> res = 0
* - valid_j[4] += valid_i[8] (1) -> valid_j = {8:0, 4:1}
* - valid_i[4]++ -> valid_i = {8:1, 4:1}
* * 3. num = 2:
* - Even? Yes. res += valid_j[1] (0) -> res = 0
* - valid_j[2] += valid_i[4] (1) -> valid_j = {8:0, 4:1, 2:1}
* - valid_i[2]++ -> valid_i = {8:1, 4:1, 2:1}
* * 4. num = 8:
* - Even? Yes. res += valid_j[4] (1) -> res = 1 (Triplet: 8,4,8)
* - valid_j[8] += valid_i[16] (0) -> valid_j[8] stays 0
* - valid_i[8]++ -> valid_i[8]=2
* * 5. num = 4:
* - Even? Yes. res += valid_j[2] (1) -> res = 2 (Triplet: 4,2,4)
* - valid_j[4] += valid_i[8] (2) -> valid_j[4]=3
* - valid_i[4]++ -> valid_i[4]=2
* * End: Return 2
*
*/
```

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/count-special-triplets/) for original content and copyright.**

## üë®‚Äçüíª Author

  - [imnilesh18](https://github.com/imnilesh18)
