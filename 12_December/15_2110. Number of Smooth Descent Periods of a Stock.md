# 2110. Number of Smooth Descent Periods of a Stock

<p align="center">
  <a href="https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/">
    <img src="https://img.shields.io/badge/LeetCode-2110-FFA116?style=for-the-badge&logo=leetcode&logoColor=black" alt="LeetCode 2110">
  </a>
</p>

## ğŸ“š Table of Contents
- [â„¹ï¸ Overview](#-overview)
- [ğŸ“ Problem Statement](#-problem-statement)
- [ğŸ¯ Examples](#-examples)
- [ğŸ’¡ Approach](#-approach)
- [ğŸ’» Solution Code](#-solution-code)
- [ğŸ”‘ Key Insights](#-key-insights)
- [ğŸ“„ License](#-license)
- [ğŸ‘¨â€ğŸ’» Author](#-author)

---

## â„¹ï¸ Overview

| Property | Details |
| :--- | :--- |
| **Problem Link** | [2110. Number of Smooth Descent Periods of a Stock](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/) |
| **Problem Name** | Number of Smooth Descent Periods of a Stock |
| **Difficulty** | <img src="https://img.shields.io/badge/Medium-FFB800?style=flat-square&logo=leetcode&logoColor=white" alt="Medium" /> |
| **Tags** | `Array`, `Dynamic Programming`, `Math` |

---

## ğŸ“ Problem Statement

You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day.

A **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule.

Return *the number of **smooth descent periods***.

**Constraints:**
- `1 <= prices.length <= 10^5`
- `1 <= prices[i] <= 10^5`

---

## ğŸ¯ Examples

### Example 1

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `prices = [3,2,1,4]` | `7` | There are 7 smooth descent periods: `[3]`, `[2]`, `[1]`, `[4]`, `[3,2]`, `[2,1]`, and `[3,2,1]`. Note that a period with one day is a smooth descent period by the definition. |

### Example 2

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `prices = [8,6,7,7]` | `4` | There are 4 smooth descent periods: `[8]`, `[6]`, `[7]`, and `[7]`. Note that `[8,6]` is not a smooth descent period as `8 - 6 â‰  1`. |

### Example 3

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `prices = [1]` | `1` | There is 1 smooth descent period: `[1]`. |

---

## ğŸ’¡ Approach

The core idea is to count the length of contiguous subarrays where the price decreases by exactly 1.

1.  **Initialization:** We start with `result = 1` and `count = 1` because the first element itself is always a valid smooth descent period of length 1.
2.  **Iteration:** Loop through the array starting from the second element (index 1).
3.  **Check Descent:** Compare the current price `prices[i]` with the previous price `prices[i-1]`.
    - If `prices[i-1] - prices[i] == 1`, it means the descent continues. We increment the current descent length `count`.
    - If not, the streak is broken. We reset `count` to `1` (representing the current element alone).
4.  **Accumulate:** Add the current `count` to the total `result`.
    - *Why add `count`?* If you have a sequence like `3, 2`, adding `2` creates subarrays `[3, 2]` and `[2]`. If you have `3, 2, 1`, adding `1` creates `[3, 2, 1]`, `[2, 1]`, `[1]`. Effectively, adding the current length counts all new subarrays ending at the current index.
5.  **Return:** The final `result`.

---

## ğŸ’» Solution Code

```cpp
// Intuition: If prices drop by 1, the new subarrays ending here equal the length of the current descent sequence.
// Approach: One-pass iteration maintaining a running count of the current smooth descent length.
// Time Complexity: O(N) where N is the length of prices array (single pass).
// Space Complexity: O(1) as we only use variables for result and count.

class Solution {
public:
    long long getDescentPeriods(vector<int>& prices) {
        long long result = 1; // Start with 1 for the first element
        long long count  = 1; // Current descent streak length

        for(int i = 1; i < prices.size(); i++) {
            // Check if current price is exactly 1 less than previous
            if(prices[i - 1] - prices[i] == 1) {
                count++; // Extend the streak
            } else {
                count = 1; // Reset streak to current element only
            }
            result += count; // Add possible subarrays ending at i
        }
        return result;
    }
};

/*
*
* Dry Run
* Input: prices = [3, 2, 1, 4]
* N = 4
* * Initialization:
* result = 1, count = 1
*
* Iteration 1 (i = 1, val = 2):
* prices[0] (3) - prices[1] (2) == 1? -> True
* count becomes 2 (sequence: 3, 2)
* result += 2 -> result = 3
*
* Iteration 2 (i = 2, val = 1):
* prices[1] (2) - prices[2] (1) == 1? -> True
* count becomes 3 (sequence: 3, 2, 1)
* result += 3 -> result = 6
*
* Iteration 3 (i = 3, val = 4):
* prices[2] (1) - prices[3] (4) == 1? -> False
* count resets to 1 (sequence: 4)
* result += 1 -> result = 7
*
* End of loop. Return result = 7.
*
*/
```

---

## ğŸ”‘ Key Insights

- **Single Element Validity:** Every individual element is a valid smooth descent period of length 1.
- **Incremental Contribution:** Instead of calculating `N*(N+1)/2` for every segment separately, we can add the current length of the streak to the total result at each step. This handles overlapping periods implicitly.
- **Data Types:** Since the number of periods can exceed the 32-bit integer limit (constraints up to 10^5), we must use `long long` for `result` and `count`.

---

## ğŸ“„ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/number-of-smooth-descent-periods-of-a-stock/) for original content and copyright.**

---

## ğŸ‘¨â€ğŸ’» Author

- [imnilesh18](https://github.com/imnilesh18)