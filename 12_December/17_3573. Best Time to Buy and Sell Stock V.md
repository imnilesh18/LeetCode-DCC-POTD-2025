# 3573. Best Time to Buy and Sell Stock V

<div align="center">
  <img src="https://img.shields.io/badge/Difficulty-Medium-orange?style=for-the-badge" alt="Difficulty Medium">
  <img src="https://img.shields.io/badge/Topic-Dynamic%20Programming-blue?style=for-the-badge" alt="Topic DP">
  <img src="https://img.shields.io/badge/LeetCode-3573-yellow?style=for-the-badge&logo=leetcode" alt="Problem Number">
</div>

## üìù Problem Statement

You are given an integer array `prices` where `prices[i]` is the price of a stock on the $i^{th}$ day, and an integer `k`.

You are allowed to make at most `k` transactions, where each transaction can be either:
1.  **Normal transaction**: Buy on day `i`, then sell on a later day `j` where $i < j$. Profit = `prices[j] - prices[i]`.
2.  **Short selling transaction**: Sell on day `i`, then buy back on a later day `j` where $i < j$. Profit = `prices[i] - prices[j]`.

**Note:**
- You must complete each transaction before starting another.
- You cannot buy or sell on the same day you are selling or buying back as part of a previous transaction.
- Return the **maximum** total profit you can earn with at most `k` transactions.

## ‚öôÔ∏è Constraints

- `2 <= prices.length <= 10¬≥`
- `1 <= prices[i] <= 10‚Åπ`
- `1 <= k <= prices.length / 2`

---

## üí° Examples

| Input | Output | Explanation |
| :--- | :--- | :--- |
| `prices = [1,7,9,8,2], k = 2` | `14` | Normal: Buy day 0 ($1), Sell day 2 ($9) [Profit: 8]. Short: Sell day 3 ($8), Buy back day 4 ($2) [Profit: 6]. Total: 14. |
| `prices = [12,16,19,19,8,1,19,13,9], k = 3` | `36` | Normal: (12->19) [7]. Short: (19->8) [11]. Normal: (1->19) [18]. Total: 36. |

---

## üöÄ Approach

The problem is a variation of the classic Stock Buy/Sell problems but introduces **Short Selling**. Since we have at most `k` transactions and different states, **Dynamic Programming** is the optimal choice.

### üß† Intuition
At any day $i$, we can either:
1.  **Skip** the day (no action).
2.  **Take action** based on our current state:
    -   **Case 0 (Fresh):** Start a new transaction. Either buy long or short sell.
    -   **Case 1 (Long):** We already bought a stock; we must sell it to close the transaction.
    -   **Case 2 (Short):** We already sold a stock; we must buy it back to close the transaction.

### üõ†Ô∏è Key Logic
-   **Transaction Completion**: A transaction is completed only when a "buy" is followed by a "sell", or a "short-sell" is followed by a "buy-back". This is when we decrement `k`.
-   **Invalid States**: If we reach the end of the array while a transaction is still open (Case 1 or Case 2), that path is invalid (`INT_MIN`).
-   **Short Selling**: In real-world terms, short selling involves borrowing a stock to sell it now and buying it back later at a lower price.

---

## üíª Solution Code

### Approach 1: Recursion + Memoization

```cpp
// Intuition: The problem involves making decisions at each step with a limited number of transactions. We maintain states to track if we are in a normal transaction, a short-selling transaction, or waiting to start one.
// Approach: Use a 3D DP table t[index][k][case] where index is the current day, k is remaining transactions, and case represents the current holding status.
// Time Complexity: O(n * k) - where n is the number of days and k is the max transactions, as each state is computed once.
// Space Complexity: O(n * k) - for the 3D memoization table and recursion stack.

class Solution {
public:
    long long t[1001][501][3];

    // CASE:
    // 0 -> Fresh state: No stock held, no short-sale active.
    // 1 -> Long state: Stock bought, waiting to sell.
    // 2 -> Short state: Stock sold, waiting to buy back.
    long long solve(int i, int k, int CASE, vector<int>& prices) {

        // Base Case: Reached the end of days
        if (i == prices.size()) {
            if (CASE == 0)
                return 0; // All transactions finished
            return INT_MIN; // Unfinished transaction is invalid
        }

        // Return memoized result
        if (t[i][k][CASE] != INT_MIN)
            return t[i][k][CASE];

        long long take = INT_MIN;
        long long dontTake;

        // Choice 1: Do nothing today (Skip)
        dontTake = solve(i + 1, k, CASE, prices);

        // Choice 2: Take action (Buy/Sell/Short-Sell/Buy-Back)
        if (k > 0) {
            if (CASE == 1) {
                // Currently holding: Sell today to complete normal transaction
                take = prices[i] + solve(i + 1, k - 1, 0, prices);
            }
            else if (CASE == 2) {
                // Currently short: Buy back today to complete short transaction
                take = -prices[i] + solve(i + 1, k - 1, 0, prices);
            }
            else {
                // CASE == 0: Start a fresh transaction
                take = max(
                    -prices[i] + solve(i + 1, k, 1, prices), // Buy (Long)
                     prices[i] + solve(i + 1, k, 2, prices)  // Short Sell
                );
            }
        }

        // Store and return the maximum profit between choices
        return t[i][k][CASE] = max(take, dontTake);
    }

    long long maximumProfit(vector<int>& prices, int k) {
        int n = prices.size();

        // Initialize memoization table with INT_MIN
        for (int i = 0; i <= n; i++)
            for (int j = 0; j <= k; j++)
                for (int l = 0; l < 3; l++)
                    t[i][j][l] = INT_MIN;

        return solve(0, k, 0, prices);
    }
};

/*
* Dry Run
* prices = [1, 7, 9], k = 1
* Day 0 (Price 1): Choice 1: Skip. Choice 2: Buy (-1) -> State Case 1.
* Day 1 (Price 7): If Case 1, Choice 2: Sell (+7). Total Profit = -1 + 7 = 6.
* Day 2 (Price 9): If Case 1, Choice 2: Sell (+9). Total Profit = -1 + 9 = 8.
* Recursion explores all paths and picks Max profit 8.
*/
```

### Approach 2: Bottom-Up (Tabulation)

```cpp
// Intuition: Iteratively build up the solution from the last day to the first. By filling the DP table backwards, we ensure that every 'future' state required for the current calculation is already computed.
// Approach: Create a 3D table t[n+1][K+1][3]. Initialize the base case for day n. Iterate i from n-1 down to 0, k from 0 to K, and calculate transitions for each of the 3 cases.
// Time Complexity: O(n * k) - nested loops for days and transactions.
// Space Complexity: O(n * k) - for the 3D DP table.

class Solution {
public:
    long long maximumProfit(vector<int>& prices, int K) {
        int n = prices.size();
        long long t[1001][501][3];

        // Base case: day n (i == n)
        // Profit is 0 if no transactions are open, else invalid (INT_MIN)
        for (int k = 0; k <= K; k++) {
            t[n][k][0] = 0;
            t[n][k][1] = INT_MIN;
            t[n][k][2] = INT_MIN;
        }

        // Fill table bottom-up from last day to first
        for (int i = n - 1; i >= 0; i--) {
            for (int k = 0; k <= K; k++) {
                
                // Case 0: No transaction in progress
                t[i][k][0] = t[i + 1][k][0]; // Option: Skip today
                if (k > 0) {
                    long long buyLong = -prices[i] + t[i + 1][k][1];
                    long long shortSell = prices[i] + t[i + 1][k][2];
                    t[i][k][0] = max({t[i][k][0], buyLong, shortSell});
                }

                // Case 1: Holding long position
                t[i][k][1] = t[i + 1][k][1]; // Option: Hold today
                if (k > 0) {
                    long long sellStock = prices[i] + t[i + 1][k - 1][0];
                    t[i][k][1] = max(t[i][k][1], sellStock);
                }

                // Case 2: Holding short position
                t[i][k][2] = t[i + 1][k][2]; // Option: Hold today
                if (k > 0) {
                    long long buyBack = -prices[i] + t[i + 1][k - 1][0];
                    t[i][k][2] = max(t[i][k][2], buyBack);
                }
            }
        }

        // Answer is starting on day 0 with K transactions available and Case 0
        return t[0][K][0];
    }
};

/*
* Dry Run
* prices = [2, 1], k = 1
* Init: t[2][all][0]=0, others=MIN
* i = 1 (Price 1):
* t[1][1][0]: max(skip:0, buy:-1, short:1) = 1
* t[1][1][1]: max(skip:MIN, sell:1+t[2][0][0]=1) = 1
* t[1][1][2]: max(skip:MIN, buyBack:-1+t[2][0][0]=-1) = -1
* i = 0 (Price 2):
* t[0][1][0]: max(skip:t[1][1][0]=1, buy:-2+t[1][1][1]=-1, short:2+t[1][1][2]=1) = 1
* Result: 1
*/
```

---

## üîç Key Insights

-   **State Management**: The problem highlights how tracking "what we are currently doing" (Long vs Short) is crucial for correct DP transitions.
-   **Unfinished Transactions**: Returning `INT_MIN` for open positions at the end of the array is a common DP pattern to filter out invalid paths.
-   **Short Selling**: Unlike typical stock problems, short selling means your profit increases when the price goes **down**.

## üõ†Ô∏è Further Exploration

-   **Memory Optimization**: Since `t[i]` only depends on `t[i+1]`, the space complexity can be reduced from $O(n \times k)$ to $O(k)$ by using only two layers of the DP table.
-   **Infinite Transactions**: If $k$ was infinite, the problem would simplify to capturing every profitable price move (Greedy).

## üìö References

-   [LeetCode Stock Problem Series](https://leetcode.com/problemset/all/?search=best%20time%20to%20buy%20and%20sell%20stock)
-   [Short Selling Explanation](https://www.investopedia.com/terms/s/shortselling.asp)

## üè∑Ô∏è Tags
`Array` `Dynamic Programming` `C++` `Memoization` `Tabulation`

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-v/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)