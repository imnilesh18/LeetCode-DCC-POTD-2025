# 1351. Count Negative Numbers in a Sorted Matrix

<div align="center">

<img src="https://img.shields.io/badge/Difficulty-Easy-green" alt="Difficulty" />
<img src="https://img.shields.io/badge/Time_Complexity-O(m_+_n)-blue" alt="Time Complexity" />
<img src="https://img.shields.io/badge/Space_Complexity-O(1)-yellow" alt="Space Complexity" />

</div>

---

## üîó Problem Link

[**LeetCode: Count Negative Numbers in a Sorted Matrix**](https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description)

## üí° Problem Statement

Given a `m x n` matrix `grid` which is sorted in non-increasing order both row-wise and column-wise, return _the number of **negative** numbers in_ `grid`.

**Follow up:** Could you find an `O(n + m)` solution?

## üìù Constraints

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 100`
- `-100 <= grid[i][j] <= 100`

## üîé Examples

<details>
<summary><b>Click to expand examples</b></summary>

### Example 1:

> **Input:** `grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]` > **Output:** `8` > **Explanation:** There are 8 negatives number in the matrix.

### Example 2:

> **Input:** `grid = [[3,2],[1,0]]` > **Output:** `0`

</details>

---

## üöÄ Approach & Solution

We can solve this problem using three different approaches, ranging from a basic brute-force method to an optimized linear time solution.

### Approach 1: Brute Force (Iterative)

The simplest approach is to traverse the entire matrix element by element. Since the constraints are small (`m, n <= 100`), this will pass, but it doesn't utilize the sorted property of the matrix.

**Time Complexity:** $O(m \times n)$ - We visit every cell.
**Space Complexity:** $O(1)$ - No extra space used.

```cpp
// Intuition: Iterate through the complete matrix and count negative numbers directly.
// Approach: Use nested loops to traverse every cell in the grid. If a value is less than 0, increment the counter.
// Time Complexity: O(m * n) where m is the number of rows and n is the number of columns.
// Space Complexity: O(1) as no extra space is used.

class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int result = 0;

        // Iterate through each row
        for(int i = 0; i<m; i++) {
            // Iterate through each column
            for(int j = 0; j<n; j++) {

                // Check if current element is negative
                if(grid[i][j] < 0)
                    result++;

            }
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: [[4,3,2,-1], [3,2,1,-1]]
* i=0, j=0..3: Vals 4,3,2,-1. Count increments at -1. Result = 1.
* i=1, j=0..3: Vals 3,2,1,-1. Count increments at -1. Result = 2.
* Output: 2
*
*/
```

---

### Approach 2: Binary Search

Since each row is sorted in **non-increasing** order, we can use binary search to find the first negative number in each row. Once we find the first negative number at index `idx`, all subsequent numbers in that row (`idx` to `n-1`) are also negative.

**Time Complexity:** $O(m \log n)$ - Binary search is performed for each of the `m` rows.
**Space Complexity:** $O(1)$ - Constant space.

```cpp
// Intuition: Since each row is sorted in non-increasing order, we can efficiently find the start of negative numbers using binary search.
// Approach: Iterate through each row. Use upper_bound with a custom comparator (greater<int>) to find the first element strictly less than 0. Count remaining elements in the row.
// Time Complexity: O(m * log(n)) because we perform a binary search on each of the m rows.
// Space Complexity: O(1) excluding stack space for the comparator.

class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int result = 0;

        for(auto &vec : grid) {

            // Find first element strictly less than 0 (since sorted desc, use greater<int> comparator)
            // upper_bound returns iterator to first element that compares 'true' with value (0)
            int idx = upper_bound(begin(vec), end(vec), 0, greater<int>()) - begin(vec);

            // Elements from idx to end are negative
            result += n-idx;

        }

        return result;
    }
};

/*
*
* Dry Run
* Input: [[3,2],[1,0]]
* Row 1: [3, 2]. upper_bound for 0 returns end(). Index = 2. Count += 2-2 = 0.
* Row 2: [1, 0]. upper_bound for 0 returns end(). Index = 2. Count += 2-2 = 0.
* Output: 0
*
*/
```

---

### Approach 3: Optimal (Staircase Method)

This approach leverages the fact that the matrix is sorted **both** row-wise and column-wise. We start from the **bottom-left** corner of the matrix.

- If the current element is negative, it means all elements to its right in the current row are also negative (due to non-increasing order). We add those to the count and move **up** to find more positive numbers.
- If the current element is positive (or zero), we need to look for smaller numbers, so we move **right**.

**Time Complexity:** $O(m + n)$ - In the worst case, we traverse from bottom-left to top-right, moving at most `m` times up and `n` times right.
**Space Complexity:** $O(1)$ - Constant space.

```cpp
// Intuition: Utilize sorting in both dimensions. Start from bottom-left corner. If a number is negative, all numbers to its right are also negative. If positive, we need to look further right.
// Approach: Start pointer at (m-1, 0). If grid[row][col] < 0, add (n - col) to result and move up. Else, move right.
// Time Complexity: O(m + n) as we traverse at most m rows and n columns in a staircase manner.
// Space Complexity: O(1) as no auxiliary space is required.

class Solution {
public:
    int countNegatives(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();

        int row = m-1;
        int col = 0;

        int result = 0;
        // Start traversal from bottom-left
        while( row >= 0 && col < n) {

            // If negative, all elements to the right in this row are also negative
            if(grid[row][col] < 0) {
                result += n-col; // Add count of negative numbers in this row
                row--;           // Move to upper row to check for more
            } else {
                col++;           // Current is positive, so move to next column to find smaller values
            }
        }

        return result;
    }
};

/*
*
* Dry Run
* Input: [[4,3,2,-1], [3,2,1,-1], [1,1,-1,-2], [-1,-1,-2,-3]] (4x4)
* Start: row=3, col=0. Val=-1.
* -1 < 0: Add (4-0)=4 to result. result=4. Move up (row=2).
* row=2, col=0. Val=1.
* 1 >= 0: Move right (col=1).
* row=2, col=1. Val=1.
* 1 >= 0: Move right (col=2).
* row=2, col=2. Val=-1.
* -1 < 0: Add (4-2)=2 to result. result=4+2=6. Move up (row=1).
* ... Process continues similarly ...
* Total Result = 8
*
*/
```

---

## üîë Key Insights

1.  **Sorted Property**: The problem explicitly states sorting in non-increasing order. This is the biggest hint to look beyond $O(m \times n)$.
2.  **Binary Search**: Any sorted array immediately suggests Binary Search. Applying it row-by-row improves efficiency.
3.  **Optimal Traversal**: The combination of row and column sorting allows for a "Staircase" traversal (similar to "Search a 2D Matrix II"), reducing complexity to linear relative to dimensions.

## üìÑ License

This repository is released under the [MIT License](./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
