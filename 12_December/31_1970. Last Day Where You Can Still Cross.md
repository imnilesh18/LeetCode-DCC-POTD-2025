# 1970. Last Day Where You Can Still Cross

## üîó Problem Link

[LeetCode Problem - Last Day Where You Can Still Cross](https://leetcode.com/problems/last-day-where-you-can-still-cross/)

## üìù Problem Statement

There is a **1-based** binary matrix where `0` represents land and `1` represents water. You are given integers `row` and `col` representing the number of rows and columns in the matrix, respectively.

Initially on day `0`, the **entire** matrix is **land**. However, each day a new cell becomes flooded with **water**. You are given a **1-based** 2D array `cells`, where `cells[i] = [ri, ci]` represents that on the `ith` day, the cell on the `ri`th row and `ci`th column (**1-based** coordinates) will be covered with **water** (i.e., changed to `1`).

You want to find the **last** day that it is possible to walk from the **top** to the **bottom** by only walking on land cells. You can start from **any** cell in the top row and end at **any** cell in the bottom row. You can only travel in the **four** cardinal directions (left, right, up, and down).

Return _the **last** day where it is possible to walk from the **top** to the **bottom** by only walking on land cells_.

## üéØ Examples

### Example 1

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2021/07/27/1.png" alt="Example 1 Image" width="400"/>
</div>

**Input:** `row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]`  
**Output:** `2`  
**Explanation:** The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 2.

### Example 2

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2021/07/27/2.png" alt="Example 2 Image" width="400"/>
</div>

**Input:** `row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]`  
**Output:** `1`  
**Explanation:** The last day where it is possible to cross from top to bottom is on day 1.

### Example 3

<div align="center">
  <img src="https://assets.leetcode.com/uploads/2021/07/27/3.png" alt="Example 3 Image" width="400"/>
</div>

**Input:** `row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]]`  
**Output:** `3`  
**Explanation:** The last day where it is possible to cross from top to bottom is on day 3.

## üîí Constraints

- `2 <= row, col <= 2 * 10^4`
- `4 <= row * col <= 2 * 10^4`
- `cells.length == row * col`
- `1 <= ri <= row`
- `1 <= ci <= col`
- All the values of `cells` are **unique**.

## üè∑Ô∏è Tags

`Array` `Binary Search` `Depth-First Search` `Breadth-First Search` `Union Find` `Matrix`

## üí° Key Insights & Approach

The problem asks for the "last day" a condition holds true. This is a classic indicator of **Binary Search on Answer**.

1.  **Monotonicity**:

    - If it's possible to cross on Day `k`, it is certainly possible to cross on Day `k-1` (because there is even less water).
    - If it's _impossible_ to cross on Day `k`, it is certainly impossible to cross on Day `k+1` (because there is even more water).
    - This monotonic property allows us to use binary search to find the threshold day.

2.  **Binary Search Range**:

    - `Low`: 0 (Day 0, all land).
    - `High`: `cells.size() - 1` (The last possible day).

3.  **Check Function (`canCross`)**:

    - For a given `mid` day, we simulate the state of the grid.
    - We mark all cells from index `0` to `mid` in the `cells` array as water (`1`).
    - We then perform a **Graph Traversal (BFS or DFS)** starting from all land cells in the **top row**.
    - If our traversal can reach any cell in the **bottom row**, then it is possible to cross on this day.

4.  **Optimization**:
    - The search space is `1` to `row * col`.
    - Each check takes `O(row * col)` time.
    - Total complexity involves `log(row*col)` checks.

## üöÄ Solution Code

### Approach 1: Binary Search + DFS

```cpp
// Intuition: We use Binary Search to find the latest day. For a specific day, we rebuild the grid with water and use DFS to check if a path exists from the top row to the bottom row.
// Approach:
// 1. Define a search space [0, cells.size()-1].
// 2. Calculate mid. Build a temporary grid where cells from 0 to mid are water.
// 3. Run DFS from all land cells in the top row.
// 4. If DFS reaches the bottom row, we can cross; try a later day (move left pointer). Else, try an earlier day (move right pointer).
// Time Complexity: O(R * C * log(R * C)) where R is row and C is col. The log comes from binary search, and building/traversing the grid takes O(R*C).
// Space Complexity: O(R * C) for the grid and recursion stack.

class Solution {
public:
    int ROW;
    int COL;
    vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    bool dfs(vector<vector<int>> &grid, int i, int j) {
        // Boundary checks and check if current cell is water (1)
        if(i < 0 || i >= ROW || j < 0 || j >= COL || grid[i][j] == 1) {
            return false;
        }

        // If we reached the last row, a path exists
        if(i == ROW-1)
            return true;

        // Mark as visited to avoid cycles and redundant processing
        grid[i][j] = 1;

        // Explore all 4 cardinal directions
        for(vector<int> &dir : directions) {
            int new_i = i + dir[0];
            int new_j = j + dir[1];

            if(dfs(grid, new_i, new_j))
                return true;
        }

        return false;
    }

    bool canCross(vector<vector<int>>& cells, int day) {
        vector<vector<int>> grid(ROW, vector<int>(COL, 0)); // 0 represents land

        // Mark cells as water up to the 'day' index
        for (int i = 0; i <= day; ++i) {
            int r = cells[i][0] - 1; // Convert 1-based to 0-based
            int c = cells[i][1] - 1;
            grid[r][c] = 1;
        }

        // Try DFS starting from any land cell in the top row
        for (int j = 0; j < COL; j++) {
            if (grid[0][j] == 0 && dfs(grid, 0, j)) {
                return true;
            }
        }
        return false;
    }

    int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
        ROW = row;
        COL = col;

        int l = 0;
        int r = cells.size()-1;
        int lastDay = 0;

        // Binary Search on days
        while(l <= r) {
            int mid = l + (r-l)/2;

            if(canCross(cells, mid)) {
                lastDay = mid + 1; // Store 1-based day result
                l = mid + 1;       // Try to find a later possible day
            } else {
                r = mid - 1;       // Current day impossible, look earlier
            }
        }

        return lastDay;
    }
};

/*
*
* Dry Run
* Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]]
* * Initial State:
* l = 0, r = 3 (size-1)
* * Iteration 1:
* mid = 1
* canCross(mid=1):
* Grid fills cells[0] (0,0) and cells[1] (1,0) as Water (1).
* Grid:
* [1, 0]
* [1, 0]
* Start DFS from top row land: (0,1).
* Path: (0,1) -> (1,1). Reached row 1 (bottom). Return True.
* Result: Possible. lastDay = 2. l moves to 2.
* * Iteration 2:
* l = 2, r = 3
* mid = 2
* canCross(mid=2):
* Grid fills cells[0..2]: (0,0), (1,0), (0,1) as Water.
* Grid:
* [1, 1]
* [1, 0]
* Start DFS from top row: No land cells (all 1).
* Result: Impossible. Return False. r moves to 1.
* * Termination:
* l (2) > r (1). Loop ends.
* Return lastDay = 2.
*/

```

### Approach 2: Binary Search + BFS

```cpp
// Intuition: Similar to Approach 1, but uses Breadth-First Search (BFS) to find the path. BFS is iterative and avoids recursion depth issues for large grids.
// Approach:
// 1. Binary Search for the last day.
// 2. In check function, build grid up to 'mid' day.
// 3. Add all top-row land cells to a queue.
// 4. Process queue level by level. If any popped cell is in the last row, return true.
// Time Complexity: O(R * C * log(R * C)).
// Space Complexity: O(R * C) for the grid and queue.

class Solution {
public:
    int ROW;
    int COL;
    vector<vector<int>> directions{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

    bool bfs(vector<vector<int>> &grid, int i, int j) {
        queue<pair<int, int>> que;
        que.push({i, j});
        grid[i][j] = 1; // Mark visited

        while(!que.empty()) {
            auto temp = que.front();
            que.pop();

            int x = temp.first;
            int y = temp.second;

            // If reached the bottom row
            if(x == ROW-1)
                return true;

            for(vector<int> & dir : directions) {
                int new_x = x + dir[0];
                int new_y = y + dir[1];

                // Check bounds and if land (0)
                if(new_x >= 0 && new_x < ROW && new_y >= 0 && new_y < COL && grid[new_x][new_y] == 0) {
                    que.push({new_x, new_y});
                    grid[new_x][new_y] = 1; // Mark visited immediately
                }
            }
        }
        return false;
    }

    bool canCross(vector<vector<int>>& cells, int day) {
        vector<vector<int>> grid(ROW, vector<int>(COL, 0));

        // Fill water cells
        for (int i = 0; i <= day; ++i) {
            int r = cells[i][0] - 1;
            int c = cells[i][1] - 1;
            grid[r][c] = 1;
        }

        // Try BFS starting from any top row land cell
        for (int j = 0; j < COL; j++) {
            if (grid[0][j] == 0 && bfs(grid, 0, j)) {
                return true;
            }
        }
        return false;
    }

    int latestDayToCross(int row, int col, vector<vector<int>>& cells) {
        ROW = row;
        COL = col;

        int n = cells.size();
        int l = 0;
        int r = cells.size()-1;
        int lastDay = 0;

        while(l <= r) {
            int mid = l + (r-l)/2;

            if(canCross(cells, mid)) {
                lastDay = mid + 1;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }

        return lastDay;
    }
};

/*
*
* Dry Run
* Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]]
* * Iteration 1:
* l=0, r=3, mid=1
* Grid after filling 0..1: (0,0) is Water, (0,1) is Water.
* Top row has no land (0).
* canCross returns False.
* r becomes 0.
* * Iteration 2:
* l=0, r=0, mid=0
* Grid after filling 0: (0,0) is Water.
* Top row land at (0,1).
* BFS starts at (0,1). Neighbors: (1,1) is Land.
* (1,1) is in bottom row.
* canCross returns True.
* lastDay = 1.
* l becomes 1.
* * Termination:
* l(1) > r(0). Loop ends.
* Returns lastDay = 1.
*/

```

## üìÑ License

This repository is released under the [MIT License](https://www.google.com/search?q=./LICENSE).

> **This repository and its solutions are provided for educational purposes only and are not intended for commercial use. Please refer to the [LeetCode problem statement](https://leetcode.com/problems/last-day-where-you-can-still-cross/) for original content and copyright.**

## üë®‚Äçüíª Author

- [imnilesh18](https://github.com/imnilesh18)
